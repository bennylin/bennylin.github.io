/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
/**
 * Constructs a string from one or more Unicode character codepoint values
 * passed as integer parameters.
 *
 * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
 * @return {string|null}      The new String object.
 */
String.kmwFromCharCode = function (cp0) {
    var chars = [], i;
    for (i = 0; i < arguments.length; i++) {
        var c = Number(arguments[i]);
        if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
            throw new RangeError("Invalid code point " + c);
        }
        if (c < 0x10000) {
            chars.push(c);
        }
        else {
            c -= 0x10000;
            chars.push((c >> 10) + 0xD800);
            chars.push((c % 0x400) + 0xDC00);
        }
    }
    return String.fromCharCode.apply(undefined, chars);
};
/**
 * Returns a number indicating the Unicode value of the character at the given
 * code point index, with support for supplementary plane characters.
 *
 * @param  {number}  codePointIndex  The code point index into the string (not
                                     the code unit index) to return
 * @return {number}                  The Unicode character value
 */
String.prototype.kmwCharCodeAt = function (codePointIndex) {
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0 || codePointIndex >= str.length) {
        return NaN;
    }
    for (var i = 0; i < codePointIndex; i++) {
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        if (codeUnitIndex === null)
            return NaN;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
        }
    }
    return first;
};
/**
 * Returns the code point index within the calling String object of the first occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  [fromIndex]    Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.indexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the code point index within the calling String object of the last occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  fromIndex      Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the length of the string in code points, as opposed to code units.
 *
 * @return {number}                 The length of the string in code points
 */
String.prototype.kmwLength = function () {
    var str = String(this);
    if (str.length == 0)
        return 0;
    for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return i;
};
/**
 * Extracts a section of a string and returns a new string.
 *
 * @param  {number}  beginSlice    The start code point index in the string to
 *                                 extract from
 * @param  {number}  endSlice      Optional end code point index in the string
 *                                 to extract to
 * @return {string}                The substring as selected by beginSlice and
 *                                 endSlice
 */
String.prototype.kmwSlice = function (beginSlice, endSlice) {
    var str = String(this);
    var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
    var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
    if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
        return '';
    else
        return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
};
/**
 * Returns the characters in a string beginning at the specified location through
 * the specified number of characters.
 *
 * @param  {number}  start         The start code point index in the string to
 *                                 extract from
 * @param  {number=}  length        Optional length to extract
 * @return {string}                The substring as selected by start and length
 */
String.prototype.kmwSubstr = function (start, length) {
    var str = String(this);
    if (start < 0) {
        start = str.kmwLength() + start;
    }
    if (start < 0)
        start = 0;
    var startCodeUnit = str.kmwCodePointToCodeUnit(start);
    var endCodeUnit = startCodeUnit;
    if (startCodeUnit === null)
        return '';
    if (arguments.length < 2) {
        endCodeUnit = str.length;
    }
    else {
        for (var i = 0; i < length; i++)
            endCodeUnit = str.kmwNextChar(endCodeUnit);
    }
    if (endCodeUnit === null)
        return str.substring(startCodeUnit);
    else
        return str.substring(startCodeUnit, endCodeUnit);
};
/**
 * Returns the characters in a string between two indexes into the string.
 *
 * @param  {number}  indexA        The start code point index in the string to
 *                                 extract from
 * @param  {number}  indexB        The end code point index in the string to
 *                                 extract to
 * @return {string}                The substring as selected by indexA and indexB
 */
String.prototype.kmwSubstring = function (indexA, indexB) {
    var str = String(this), indexACodeUnit, indexBCodeUnit;
    if (typeof (indexB) == 'undefined') {
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.length;
    }
    else {
        if (indexA > indexB) {
            var c = indexA;
            indexA = indexB;
            indexB = c;
        }
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
    }
    if (isNaN(indexACodeUnit) || indexACodeUnit === null)
        indexACodeUnit = 0;
    if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
        indexBCodeUnit = str.length;
    return str.substring(indexACodeUnit, indexBCodeUnit);
};
/*
  Helper functions
*/
/**
 * Returns the code unit index for the next code point in the string, accounting for
 * supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to increment
 * @return {number|null}                 The index of the next code point in the string,
 *                                       in code units
 */
String.prototype.kmwNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            if (codeUnitIndex == str.length - 2) {
                return null;
            }
            return codeUnitIndex + 2;
        }
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string, accounting
 * for supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to decrement
 * @return {number|null}                 The index of the previous code point in the
 *                                       string, in code units
*/
String.prototype.kmwPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    var second = str.charCodeAt(codeUnitIndex - 1);
    if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
        var first = str.charCodeAt(codeUnitIndex - 2);
        if (first >= 0xD800 && first <= 0xDBFF) {
            return codeUnitIndex - 2;
        }
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the corresponding code unit index to the code point index passed
 *
 * @param  {number|null} codePointIndex  A code point index in the string
 * @return {number|null}                 The corresponding code unit index
 */
String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
    if (codePointIndex === null)
        return null;
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0) {
        codeUnitIndex = str.length;
        for (var i = 0; i > codePointIndex; i--)
            codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
        return codeUnitIndex;
    }
    if (codePointIndex == str.kmwLength())
        return str.length;
    for (var i = 0; i < codePointIndex; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return codeUnitIndex;
};
/**
 * Returns the corresponding code point index to the code unit index passed
 *
 * @param  {number|null}  codeUnitIndex  A code unit index in the string
 * @return {number|null}                 The corresponding code point index
 */
String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null)
        return null;
    else if (codeUnitIndex == 0)
        return 0;
    else if (codeUnitIndex < 0)
        return str.substr(codeUnitIndex).kmwLength();
    else
        return str.substr(0, codeUnitIndex).kmwLength();
};
/**
 * Returns the character at a the code point index passed
 *
 * @param  {number}  codePointIndex  A code point index in the string
 * @return {string}                  The corresponding character
 */
String.prototype.kmwCharAt = function (codePointIndex) {
    var str = String(this);
    if (codePointIndex >= 0)
        return str.kmwSubstr(codePointIndex, 1);
    else
        return '';
};
/**
 * String prototype library extensions for basic plane characters,
 * to simplify enabling or disabling supplementary plane functionality (I3319)
 */
/**
 * Returns the code unit index for the next code point in the string
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string
 *
 * @param  {number}  codeUnitIndex    A code unit index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the code unit index for a code point index
 *
 * @param  {number}  codePointIndex   A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
    return codePointIndex;
};
/**
 * Returns the code point index for a code unit index
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
    return codeUnitIndex;
};
/**
 * Returns the length of a BMP string
 *
 * @return {number}                   The length in code points
 */
String.prototype.kmwBMPLength = function () {
    var str = String(this);
    return str.length;
};
/**
 * Returns a substring
 *
 * @param  {number}  n
 * @param  {number=}  ln
 * @return {string}
 */
String.prototype.kmwBMPSubstr = function (n, ln) {
    var str = String(this);
    if (n > -1)
        return str.substr(n, ln);
    else
        return str.substr(str.length + n, -n);
};
/**
 * Enable or disable supplementary plane string handling
 *
 * @param  {boolean}  bEnable
 */
String.kmwEnableSupplementaryPlane = function (bEnable) {
    var p = String.prototype;
    String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
    p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
    p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
    p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
    p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
    p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
    p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
    p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
    p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
    p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
    p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
    p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
    p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
};
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            // Defines the base Deadkey-tracking object.
            var Deadkey = /** @class */ (function () {
                function Deadkey(pos, id) {
                    this.p = pos;
                    this.d = id;
                    this.o = Deadkey.ordinalSeed++;
                }
                Deadkey.prototype.match = function (p, d) {
                    var result = (this.p == p && this.d == d);
                    return result;
                };
                Deadkey.prototype.set = function () {
                    this.matched = 1;
                };
                Deadkey.prototype.reset = function () {
                    this.matched = 0;
                };
                Deadkey.prototype.before = function (other) {
                    return this.o < other.o;
                };
                Deadkey.prototype.clone = function () {
                    var dk = new Deadkey(this.p, this.d);
                    dk.o = this.o;
                    return dk;
                };
                Deadkey.ordinalSeed = 0;
                /**
                 * Sorts the deadkeys in reverse order.
                 */
                Deadkey.sortFunc = function (a, b) {
                    // We want descending order, so we want 'later' deadkeys first.
                    if (a.p != b.p) {
                        return b.p - a.p;
                    }
                    else {
                        return b.o - a.o;
                    }
                };
                return Deadkey;
            }());
            text.Deadkey = Deadkey;
            // Object-orients deadkey management.
            var DeadkeyTracker = /** @class */ (function () {
                function DeadkeyTracker() {
                    this.dks = [];
                }
                DeadkeyTracker.prototype.toSortedArray = function () {
                    this.dks = this.dks.sort(Deadkey.sortFunc);
                    return [].concat(this.dks);
                };
                DeadkeyTracker.prototype.clone = function () {
                    var dkt = new DeadkeyTracker();
                    var dks = this.toSortedArray();
                    // Make sure to clone the deadkeys themselves - the Deadkey object is mutable.
                    dkt.dks = [];
                    dks.forEach(function (value) {
                        dkt.dks.push(value.clone());
                    });
                    return dkt;
                };
                /**
                 * Function     isMatch
                 * Scope        Public
                 * @param       {number}      caretPos  current cursor position
                 * @param       {number}      n         expected offset of deadkey from cursor
                 * @param       {number}      d         deadkey
                 * @return      {boolean}               True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                DeadkeyTracker.prototype.isMatch = function (caretPos, n, d) {
                    if (this.dks.length == 0) {
                        return false; // I3318
                    }
                    var sp = caretPos;
                    n = sp - n;
                    for (var i = 0; i < this.dks.length; i++) {
                        // Don't re-match an already-matched deadkey.  It's possible to have two identical 
                        // entries, and they should be kept separately.
                        if (this.dks[i].match(n, d) && !this.dks[i].matched) {
                            this.dks[i].set();
                            // Assumption:  since we match the first possible entry in the array, we
                            // match the entry with the lower ordinal - the 'first' deadkey in the position.
                            return true; // I3318
                        }
                    }
                    this.resetMatched(); // I3318
                    return false;
                };
                DeadkeyTracker.prototype.add = function (dk) {
                    this.dks = this.dks.concat(dk);
                };
                DeadkeyTracker.prototype.remove = function (dk) {
                    var index = this.dks.indexOf(dk);
                    this.dks.splice(index, 1);
                };
                DeadkeyTracker.prototype.clear = function () {
                    this.dks = [];
                };
                DeadkeyTracker.prototype.resetMatched = function () {
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        dk.reset();
                    }
                };
                DeadkeyTracker.prototype.deleteMatched = function () {
                    for (var Li = 0; Li < this.dks.length; Li++) {
                        if (this.dks[Li].matched) {
                            this.dks.splice(Li--, 1); // Don't forget to decrement!
                        }
                    }
                };
                /**
                 * Function     adjustPositions (formerly _DeadkeyAdjustPos)
                 * Scope        Private
                 * @param       {number}      Lstart      start position in context
                 * @param       {number}      Ldelta      characters to adjust by
                 * Description  Adjust saved positions of deadkeys in context
                 */
                DeadkeyTracker.prototype.adjustPositions = function (Lstart, Ldelta) {
                    if (Ldelta == 0) {
                        return;
                    }
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        if (dk.p > Lstart) {
                            dk.p += Ldelta;
                        }
                    }
                };
                DeadkeyTracker.prototype.count = function () {
                    return this.dks.length;
                };
                return DeadkeyTracker;
            }());
            text.DeadkeyTracker = DeadkeyTracker;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * This class is defined within its own file so that it can be loaded by code outside of KMW without
             * having to actually load the entirety of KMW.
             */
            var KeyEvent = /** @class */ (function () {
                function KeyEvent() {
                }
                return KeyEvent;
            }());
            text.KeyEvent = KeyEvent;
            ;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines KMW's string extension functions.
///<reference path="../text/kmwstring.ts" />
// Defines deadkey management in a manner attachable to each element interface.
///<reference path="../text/deadkeys.ts" />
// Defines relevant LMLayer-related interfaces.
///<reference path="../includes/lmMsgs.d.ts" />
// Defines the KeyEvent type.
///<reference path="keyEvent.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text_1) {
            var TextTransform = /** @class */ (function () {
                function TextTransform(insert, deleteLeft, deleteRight) {
                    this.insert = insert;
                    this.deleteLeft = deleteLeft;
                    this.deleteRight = deleteRight || 0;
                }
                TextTransform.nil = new TextTransform('', 0, 0);
                return TextTransform;
            }());
            text_1.TextTransform = TextTransform;
            var Transcription = /** @class */ (function () {
                function Transcription(keystroke, transform, preInput, alternates /*, removedDks: Deadkey[], insertedDks: Deadkey[]*/) {
                    var token = this.token = Transcription.tokenSeed++;
                    this.keystroke = keystroke;
                    this.transform = transform;
                    this.alternates = alternates;
                    this.preInput = preInput;
                    this.transform.id = this.token;
                    // Assign the ID to each alternate, as well.
                    if (alternates) {
                        alternates.forEach(function (alt) {
                            alt.sample.id = token;
                        });
                    }
                }
                Transcription.tokenSeed = 0;
                return Transcription;
            }());
            text_1.Transcription = Transcription;
            var OutputTarget = /** @class */ (function () {
                function OutputTarget() {
                    this._dks = new text.DeadkeyTracker();
                }
                OutputTarget.prototype.deadkeys = function () {
                    return this._dks;
                };
                OutputTarget.prototype.hasDeadkeyMatch = function (n, d) {
                    return this.deadkeys().isMatch(this.getDeadkeyCaret(), n, d);
                };
                OutputTarget.prototype.insertDeadkeyBeforeCaret = function (d) {
                    var dk = new text_1.Deadkey(this.getDeadkeyCaret(), d);
                    this.deadkeys().add(dk);
                };
                /**
                 * Should be called by each output target immediately before text mutation operations occur.
                 *
                 * Maintains solutions to old issues:  I3318,I3319
                 * @param {number} delta  Use negative values if characters were deleted, positive if characters were added.
                 */
                OutputTarget.prototype.adjustDeadkeys = function (delta) {
                    this.deadkeys().adjustPositions(this.getDeadkeyCaret(), delta);
                };
                /**
                 * Needed to properly clone deadkeys for use with Mock element interfaces toward predictive text purposes.
                 * @param {object}  dks   An existing set of deadkeys to deep-copy for use by this element interface.
                 */
                OutputTarget.prototype.setDeadkeys = function (dks) {
                    this._dks = dks.clone();
                };
                /**
                 * Determines the basic operations needed to reconstruct the current OutputTarget's text from the prior state specified
                 * by another OutputTarget based on their text and caret positions.
                 *
                 * This is designed for use as a "before and after" comparison to determine the effect of a single keyboard rule at a time.
                 * As such, it assumes that the caret is immediately after any inserted text.
                 * @param from An output target (preferably a Mock) representing the prior state of the input/output system.
                 */
                OutputTarget.prototype.buildTransformFrom = function (original) {
                    var to = this.getText();
                    var from = original.getText();
                    var fromCaret = original.getDeadkeyCaret();
                    var toCaret = this.getDeadkeyCaret();
                    // Step 1:  Determine the number of left-deletions.
                    for (var newCaret = 0; newCaret < fromCaret; newCaret++) {
                        if (from._kmwCharAt(newCaret) != to._kmwCharAt(newCaret)) {
                            break;
                        }
                    }
                    var deletedLeft = fromCaret - newCaret;
                    // Step 2:  Determine the other properties.
                    // Since the 'after' OutputTarget's caret indicates the end of any inserted text, we
                    // can easily calculate the rest.
                    var insertedLength = toCaret - newCaret;
                    var delta = to._kmwSubstr(newCaret, insertedLength);
                    var undeletedRight = to._kmwLength() - toCaret;
                    var originalRight = from._kmwLength() - fromCaret;
                    return new TextTransform(delta, deletedLeft, originalRight - undeletedRight);
                };
                OutputTarget.prototype.buildTranscriptionFrom = function (original, keyEvent, alternates) {
                    var transform = this.buildTransformFrom(original);
                    // If we ever decide to re-add deadkey tracking, this is the place for it.
                    return new Transcription(keyEvent, transform, Mock.from(original), alternates);
                };
                /**
                 * Restores the `OutputTarget` to the indicated state.  Designed for use with `Transcription.preInput`.
                 * @param original An `OutputTarget` (usually a `Mock`).
                 */
                OutputTarget.prototype.restoreTo = function (original) {
                    //
                    this.setTextBeforeCaret(original.getTextBeforeCaret());
                    this.setTextAfterCaret(original.getTextAfterCaret());
                    // Also, restore the deadkeys!
                    this._dks = original._dks.clone();
                };
                OutputTarget.prototype.apply = function (transform) {
                    if (transform.deleteRight) {
                        this.setTextAfterCaret(this.getTextAfterCaret()._kmwSubstr(transform.deleteRight));
                    }
                    if (transform.deleteLeft) {
                        this.deleteCharsBeforeCaret(transform.deleteLeft);
                    }
                    if (transform.insert) {
                        this.insertTextBeforeCaret(transform.insert);
                    }
                    // We assume that all deadkeys are invalidated after applying a Transform, since
                    // prediction implies we'll be completing a word, post-deadkeys.
                    this._dks.clear();
                };
                /**
                 * Helper to `restoreTo` - allows directly setting the 'before' context to that of another
                 * `OutputTarget`.
                 * @param s
                 */
                OutputTarget.prototype.setTextBeforeCaret = function (s) {
                    // This one's easy enough to provide a default implementation for.
                    this.deleteCharsBeforeCaret(this.getTextBeforeCaret()._kmwLength());
                    this.insertTextBeforeCaret(s);
                };
                /**
                 * Saves element-specific state properties prone to mutation, enabling restoration after
                 * text-output operations.
                 */
                OutputTarget.prototype.saveProperties = function () {
                    // Most element interfaces won't need anything here.
                };
                /**
                 * Restores previously-saved element-specific state properties.  Designed for use after text-output
                 * ops to facilitate more-seamless web-dev and user interactions.
                 */
                OutputTarget.prototype.restoreProperties = function () {
                    // Most element interfaces won't need anything here. 
                };
                return OutputTarget;
            }());
            text_1.OutputTarget = OutputTarget;
            // Due to some interesting requirements on compile ordering in TS,
            // this needs to be in the same file as OutputTarget now.
            var Mock = /** @class */ (function (_super) {
                __extends(Mock, _super);
                function Mock(text, caretPos) {
                    var _this = _super.call(this) || this;
                    _this.text = text ? text : "";
                    var defaultLength = _this.text._kmwLength();
                    _this.caretIndex = caretPos ? caretPos : defaultLength;
                    return _this;
                }
                // Clones the state of an existing EditableElement, creating a Mock version of its state.
                Mock.from = function (outputTarget) {
                    var preText = outputTarget.getTextBeforeCaret();
                    var caretIndex = preText._kmwLength();
                    // We choose to ignore (rather, pre-emptively remove) any actively-selected text,
                    // as since it's always removed instantly during any text mutation operations.
                    var clone = new Mock(preText + outputTarget.getTextAfterCaret(), caretIndex);
                    clone.setDeadkeys(outputTarget.deadkeys());
                    return clone;
                };
                Mock.prototype.getElement = function () {
                    return null;
                };
                Mock.prototype.clearSelection = function () {
                    return;
                };
                Mock.prototype.invalidateSelection = function () {
                    return;
                };
                Mock.prototype.hasSelection = function () {
                    return true;
                };
                Mock.prototype.getDeadkeyCaret = function () {
                    return this.caretIndex;
                };
                Mock.prototype.setDeadkeyCaret = function (index) {
                    if (index < 0 || index > this.text._kmwLength()) {
                        throw new Error("Provided caret index is out of range.");
                    }
                    this.caretIndex = index;
                };
                Mock.prototype.getTextBeforeCaret = function () {
                    return this.text.kmwSubstr(0, this.caretIndex);
                };
                Mock.prototype.getTextAfterCaret = function () {
                    return this.text.kmwSubstr(this.caretIndex);
                };
                Mock.prototype.getText = function () {
                    return this.text;
                };
                Mock.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (dn >= 0) {
                        if (dn > this.caretIndex) {
                            dn = this.caretIndex;
                        }
                        this.text = this.text.kmwSubstr(0, this.caretIndex - dn) + this.getTextAfterCaret();
                        this.caretIndex -= dn;
                    }
                };
                Mock.prototype.insertTextBeforeCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s + this.getTextAfterCaret();
                    this.caretIndex += s.kmwLength();
                };
                Mock.prototype.setTextAfterCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s;
                };
                return Mock;
            }(OutputTarget));
            text_1.Mock = Mock;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="text/outputTarget.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var AttachmentInfo = /** @class */ (function () {
            function AttachmentInfo(eleInterface, kbd, touch) {
                this.interface = eleInterface;
                this.keyboard = kbd;
                this.touchEnabled = touch || false;
            }
            return AttachmentInfo;
        }());
        keyman.AttachmentInfo = AttachmentInfo;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines a number of KMW objects.
/// <reference path="kmwtypedefs.ts"/>
/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */
(function (e, t) { if (typeof define === "function" && define.amd) {
    define(t);
}
else if (typeof exports === "object") {
    module.exports = t();
}
else {
    e.returnExports = t();
} })(this, function () {
    "use strict";
    var e = Function.call.bind(Function.apply);
    var t = Function.call.bind(Function.call);
    var r = Array.isArray;
    var n = Object.keys;
    var o = function notThunker(t) { return function notThunk() { return !e(t, this, arguments); }; };
    var i = function (e) { try {
        e();
        return false;
    }
    catch (t) {
        return true;
    } };
    var a = function valueOrFalseIfThrows(e) { try {
        return e();
    }
    catch (t) {
        return false;
    } };
    var u = o(i);
    var f = function () { return !i(function () { return Object.defineProperty({}, "x", { get: function () { } }); }); };
    var s = !!Object.defineProperty && f();
    var c = function foo() { }.name === "foo";
    var l = Function.call.bind(Array.prototype.forEach);
    var p = Function.call.bind(Array.prototype.reduce);
    var v = Function.call.bind(Array.prototype.filter);
    var y = Function.call.bind(Array.prototype.some);
    var h = function (e, t, r, n) { if (!n && t in e) {
        return;
    } if (s) {
        Object.defineProperty(e, t, { configurable: true, enumerable: false, writable: true, value: r });
    }
    else {
        e[t] = r;
    } };
    var b = function (e, t, r) { l(n(t), function (n) { var o = t[n]; h(e, n, o, !!r); }); };
    var g = Function.call.bind(Object.prototype.toString);
    var d = typeof /abc/ === "function" ? function IsCallableSlow(e) { return typeof e === "function" && g(e) === "[object Function]"; } : function IsCallableFast(e) { return typeof e === "function"; };
    var m = { getter: function (e, t, r) { if (!s) {
            throw new TypeError("getters require true ES5 support");
        } Object.defineProperty(e, t, { configurable: true, enumerable: false, get: r }); }, proxy: function (e, t, r) { if (!s) {
            throw new TypeError("getters require true ES5 support");
        } var n = Object.getOwnPropertyDescriptor(e, t); Object.defineProperty(r, t, { configurable: n.configurable, enumerable: n.enumerable, get: function getKey() { return e[t]; }, set: function setKey(r) { e[t] = r; } }); }, redefine: function (e, t, r) { if (s) {
            var n = Object.getOwnPropertyDescriptor(e, t);
            n.value = r;
            Object.defineProperty(e, t, n);
        }
        else {
            e[t] = r;
        } }, defineByDescriptor: function (e, t, r) { if (s) {
            Object.defineProperty(e, t, r);
        }
        else if ("value" in r) {
            e[t] = r.value;
        } }, preserveToString: function (e, t) { if (t && d(t.toString)) {
            h(e, "toString", t.toString.bind(t), true);
        } } };
    var O = Object.create || function (e, t) { var r = function Prototype() { }; r.prototype = e; var o = new r; if (typeof t !== "undefined") {
        n(t).forEach(function (e) { m.defineByDescriptor(o, e, t[e]); });
    } return o; };
    var w = function (e, t) { if (!Object.setPrototypeOf) {
        return false;
    } return a(function () { var r = function Subclass(t) { var r = new e(t); Object.setPrototypeOf(r, Subclass.prototype); return r; }; Object.setPrototypeOf(r, e); r.prototype = O(e.prototype, { constructor: { value: r } }); return t(r); }); };
    var j = function () { if (typeof self !== "undefined") {
        return self;
    } if (typeof window !== "undefined") {
        return window;
    } if (typeof global !== "undefined") {
        return global;
    } throw new Error("unable to locate global object"); };
    var S = j();
    var T = S.isFinite;
    var I = Function.call.bind(String.prototype.indexOf);
    var E = Function.apply.bind(Array.prototype.indexOf);
    var P = Function.call.bind(Array.prototype.concat);
    var C = Function.call.bind(String.prototype.slice);
    var M = Function.call.bind(Array.prototype.push);
    var x = Function.apply.bind(Array.prototype.push);
    var N = Function.call.bind(Array.prototype.shift);
    var A = Math.max;
    var R = Math.min;
    var _ = Math.floor;
    var k = Math.abs;
    var L = Math.exp;
    var F = Math.log;
    var D = Math.sqrt;
    var z = Function.call.bind(Object.prototype.hasOwnProperty);
    var q;
    var W = function () { };
    var G = S.Map;
    var H = G && G.prototype["delete"];
    var V = G && G.prototype.get;
    var B = G && G.prototype.has;
    var U = G && G.prototype.set;
    var $ = S.Symbol || {};
    var J = $.species || "@@species";
    var X = Number.isNaN || function isNaN(e) { return e !== e; };
    var K = Number.isFinite || function isFinite(e) { return typeof e === "number" && T(e); };
    var Z = d(Math.sign) ? Math.sign : function sign(e) { var t = Number(e); if (t === 0) {
        return t;
    } if (X(t)) {
        return t;
    } return t < 0 ? -1 : 1; };
    var Y = function log1p(e) { var t = Number(e); if (t < -1 || X(t)) {
        return NaN;
    } if (t === 0 || t === Infinity) {
        return t;
    } if (t === -1) {
        return -Infinity;
    } return 1 + t - 1 === 0 ? t : t * (F(1 + t) / (1 + t - 1)); };
    var Q = function isArguments(e) { return g(e) === "[object Arguments]"; };
    var ee = function isArguments(e) { return e !== null && typeof e === "object" && typeof e.length === "number" && e.length >= 0 && g(e) !== "[object Array]" && g(e.callee) === "[object Function]"; };
    var te = Q(arguments) ? Q : ee;
    var re = { primitive: function (e) { return e === null || typeof e !== "function" && typeof e !== "object"; }, string: function (e) { return g(e) === "[object String]"; }, regex: function (e) { return g(e) === "[object RegExp]"; }, symbol: function (e) { return typeof S.Symbol === "function" && typeof e === "symbol"; } };
    var ne = function overrideNative(e, t, r) { var n = e[t]; h(e, t, r, true); m.preserveToString(e[t], n); };
    var oe = typeof $ === "function" && typeof $["for"] === "function" && re.symbol($());
    var ie = re.symbol($.iterator) ? $.iterator : "_es6-shim iterator_";
    if (S.Set && typeof (new S.Set)["@@iterator"] === "function") {
        ie = "@@iterator";
    }
    if (!S.Reflect) {
        h(S, "Reflect", {}, true);
    }
    var ae = S.Reflect;
    var ue = String;
    var fe = typeof document === "undefined" || !document ? null : document.all;
    var se = fe == null ? function isNullOrUndefined(e) { return e == null; } : function isNullOrUndefinedAndNotDocumentAll(e) { return e == null && e !== fe; };
    var ce = { Call: function Call(t, r) { var n = arguments.length > 2 ? arguments[2] : []; if (!ce.IsCallable(t)) {
            throw new TypeError(t + " is not a function");
        } return e(t, r, n); }, RequireObjectCoercible: function (e, t) { if (se(e)) {
            throw new TypeError(t || "Cannot call method on " + e);
        } return e; }, TypeIsObject: function (e) { if (e === void 0 || e === null || e === true || e === false) {
            return false;
        } return typeof e === "function" || typeof e === "object" || e === fe; }, ToObject: function (e, t) { return Object(ce.RequireObjectCoercible(e, t)); }, IsCallable: d, IsConstructor: function (e) { return ce.IsCallable(e); }, ToInt32: function (e) { return ce.ToNumber(e) >> 0; }, ToUint32: function (e) { return ce.ToNumber(e) >>> 0; }, ToNumber: function (e) { if (g(e) === "[object Symbol]") {
            throw new TypeError("Cannot convert a Symbol value to a number");
        } return +e; }, ToInteger: function (e) { var t = ce.ToNumber(e); if (X(t)) {
            return 0;
        } if (t === 0 || !K(t)) {
            return t;
        } return (t > 0 ? 1 : -1) * _(k(t)); }, ToLength: function (e) { var t = ce.ToInteger(e); if (t <= 0) {
            return 0;
        } if (t > Number.MAX_SAFE_INTEGER) {
            return Number.MAX_SAFE_INTEGER;
        } return t; }, SameValue: function (e, t) { if (e === t) {
            if (e === 0) {
                return 1 / e === 1 / t;
            }
            return true;
        } return X(e) && X(t); }, SameValueZero: function (e, t) { return e === t || X(e) && X(t); }, IsIterable: function (e) { return ce.TypeIsObject(e) && (typeof e[ie] !== "undefined" || te(e)); }, GetIterator: function (e) { if (te(e)) {
            return new q(e, "value");
        } var t = ce.GetMethod(e, ie); if (!ce.IsCallable(t)) {
            throw new TypeError("value is not an iterable");
        } var r = ce.Call(t, e); if (!ce.TypeIsObject(r)) {
            throw new TypeError("bad iterator");
        } return r; }, GetMethod: function (e, t) { var r = ce.ToObject(e)[t]; if (se(r)) {
            return void 0;
        } if (!ce.IsCallable(r)) {
            throw new TypeError("Method not callable: " + t);
        } return r; }, IteratorComplete: function (e) { return !!e.done; }, IteratorClose: function (e, t) { var r = ce.GetMethod(e, "return"); if (r === void 0) {
            return;
        } var n, o; try {
            n = ce.Call(r, e);
        }
        catch (i) {
            o = i;
        } if (t) {
            return;
        } if (o) {
            throw o;
        } if (!ce.TypeIsObject(n)) {
            throw new TypeError("Iterator's return method returned a non-object.");
        } }, IteratorNext: function (e) { var t = arguments.length > 1 ? e.next(arguments[1]) : e.next(); if (!ce.TypeIsObject(t)) {
            throw new TypeError("bad iterator");
        } return t; }, IteratorStep: function (e) { var t = ce.IteratorNext(e); var r = ce.IteratorComplete(t); return r ? false : t; }, Construct: function (e, t, r, n) { var o = typeof r === "undefined" ? e : r; if (!n && ae.construct) {
            return ae.construct(e, t, o);
        } var i = o.prototype; if (!ce.TypeIsObject(i)) {
            i = Object.prototype;
        } var a = O(i); var u = ce.Call(e, a, t); return ce.TypeIsObject(u) ? u : a; }, SpeciesConstructor: function (e, t) { var r = e.constructor; if (r === void 0) {
            return t;
        } if (!ce.TypeIsObject(r)) {
            throw new TypeError("Bad constructor");
        } var n = r[J]; if (se(n)) {
            return t;
        } if (!ce.IsConstructor(n)) {
            throw new TypeError("Bad @@species");
        } return n; }, CreateHTML: function (e, t, r, n) { var o = ce.ToString(e); var i = "<" + t; if (r !== "") {
            var a = ce.ToString(n);
            var u = a.replace(/"/g, "&quot;");
            i += " " + r + '="' + u + '"';
        } var f = i + ">"; var s = f + o; return s + "</" + t + ">"; }, IsRegExp: function IsRegExp(e) { if (!ce.TypeIsObject(e)) {
            return false;
        } var t = e[$.match]; if (typeof t !== "undefined") {
            return !!t;
        } return re.regex(e); }, ToString: function ToString(e) { return ue(e); } };
    if (s && oe) {
        var le = function defineWellKnownSymbol(e) { if (re.symbol($[e])) {
            return $[e];
        } var t = $["for"]("Symbol." + e); Object.defineProperty($, e, { configurable: false, enumerable: false, writable: false, value: t }); return t; };
        if (!re.symbol($.search)) {
            var pe = le("search");
            var ve = String.prototype.search;
            h(RegExp.prototype, pe, function search(e) { return ce.Call(ve, e, [this]); });
            var ye = function search(e) { var t = ce.RequireObjectCoercible(this); if (!se(e)) {
                var r = ce.GetMethod(e, pe);
                if (typeof r !== "undefined") {
                    return ce.Call(r, e, [t]);
                }
            } return ce.Call(ve, t, [ce.ToString(e)]); };
            ne(String.prototype, "search", ye);
        }
        if (!re.symbol($.replace)) {
            var he = le("replace");
            var be = String.prototype.replace;
            h(RegExp.prototype, he, function replace(e, t) { return ce.Call(be, e, [this, t]); });
            var ge = function replace(e, t) { var r = ce.RequireObjectCoercible(this); if (!se(e)) {
                var n = ce.GetMethod(e, he);
                if (typeof n !== "undefined") {
                    return ce.Call(n, e, [r, t]);
                }
            } return ce.Call(be, r, [ce.ToString(e), t]); };
            ne(String.prototype, "replace", ge);
        }
        if (!re.symbol($.split)) {
            var de = le("split");
            var me = String.prototype.split;
            h(RegExp.prototype, de, function split(e, t) { return ce.Call(me, e, [this, t]); });
            var Oe = function split(e, t) { var r = ce.RequireObjectCoercible(this); if (!se(e)) {
                var n = ce.GetMethod(e, de);
                if (typeof n !== "undefined") {
                    return ce.Call(n, e, [r, t]);
                }
            } return ce.Call(me, r, [ce.ToString(e), t]); };
            ne(String.prototype, "split", Oe);
        }
        var we = re.symbol($.match);
        var je = we && function () { var e = {}; e[$.match] = function () { return 42; }; return "a".match(e) !== 42; }();
        if (!we || je) {
            var Se = le("match");
            var Te = String.prototype.match;
            h(RegExp.prototype, Se, function match(e) { return ce.Call(Te, e, [this]); });
            var Ie = function match(e) { var t = ce.RequireObjectCoercible(this); if (!se(e)) {
                var r = ce.GetMethod(e, Se);
                if (typeof r !== "undefined") {
                    return ce.Call(r, e, [t]);
                }
            } return ce.Call(Te, t, [ce.ToString(e)]); };
            ne(String.prototype, "match", Ie);
        }
    }
    var Ee = function wrapConstructor(e, t, r) { m.preserveToString(t, e); if (Object.setPrototypeOf) {
        Object.setPrototypeOf(e, t);
    } if (s) {
        l(Object.getOwnPropertyNames(e), function (n) { if (n in W || r[n]) {
            return;
        } m.proxy(e, n, t); });
    }
    else {
        l(Object.keys(e), function (n) { if (n in W || r[n]) {
            return;
        } t[n] = e[n]; });
    } t.prototype = e.prototype; m.redefine(e.prototype, "constructor", t); };
    var Pe = function () { return this; };
    var Ce = function (e) { if (s && !z(e, J)) {
        m.getter(e, J, Pe);
    } };
    var Me = function (e, t) { var r = t || function iterator() { return this; }; h(e, ie, r); if (!e[ie] && re.symbol(ie)) {
        e[ie] = r;
    } };
    var xe = function createDataProperty(e, t, r) { if (s) {
        Object.defineProperty(e, t, { configurable: true, enumerable: true, writable: true, value: r });
    }
    else {
        e[t] = r;
    } };
    var Ne = function createDataPropertyOrThrow(e, t, r) { xe(e, t, r); if (!ce.SameValue(e[t], r)) {
        throw new TypeError("property is nonconfigurable");
    } };
    var Ae = function (e, t, r, n) { if (!ce.TypeIsObject(e)) {
        throw new TypeError("Constructor requires `new`: " + t.name);
    } var o = t.prototype; if (!ce.TypeIsObject(o)) {
        o = r;
    } var i = O(o); for (var a in n) {
        if (z(n, a)) {
            var u = n[a];
            h(i, a, u, true);
        }
    } return i; };
    if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
        var Re = String.fromCodePoint;
        ne(String, "fromCodePoint", function fromCodePoint(e) { return ce.Call(Re, this, arguments); });
    }
    var _e = { fromCodePoint: function fromCodePoint(e) { var t = []; var r; for (var n = 0, o = arguments.length; n < o; n++) {
            r = Number(arguments[n]);
            if (!ce.SameValue(r, ce.ToInteger(r)) || r < 0 || r > 1114111) {
                throw new RangeError("Invalid code point " + r);
            }
            if (r < 65536) {
                M(t, String.fromCharCode(r));
            }
            else {
                r -= 65536;
                M(t, String.fromCharCode((r >> 10) + 55296));
                M(t, String.fromCharCode(r % 1024 + 56320));
            }
        } return t.join(""); }, raw: function raw(e) { var t = ce.ToObject(e, "bad callSite"); var r = ce.ToObject(t.raw, "bad raw value"); var n = r.length; var o = ce.ToLength(n); if (o <= 0) {
            return "";
        } var i = []; var a = 0; var u, f, s, c; while (a < o) {
            u = ce.ToString(a);
            s = ce.ToString(r[u]);
            M(i, s);
            if (a + 1 >= o) {
                break;
            }
            f = a + 1 < arguments.length ? arguments[a + 1] : "";
            c = ce.ToString(f);
            M(i, c);
            a += 1;
        } return i.join(""); } };
    if (String.raw && String.raw({ raw: { 0: "x", 1: "y", length: 2 } }) !== "xy") {
        ne(String, "raw", _e.raw);
    }
    b(String, _e);
    var ke = function repeat(e, t) { if (t < 1) {
        return "";
    } if (t % 2) {
        return repeat(e, t - 1) + e;
    } var r = repeat(e, t / 2); return r + r; };
    var Le = Infinity;
    var Fe = { repeat: function repeat(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); var r = ce.ToInteger(e); if (r < 0 || r >= Le) {
            throw new RangeError("repeat count must be less than infinity and not overflow maximum string size");
        } return ke(t, r); }, startsWith: function startsWith(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); if (ce.IsRegExp(e)) {
            throw new TypeError('Cannot call method "startsWith" with a regex');
        } var r = ce.ToString(e); var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o = A(ce.ToInteger(n), 0); return C(t, o, o + r.length) === r; }, endsWith: function endsWith(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); if (ce.IsRegExp(e)) {
            throw new TypeError('Cannot call method "endsWith" with a regex');
        } var r = ce.ToString(e); var n = t.length; var o; if (arguments.length > 1) {
            o = arguments[1];
        } var i = typeof o === "undefined" ? n : ce.ToInteger(o); var a = R(A(i, 0), n); return C(t, a - r.length, a) === r; }, includes: function includes(e) { if (ce.IsRegExp(e)) {
            throw new TypeError('"includes" does not accept a RegExp');
        } var t = ce.ToString(e); var r; if (arguments.length > 1) {
            r = arguments[1];
        } return I(this, t, r) !== -1; }, codePointAt: function codePointAt(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); var r = ce.ToInteger(e); var n = t.length; if (r >= 0 && r < n) {
            var o = t.charCodeAt(r);
            var i = r + 1 === n;
            if (o < 55296 || o > 56319 || i) {
                return o;
            }
            var a = t.charCodeAt(r + 1);
            if (a < 56320 || a > 57343) {
                return o;
            }
            return (o - 55296) * 1024 + (a - 56320) + 65536;
        } } };
    if (String.prototype.includes && "a".includes("a", Infinity) !== false) {
        ne(String.prototype, "includes", Fe.includes);
    }
    if (String.prototype.startsWith && String.prototype.endsWith) {
        var De = i(function () { return "/a/".startsWith(/a/); });
        var ze = a(function () { return "abc".startsWith("a", Infinity) === false; });
        if (!De || !ze) {
            ne(String.prototype, "startsWith", Fe.startsWith);
            ne(String.prototype, "endsWith", Fe.endsWith);
        }
    }
    if (oe) {
        var qe = a(function () { var e = /a/; e[$.match] = false; return "/a/".startsWith(e); });
        if (!qe) {
            ne(String.prototype, "startsWith", Fe.startsWith);
        }
        var We = a(function () { var e = /a/; e[$.match] = false; return "/a/".endsWith(e); });
        if (!We) {
            ne(String.prototype, "endsWith", Fe.endsWith);
        }
        var Ge = a(function () { var e = /a/; e[$.match] = false; return "/a/".includes(e); });
        if (!Ge) {
            ne(String.prototype, "includes", Fe.includes);
        }
    }
    b(String.prototype, Fe);
    var He = ["\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003", "\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028", "\u2029\ufeff"].join("");
    var Ve = new RegExp("(^[" + He + "]+)|([" + He + "]+$)", "g");
    var Be = function trim() { return ce.ToString(ce.RequireObjectCoercible(this)).replace(Ve, ""); };
    var Ue = ["\x85", "\u200b", "\ufffe"].join("");
    var $e = new RegExp("[" + Ue + "]", "g");
    var Je = /^[-+]0x[0-9a-f]+$/i;
    var Xe = Ue.trim().length !== Ue.length;
    h(String.prototype, "trim", Be, Xe);
    var Ke = function (e) { return { value: e, done: arguments.length === 0 }; };
    var Ze = function (e) { ce.RequireObjectCoercible(e); this._s = ce.ToString(e); this._i = 0; };
    Ze.prototype.next = function () { var e = this._s; var t = this._i; if (typeof e === "undefined" || t >= e.length) {
        this._s = void 0;
        return Ke();
    } var r = e.charCodeAt(t); var n, o; if (r < 55296 || r > 56319 || t + 1 === e.length) {
        o = 1;
    }
    else {
        n = e.charCodeAt(t + 1);
        o = n < 56320 || n > 57343 ? 1 : 2;
    } this._i = t + o; return Ke(e.substr(t, o)); };
    Me(Ze.prototype);
    Me(String.prototype, function () { return new Ze(this); });
    var Ye = { from: function from(e) { var r = this; var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o, i; if (typeof n === "undefined") {
            o = false;
        }
        else {
            if (!ce.IsCallable(n)) {
                throw new TypeError("Array.from: when provided, the second argument must be a function");
            }
            if (arguments.length > 2) {
                i = arguments[2];
            }
            o = true;
        } var a = typeof (te(e) || ce.GetMethod(e, ie)) !== "undefined"; var u, f, s; if (a) {
            f = ce.IsConstructor(r) ? Object(new r) : [];
            var c = ce.GetIterator(e);
            var l, p;
            s = 0;
            while (true) {
                l = ce.IteratorStep(c);
                if (l === false) {
                    break;
                }
                p = l.value;
                try {
                    if (o) {
                        p = typeof i === "undefined" ? n(p, s) : t(n, i, p, s);
                    }
                    f[s] = p;
                }
                catch (v) {
                    ce.IteratorClose(c, true);
                    throw v;
                }
                s += 1;
            }
            u = s;
        }
        else {
            var y = ce.ToObject(e);
            u = ce.ToLength(y.length);
            f = ce.IsConstructor(r) ? Object(new r(u)) : new Array(u);
            var h;
            for (s = 0; s < u; ++s) {
                h = y[s];
                if (o) {
                    h = typeof i === "undefined" ? n(h, s) : t(n, i, h, s);
                }
                Ne(f, s, h);
            }
        } f.length = u; return f; }, of: function of() { var e = arguments.length; var t = this; var n = r(t) || !ce.IsCallable(t) ? new Array(e) : ce.Construct(t, [e]); for (var o = 0; o < e; ++o) {
            Ne(n, o, arguments[o]);
        } n.length = e; return n; } };
    b(Array, Ye);
    Ce(Array);
    q = function (e, t) { this.i = 0; this.array = e; this.kind = t; };
    b(q.prototype, { next: function () { var e = this.i; var t = this.array; if (!(this instanceof q)) {
            throw new TypeError("Not an ArrayIterator");
        } if (typeof t !== "undefined") {
            var r = ce.ToLength(t.length);
            for (; e < r; e++) {
                var n = this.kind;
                var o;
                if (n === "key") {
                    o = e;
                }
                else if (n === "value") {
                    o = t[e];
                }
                else if (n === "entry") {
                    o = [e, t[e]];
                }
                this.i = e + 1;
                return Ke(o);
            }
        } this.array = void 0; return Ke(); } });
    Me(q.prototype);
    var Qe = Array.of === Ye.of || function () { var e = function Foo(e) { this.length = e; }; e.prototype = []; var t = Array.of.apply(e, [1, 2]); return t instanceof e && t.length === 2; }();
    if (!Qe) {
        ne(Array, "of", Ye.of);
    }
    var et = { copyWithin: function copyWithin(e, t) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); var o = ce.ToInteger(e); var i = ce.ToInteger(t); var a = o < 0 ? A(n + o, 0) : R(o, n); var u = i < 0 ? A(n + i, 0) : R(i, n); var f; if (arguments.length > 2) {
            f = arguments[2];
        } var s = typeof f === "undefined" ? n : ce.ToInteger(f); var c = s < 0 ? A(n + s, 0) : R(s, n); var l = R(c - u, n - a); var p = 1; if (u < a && a < u + l) {
            p = -1;
            u += l - 1;
            a += l - 1;
        } while (l > 0) {
            if (u in r) {
                r[a] = r[u];
            }
            else {
                delete r[a];
            }
            u += p;
            a += p;
            l -= 1;
        } return r; }, fill: function fill(e) { var t; if (arguments.length > 1) {
            t = arguments[1];
        } var r; if (arguments.length > 2) {
            r = arguments[2];
        } var n = ce.ToObject(this); var o = ce.ToLength(n.length); t = ce.ToInteger(typeof t === "undefined" ? 0 : t); r = ce.ToInteger(typeof r === "undefined" ? o : r); var i = t < 0 ? A(o + t, 0) : R(t, o); var a = r < 0 ? o + r : r; for (var u = i; u < o && u < a; ++u) {
            n[u] = e;
        } return n; }, find: function find(e) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); if (!ce.IsCallable(e)) {
            throw new TypeError("Array#find: predicate must be a function");
        } var o = arguments.length > 1 ? arguments[1] : null; for (var i = 0, a; i < n; i++) {
            a = r[i];
            if (o) {
                if (t(e, o, a, i, r)) {
                    return a;
                }
            }
            else if (e(a, i, r)) {
                return a;
            }
        } }, findIndex: function findIndex(e) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); if (!ce.IsCallable(e)) {
            throw new TypeError("Array#findIndex: predicate must be a function");
        } var o = arguments.length > 1 ? arguments[1] : null; for (var i = 0; i < n; i++) {
            if (o) {
                if (t(e, o, r[i], i, r)) {
                    return i;
                }
            }
            else if (e(r[i], i, r)) {
                return i;
            }
        } return -1; }, keys: function keys() { return new q(this, "key"); }, values: function values() { return new q(this, "value"); }, entries: function entries() { return new q(this, "entry"); } };
    if (Array.prototype.keys && !ce.IsCallable([1].keys().next)) {
        delete Array.prototype.keys;
    }
    if (Array.prototype.entries && !ce.IsCallable([1].entries().next)) {
        delete Array.prototype.entries;
    }
    if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[ie]) {
        b(Array.prototype, { values: Array.prototype[ie] });
        if (re.symbol($.unscopables)) {
            Array.prototype[$.unscopables].values = true;
        }
    }
    if (c && Array.prototype.values && Array.prototype.values.name !== "values") {
        var tt = Array.prototype.values;
        ne(Array.prototype, "values", function values() { return ce.Call(tt, this, arguments); });
        h(Array.prototype, ie, Array.prototype.values, true);
    }
    b(Array.prototype, et);
    if (1 / [true].indexOf(true, -0) < 0) {
        h(Array.prototype, "indexOf", function indexOf(e) { var t = E(this, arguments); if (t === 0 && 1 / t < 0) {
            return 0;
        } return t; }, true);
    }
    Me(Array.prototype, function () { return this.values(); });
    if (Object.getPrototypeOf) {
        Me(Object.getPrototypeOf([].values()));
    }
    var rt = function () { return a(function () { return Array.from({ length: -1 }).length === 0; }); }();
    var nt = function () { var e = Array.from([0].entries()); return e.length === 1 && r(e[0]) && e[0][0] === 0 && e[0][1] === 0; }();
    if (!rt || !nt) {
        ne(Array, "from", Ye.from);
    }
    var ot = function () { return a(function () { return Array.from([0], void 0); }); }();
    if (!ot) {
        var it = Array.from;
        ne(Array, "from", function from(e) { if (arguments.length > 1 && typeof arguments[1] !== "undefined") {
            return ce.Call(it, this, arguments);
        }
        else {
            return t(it, this, e);
        } });
    }
    var at = -(Math.pow(2, 32) - 1);
    var ut = function (e, r) { var n = { length: at }; n[r ? (n.length >>> 0) - 1 : 0] = true; return a(function () { t(e, n, function () { throw new RangeError("should not reach here"); }, []); return true; }); };
    if (!ut(Array.prototype.forEach)) {
        var ft = Array.prototype.forEach;
        ne(Array.prototype, "forEach", function forEach(e) { return ce.Call(ft, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.map)) {
        var st = Array.prototype.map;
        ne(Array.prototype, "map", function map(e) { return ce.Call(st, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.filter)) {
        var ct = Array.prototype.filter;
        ne(Array.prototype, "filter", function filter(e) { return ce.Call(ct, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.some)) {
        var lt = Array.prototype.some;
        ne(Array.prototype, "some", function some(e) { return ce.Call(lt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.every)) {
        var pt = Array.prototype.every;
        ne(Array.prototype, "every", function every(e) { return ce.Call(pt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.reduce)) {
        var vt = Array.prototype.reduce;
        ne(Array.prototype, "reduce", function reduce(e) { return ce.Call(vt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.reduceRight, true)) {
        var yt = Array.prototype.reduceRight;
        ne(Array.prototype, "reduceRight", function reduceRight(e) { return ce.Call(yt, this.length >= 0 ? this : [], arguments); }, true);
    }
    var ht = Number("0o10") !== 8;
    var bt = Number("0b10") !== 2;
    var gt = y(Ue, function (e) { return Number(e + 0 + e) === 0; });
    if (ht || bt || gt) {
        var dt = Number;
        var mt = /^0b[01]+$/i;
        var Ot = /^0o[0-7]+$/i;
        var wt = mt.test.bind(mt);
        var jt = Ot.test.bind(Ot);
        var St = function (e) { var t; if (typeof e.valueOf === "function") {
            t = e.valueOf();
            if (re.primitive(t)) {
                return t;
            }
        } if (typeof e.toString === "function") {
            t = e.toString();
            if (re.primitive(t)) {
                return t;
            }
        } throw new TypeError("No default value"); };
        var Tt = $e.test.bind($e);
        var It = Je.test.bind(Je);
        var Et = function () { var e = function Number(t) { var r; if (arguments.length > 0) {
            r = re.primitive(t) ? t : St(t, "number");
        }
        else {
            r = 0;
        } if (typeof r === "string") {
            r = ce.Call(Be, r);
            if (wt(r)) {
                r = parseInt(C(r, 2), 2);
            }
            else if (jt(r)) {
                r = parseInt(C(r, 2), 8);
            }
            else if (Tt(r) || It(r)) {
                r = NaN;
            }
        } var n = this; var o = a(function () { dt.prototype.valueOf.call(n); return true; }); if (n instanceof e && !o) {
            return new dt(r);
        } return dt(r); }; return e; }();
        Ee(dt, Et, {});
        b(Et, { NaN: dt.NaN, MAX_VALUE: dt.MAX_VALUE, MIN_VALUE: dt.MIN_VALUE, NEGATIVE_INFINITY: dt.NEGATIVE_INFINITY, POSITIVE_INFINITY: dt.POSITIVE_INFINITY });
        Number = Et;
        m.redefine(S, "Number", Et);
    }
    var Pt = Math.pow(2, 53) - 1;
    b(Number, { MAX_SAFE_INTEGER: Pt, MIN_SAFE_INTEGER: -Pt, EPSILON: 2.220446049250313e-16, parseInt: S.parseInt, parseFloat: S.parseFloat, isFinite: K, isInteger: function isInteger(e) { return K(e) && ce.ToInteger(e) === e; }, isSafeInteger: function isSafeInteger(e) { return Number.isInteger(e) && k(e) <= Number.MAX_SAFE_INTEGER; }, isNaN: X });
    h(Number, "parseInt", S.parseInt, Number.parseInt !== S.parseInt);
    if ([, 1].find(function () { return true; }) === 1) {
        ne(Array.prototype, "find", et.find);
    }
    if ([, 1].findIndex(function () { return true; }) !== 0) {
        ne(Array.prototype, "findIndex", et.findIndex);
    }
    var Ct = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
    var Mt = function ensureEnumerable(e, t) { if (s && Ct(e, t)) {
        Object.defineProperty(e, t, { enumerable: false });
    } };
    var xt = function sliceArgs() { var e = Number(this); var t = arguments.length; var r = t - e; var n = new Array(r < 0 ? 0 : r); for (var o = e; o < t; ++o) {
        n[o - e] = arguments[o];
    } return n; };
    var Nt = function assignTo(e) { return function assignToSource(t, r) { t[r] = e[r]; return t; }; };
    var At = function (e, t) { var r = n(Object(t)); var o; if (ce.IsCallable(Object.getOwnPropertySymbols)) {
        o = v(Object.getOwnPropertySymbols(Object(t)), Ct(t));
    } return p(P(r, o || []), Nt(t), e); };
    var Rt = { assign: function (e, t) { var r = ce.ToObject(e, "Cannot convert undefined or null to object"); return p(ce.Call(xt, 1, arguments), At, r); }, is: function is(e, t) { return ce.SameValue(e, t); } };
    var _t = Object.assign && Object.preventExtensions && function () { var e = Object.preventExtensions({ 1: 2 }); try {
        Object.assign(e, "xy");
    }
    catch (t) {
        return e[1] === "y";
    } }();
    if (_t) {
        ne(Object, "assign", Rt.assign);
    }
    b(Object, Rt);
    if (s) {
        var kt = { setPrototypeOf: function (e, r) { var n; var o = function (e, t) { if (!ce.TypeIsObject(e)) {
                throw new TypeError("cannot set prototype on a non-object");
            } if (!(t === null || ce.TypeIsObject(t))) {
                throw new TypeError("can only set prototype to an object or null" + t);
            } }; var i = function (e, r) { o(e, r); t(n, e, r); return e; }; try {
                n = e.getOwnPropertyDescriptor(e.prototype, r).set;
                t(n, {}, null);
            }
            catch (a) {
                if (e.prototype !== {}[r]) {
                    return;
                }
                n = function (e) { this[r] = e; };
                i.polyfill = i(i({}, null), e.prototype) instanceof e;
            } return i; }(Object, "__proto__") };
        b(Object, kt);
    }
    if (Object.setPrototypeOf && Object.getPrototypeOf && Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null && Object.getPrototypeOf(Object.create(null)) === null) {
        (function () { var e = Object.create(null); var t = Object.getPrototypeOf; var r = Object.setPrototypeOf; Object.getPrototypeOf = function (r) { var n = t(r); return n === e ? null : n; }; Object.setPrototypeOf = function (t, n) { var o = n === null ? e : n; return r(t, o); }; Object.setPrototypeOf.polyfill = false; })();
    }
    var Lt = !i(function () { return Object.keys("foo"); });
    if (!Lt) {
        var Ft = Object.keys;
        ne(Object, "keys", function keys(e) { return Ft(ce.ToObject(e)); });
        n = Object.keys;
    }
    var Dt = i(function () { return Object.keys(/a/g); });
    if (Dt) {
        var zt = Object.keys;
        ne(Object, "keys", function keys(e) { if (re.regex(e)) {
            var t = [];
            for (var r in e) {
                if (z(e, r)) {
                    M(t, r);
                }
            }
            return t;
        } return zt(e); });
        n = Object.keys;
    }
    if (Object.getOwnPropertyNames) {
        var qt = !i(function () { return Object.getOwnPropertyNames("foo"); });
        if (!qt) {
            var Wt = typeof window === "object" ? Object.getOwnPropertyNames(window) : [];
            var Gt = Object.getOwnPropertyNames;
            ne(Object, "getOwnPropertyNames", function getOwnPropertyNames(e) { var t = ce.ToObject(e); if (g(t) === "[object Window]") {
                try {
                    return Gt(t);
                }
                catch (r) {
                    return P([], Wt);
                }
            } return Gt(t); });
        }
    }
    if (Object.getOwnPropertyDescriptor) {
        var Ht = !i(function () { return Object.getOwnPropertyDescriptor("foo", "bar"); });
        if (!Ht) {
            var Vt = Object.getOwnPropertyDescriptor;
            ne(Object, "getOwnPropertyDescriptor", function getOwnPropertyDescriptor(e, t) { return Vt(ce.ToObject(e), t); });
        }
    }
    if (Object.seal) {
        var Bt = !i(function () { return Object.seal("foo"); });
        if (!Bt) {
            var Ut = Object.seal;
            ne(Object, "seal", function seal(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return Ut(e); });
        }
    }
    if (Object.isSealed) {
        var $t = !i(function () { return Object.isSealed("foo"); });
        if (!$t) {
            var Jt = Object.isSealed;
            ne(Object, "isSealed", function isSealed(e) { if (!ce.TypeIsObject(e)) {
                return true;
            } return Jt(e); });
        }
    }
    if (Object.freeze) {
        var Xt = !i(function () { return Object.freeze("foo"); });
        if (!Xt) {
            var Kt = Object.freeze;
            ne(Object, "freeze", function freeze(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return Kt(e); });
        }
    }
    if (Object.isFrozen) {
        var Zt = !i(function () { return Object.isFrozen("foo"); });
        if (!Zt) {
            var Yt = Object.isFrozen;
            ne(Object, "isFrozen", function isFrozen(e) { if (!ce.TypeIsObject(e)) {
                return true;
            } return Yt(e); });
        }
    }
    if (Object.preventExtensions) {
        var Qt = !i(function () { return Object.preventExtensions("foo"); });
        if (!Qt) {
            var er = Object.preventExtensions;
            ne(Object, "preventExtensions", function preventExtensions(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return er(e); });
        }
    }
    if (Object.isExtensible) {
        var tr = !i(function () { return Object.isExtensible("foo"); });
        if (!tr) {
            var rr = Object.isExtensible;
            ne(Object, "isExtensible", function isExtensible(e) { if (!ce.TypeIsObject(e)) {
                return false;
            } return rr(e); });
        }
    }
    if (Object.getPrototypeOf) {
        var nr = !i(function () { return Object.getPrototypeOf("foo"); });
        if (!nr) {
            var or = Object.getPrototypeOf;
            ne(Object, "getPrototypeOf", function getPrototypeOf(e) { return or(ce.ToObject(e)); });
        }
    }
    var ir = s && function () { var e = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags"); return e && ce.IsCallable(e.get); }();
    if (s && !ir) {
        var ar = function flags() { if (!ce.TypeIsObject(this)) {
            throw new TypeError("Method called on incompatible type: must be an object.");
        } var e = ""; if (this.global) {
            e += "g";
        } if (this.ignoreCase) {
            e += "i";
        } if (this.multiline) {
            e += "m";
        } if (this.unicode) {
            e += "u";
        } if (this.sticky) {
            e += "y";
        } return e; };
        m.getter(RegExp.prototype, "flags", ar);
    }
    var ur = s && a(function () { return String(new RegExp(/a/g, "i")) === "/a/i"; });
    var fr = oe && s && function () { var e = /./; e[$.match] = false; return RegExp(e) === e; }();
    var sr = a(function () { return RegExp.prototype.toString.call({ source: "abc" }) === "/abc/"; });
    var cr = sr && a(function () { return RegExp.prototype.toString.call({ source: "a", flags: "b" }) === "/a/b"; });
    if (!sr || !cr) {
        var lr = RegExp.prototype.toString;
        h(RegExp.prototype, "toString", function toString() { var e = ce.RequireObjectCoercible(this); if (re.regex(e)) {
            return t(lr, e);
        } var r = ue(e.source); var n = ue(e.flags); return "/" + r + "/" + n; }, true);
        m.preserveToString(RegExp.prototype.toString, lr);
    }
    if (s && (!ur || fr)) {
        var pr = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags").get;
        var vr = Object.getOwnPropertyDescriptor(RegExp.prototype, "source") || {};
        var yr = function () { return this.source; };
        var hr = ce.IsCallable(vr.get) ? vr.get : yr;
        var br = RegExp;
        var gr = function () { return function RegExp(e, t) { var r = ce.IsRegExp(e); var n = this instanceof RegExp; if (!n && r && typeof t === "undefined" && e.constructor === RegExp) {
            return e;
        } var o = e; var i = t; if (re.regex(e)) {
            o = ce.Call(hr, e);
            i = typeof t === "undefined" ? ce.Call(pr, e) : t;
            return new RegExp(o, i);
        }
        else if (r) {
            o = e.source;
            i = typeof t === "undefined" ? e.flags : t;
        } return new br(e, t); }; }();
        Ee(br, gr, { $input: true });
        RegExp = gr;
        m.redefine(S, "RegExp", gr);
    }
    if (s) {
        var dr = { input: "$_", lastMatch: "$&", lastParen: "$+", leftContext: "$`", rightContext: "$'" };
        l(n(dr), function (e) { if (e in RegExp && !(dr[e] in RegExp)) {
            m.getter(RegExp, dr[e], function get() { return RegExp[e]; });
        } });
    }
    Ce(RegExp);
    var mr = 1 / Number.EPSILON;
    var Or = function roundTiesToEven(e) { return e + mr - mr; };
    var wr = Math.pow(2, -23);
    var jr = Math.pow(2, 127) * (2 - wr);
    var Sr = Math.pow(2, -126);
    var Tr = Math.E;
    var Ir = Math.LOG2E;
    var Er = Math.LOG10E;
    var Pr = Number.prototype.clz;
    delete Number.prototype.clz;
    var Cr = { acosh: function acosh(e) { var t = Number(e); if (X(t) || e < 1) {
            return NaN;
        } if (t === 1) {
            return 0;
        } if (t === Infinity) {
            return t;
        } var r = 1 / (t * t); if (t < 2) {
            return Y(t - 1 + D(1 - r) * t);
        } var n = t / 2; return Y(n + D(1 - r) * n - 1) + 1 / Ir; }, asinh: function asinh(e) { var t = Number(e); if (t === 0 || !T(t)) {
            return t;
        } var r = k(t); var n = r * r; var o = Z(t); if (r < 1) {
            return o * Y(r + n / (D(n + 1) + 1));
        } return o * (Y(r / 2 + D(1 + 1 / n) * r / 2 - 1) + 1 / Ir); }, atanh: function atanh(e) { var t = Number(e); if (t === 0) {
            return t;
        } if (t === -1) {
            return -Infinity;
        } if (t === 1) {
            return Infinity;
        } if (X(t) || t < -1 || t > 1) {
            return NaN;
        } var r = k(t); return Z(t) * Y(2 * r / (1 - r)) / 2; }, cbrt: function cbrt(e) { var t = Number(e); if (t === 0) {
            return t;
        } var r = t < 0; var n; if (r) {
            t = -t;
        } if (t === Infinity) {
            n = Infinity;
        }
        else {
            n = L(F(t) / 3);
            n = (t / (n * n) + 2 * n) / 3;
        } return r ? -n : n; }, clz32: function clz32(e) { var t = Number(e); var r = ce.ToUint32(t); if (r === 0) {
            return 32;
        } return Pr ? ce.Call(Pr, r) : 31 - _(F(r + .5) * Ir); }, cosh: function cosh(e) { var t = Number(e); if (t === 0) {
            return 1;
        } if (X(t)) {
            return NaN;
        } if (!T(t)) {
            return Infinity;
        } var r = L(k(t) - 1); return (r + 1 / (r * Tr * Tr)) * (Tr / 2); }, expm1: function expm1(e) { var t = Number(e); if (t === -Infinity) {
            return -1;
        } if (!T(t) || t === 0) {
            return t;
        } if (k(t) > .5) {
            return L(t) - 1;
        } var r = t; var n = 0; var o = 1; while (n + r !== n) {
            n += r;
            o += 1;
            r *= t / o;
        } return n; }, hypot: function hypot(e, t) { var r = 0; var n = 0; for (var o = 0; o < arguments.length; ++o) {
            var i = k(Number(arguments[o]));
            if (n < i) {
                r *= n / i * (n / i);
                r += 1;
                n = i;
            }
            else {
                r += i > 0 ? i / n * (i / n) : i;
            }
        } return n === Infinity ? Infinity : n * D(r); }, log2: function log2(e) { return F(e) * Ir; }, log10: function log10(e) { return F(e) * Er; }, log1p: Y, sign: Z, sinh: function sinh(e) { var t = Number(e); if (!T(t) || t === 0) {
            return t;
        } var r = k(t); if (r < 1) {
            var n = Math.expm1(r);
            return Z(t) * n * (1 + 1 / (n + 1)) / 2;
        } var o = L(r - 1); return Z(t) * (o - 1 / (o * Tr * Tr)) * (Tr / 2); }, tanh: function tanh(e) { var t = Number(e); if (X(t) || t === 0) {
            return t;
        } if (t >= 20) {
            return 1;
        } if (t <= -20) {
            return -1;
        } return (Math.expm1(t) - Math.expm1(-t)) / (L(t) + L(-t)); }, trunc: function trunc(e) { var t = Number(e); return t < 0 ? -_(-t) : _(t); }, imul: function imul(e, t) { var r = ce.ToUint32(e); var n = ce.ToUint32(t); var o = r >>> 16 & 65535; var i = r & 65535; var a = n >>> 16 & 65535; var u = n & 65535; return i * u + (o * u + i * a << 16 >>> 0) | 0; }, fround: function fround(e) { var t = Number(e); if (t === 0 || t === Infinity || t === -Infinity || X(t)) {
            return t;
        } var r = Z(t); var n = k(t); if (n < Sr) {
            return r * Or(n / Sr / wr) * Sr * wr;
        } var o = (1 + wr / Number.EPSILON) * n; var i = o - (o - n); if (i > jr || X(i)) {
            return r * Infinity;
        } return r * i; } };
    var Mr = function withinULPDistance(e, t, r) { return k(1 - e / t) / Number.EPSILON < (r || 8); };
    b(Math, Cr);
    h(Math, "sinh", Cr.sinh, Math.sinh(710) === Infinity);
    h(Math, "cosh", Cr.cosh, Math.cosh(710) === Infinity);
    h(Math, "log1p", Cr.log1p, Math.log1p(-1e-17) !== -1e-17);
    h(Math, "asinh", Cr.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
    h(Math, "asinh", Cr.asinh, Math.asinh(1e300) === Infinity);
    h(Math, "atanh", Cr.atanh, Math.atanh(1e-300) === 0);
    h(Math, "tanh", Cr.tanh, Math.tanh(-2e-17) !== -2e-17);
    h(Math, "acosh", Cr.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
    h(Math, "acosh", Cr.acosh, !Mr(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
    h(Math, "cbrt", Cr.cbrt, !Mr(Math.cbrt(1e-300), 1e-100));
    h(Math, "sinh", Cr.sinh, Math.sinh(-2e-17) !== -2e-17);
    var xr = Math.expm1(10);
    h(Math, "expm1", Cr.expm1, xr > 22025.465794806718 || xr < 22025.465794806718);
    var Nr = Math.round;
    var Ar = Math.round(.5 - Number.EPSILON / 4) === 0 && Math.round(-.5 + Number.EPSILON / 3.99) === 1;
    var Rr = mr + 1;
    var _r = 2 * mr - 1;
    var kr = [Rr, _r].every(function (e) { return Math.round(e) === e; });
    h(Math, "round", function round(e) { var t = _(e); var r = t === -1 ? -0 : t + 1; return e - t < .5 ? t : r; }, !Ar || !kr);
    m.preserveToString(Math.round, Nr);
    var Lr = Math.imul;
    if (Math.imul(4294967295, 5) !== -5) {
        Math.imul = Cr.imul;
        m.preserveToString(Math.imul, Lr);
    }
    if (Math.imul.length !== 2) {
        ne(Math, "imul", function imul(e, t) { return ce.Call(Lr, Math, arguments); });
    }
    var Fr = function () { var e = S.setTimeout; if (typeof e !== "function" && typeof e !== "object") {
        return;
    } ce.IsPromise = function (e) { if (!ce.TypeIsObject(e)) {
        return false;
    } if (typeof e._promise === "undefined") {
        return false;
    } return true; }; var r = function (e) { if (!ce.IsConstructor(e)) {
        throw new TypeError("Bad promise constructor");
    } var t = this; var r = function (e, r) { if (t.resolve !== void 0 || t.reject !== void 0) {
        throw new TypeError("Bad Promise implementation!");
    } t.resolve = e; t.reject = r; }; t.resolve = void 0; t.reject = void 0; t.promise = new e(r); if (!(ce.IsCallable(t.resolve) && ce.IsCallable(t.reject))) {
        throw new TypeError("Bad promise constructor");
    } }; var n; if (typeof window !== "undefined" && ce.IsCallable(window.postMessage)) {
        n = function () { var e = []; var t = "zero-timeout-message"; var r = function (r) { M(e, r); window.postMessage(t, "*"); }; var n = function (r) { if (r.source === window && r.data === t) {
            r.stopPropagation();
            if (e.length === 0) {
                return;
            }
            var n = N(e);
            n();
        } }; window.addEventListener("message", n, true); return r; };
    } var o = function () { var e = S.Promise; var t = e && e.resolve && e.resolve(); return t && function (e) { return t.then(e); }; }; var i = ce.IsCallable(S.setImmediate) ? S.setImmediate : typeof process === "object" && process.nextTick ? process.nextTick : o() || (ce.IsCallable(n) ? n() : function (t) { e(t, 0); }); var a = function (e) { return e; }; var u = function (e) { throw e; }; var f = 0; var s = 1; var c = 2; var l = 0; var p = 1; var v = 2; var y = {}; var h = function (e, t, r) { i(function () { g(e, t, r); }); }; var g = function (e, t, r) { var n, o; if (t === y) {
        return e(r);
    } try {
        n = e(r);
        o = t.resolve;
    }
    catch (i) {
        n = i;
        o = t.reject;
    } o(n); }; var d = function (e, t) { var r = e._promise; var n = r.reactionLength; if (n > 0) {
        h(r.fulfillReactionHandler0, r.reactionCapability0, t);
        r.fulfillReactionHandler0 = void 0;
        r.rejectReactions0 = void 0;
        r.reactionCapability0 = void 0;
        if (n > 1) {
            for (var o = 1, i = 0; o < n; o++, i += 3) {
                h(r[i + l], r[i + v], t);
                e[i + l] = void 0;
                e[i + p] = void 0;
                e[i + v] = void 0;
            }
        }
    } r.result = t; r.state = s; r.reactionLength = 0; }; var m = function (e, t) { var r = e._promise; var n = r.reactionLength; if (n > 0) {
        h(r.rejectReactionHandler0, r.reactionCapability0, t);
        r.fulfillReactionHandler0 = void 0;
        r.rejectReactions0 = void 0;
        r.reactionCapability0 = void 0;
        if (n > 1) {
            for (var o = 1, i = 0; o < n; o++, i += 3) {
                h(r[i + p], r[i + v], t);
                e[i + l] = void 0;
                e[i + p] = void 0;
                e[i + v] = void 0;
            }
        }
    } r.result = t; r.state = c; r.reactionLength = 0; }; var O = function (e) { var t = false; var r = function (r) { var n; if (t) {
        return;
    } t = true; if (r === e) {
        return m(e, new TypeError("Self resolution"));
    } if (!ce.TypeIsObject(r)) {
        return d(e, r);
    } try {
        n = r.then;
    }
    catch (o) {
        return m(e, o);
    } if (!ce.IsCallable(n)) {
        return d(e, r);
    } i(function () { j(e, r, n); }); }; var n = function (r) { if (t) {
        return;
    } t = true; return m(e, r); }; return { resolve: r, reject: n }; }; var w = function (e, r, n, o) { if (e === I) {
        t(e, r, n, o, y);
    }
    else {
        t(e, r, n, o);
    } }; var j = function (e, t, r) { var n = O(e); var o = n.resolve; var i = n.reject; try {
        w(r, t, o, i);
    }
    catch (a) {
        i(a);
    } }; var T, I; var E = function () { var e = function Promise(t) { if (!(this instanceof e)) {
        throw new TypeError('Constructor Promise requires "new"');
    } if (this && this._promise) {
        throw new TypeError("Bad construction");
    } if (!ce.IsCallable(t)) {
        throw new TypeError("not a valid resolver");
    } var r = Ae(this, e, T, { _promise: { result: void 0, state: f, reactionLength: 0, fulfillReactionHandler0: void 0, rejectReactionHandler0: void 0, reactionCapability0: void 0 } }); var n = O(r); var o = n.reject; try {
        t(n.resolve, o);
    }
    catch (i) {
        o(i);
    } return r; }; return e; }(); T = E.prototype; var P = function (e, t, r, n) { var o = false; return function (i) { if (o) {
        return;
    } o = true; t[e] = i; if (--n.count === 0) {
        var a = r.resolve;
        a(t);
    } }; }; var C = function (e, t, r) { var n = e.iterator; var o = []; var i = { count: 1 }; var a, u; var f = 0; while (true) {
        try {
            a = ce.IteratorStep(n);
            if (a === false) {
                e.done = true;
                break;
            }
            u = a.value;
        }
        catch (s) {
            e.done = true;
            throw s;
        }
        o[f] = void 0;
        var c = t.resolve(u);
        var l = P(f, o, r, i);
        i.count += 1;
        w(c.then, c, l, r.reject);
        f += 1;
    } if (--i.count === 0) {
        var p = r.resolve;
        p(o);
    } return r.promise; }; var x = function (e, t, r) { var n = e.iterator; var o, i, a; while (true) {
        try {
            o = ce.IteratorStep(n);
            if (o === false) {
                e.done = true;
                break;
            }
            i = o.value;
        }
        catch (u) {
            e.done = true;
            throw u;
        }
        a = t.resolve(i);
        w(a.then, a, r.resolve, r.reject);
    } return r.promise; }; b(E, { all: function all(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Promise is not object");
        } var n = new r(t); var o, i; try {
            o = ce.GetIterator(e);
            i = { iterator: o, done: false };
            return C(i, t, n);
        }
        catch (a) {
            var u = a;
            if (i && !i.done) {
                try {
                    ce.IteratorClose(o, true);
                }
                catch (f) {
                    u = f;
                }
            }
            var s = n.reject;
            s(u);
            return n.promise;
        } }, race: function race(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Promise is not object");
        } var n = new r(t); var o, i; try {
            o = ce.GetIterator(e);
            i = { iterator: o, done: false };
            return x(i, t, n);
        }
        catch (a) {
            var u = a;
            if (i && !i.done) {
                try {
                    ce.IteratorClose(o, true);
                }
                catch (f) {
                    u = f;
                }
            }
            var s = n.reject;
            s(u);
            return n.promise;
        } }, reject: function reject(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Bad promise constructor");
        } var n = new r(t); var o = n.reject; o(e); return n.promise; }, resolve: function resolve(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Bad promise constructor");
        } if (ce.IsPromise(e)) {
            var n = e.constructor;
            if (n === t) {
                return e;
            }
        } var o = new r(t); var i = o.resolve; i(e); return o.promise; } }); b(T, { "catch": function (e) { return this.then(null, e); }, then: function then(e, t) { var n = this; if (!ce.IsPromise(n)) {
            throw new TypeError("not a promise");
        } var o = ce.SpeciesConstructor(n, E); var i; var b = arguments.length > 2 && arguments[2] === y; if (b && o === E) {
            i = y;
        }
        else {
            i = new r(o);
        } var g = ce.IsCallable(e) ? e : a; var d = ce.IsCallable(t) ? t : u; var m = n._promise; var O; if (m.state === f) {
            if (m.reactionLength === 0) {
                m.fulfillReactionHandler0 = g;
                m.rejectReactionHandler0 = d;
                m.reactionCapability0 = i;
            }
            else {
                var w = 3 * (m.reactionLength - 1);
                m[w + l] = g;
                m[w + p] = d;
                m[w + v] = i;
            }
            m.reactionLength += 1;
        }
        else if (m.state === s) {
            O = m.result;
            h(g, i, O);
        }
        else if (m.state === c) {
            O = m.result;
            h(d, i, O);
        }
        else {
            throw new TypeError("unexpected Promise state");
        } return i.promise; } }); y = new r(E); I = T.then; return E; }();
    if (S.Promise) {
        delete S.Promise.accept;
        delete S.Promise.defer;
        delete S.Promise.prototype.chain;
    }
    if (typeof Fr === "function") {
        b(S, { Promise: Fr });
        var Dr = w(S.Promise, function (e) { return e.resolve(42).then(function () { }) instanceof e; });
        var zr = !i(function () { return S.Promise.reject(42).then(null, 5).then(null, W); });
        var qr = i(function () { return S.Promise.call(3, W); });
        var Wr = function (e) { var t = e.resolve(5); t.constructor = {}; var r = e.resolve(t); try {
            r.then(null, W).then(null, W);
        }
        catch (n) {
            return true;
        } return t === r; }(S.Promise);
        var Gr = s && function () { var e = 0; var t = Object.defineProperty({}, "then", { get: function () { e += 1; } }); Promise.resolve(t); return e === 1; }();
        var Hr = function BadResolverPromise(e) { var t = new Promise(e); e(3, function () { }); this.then = t.then; this.constructor = BadResolverPromise_1; };
        Hr.prototype = Promise.prototype;
        Hr.all = Promise.all;
        var Vr = a(function () { return !!Hr.all([1, 2]); });
        if (!Dr || !zr || !qr || Wr || !Gr || Vr) {
            Promise = Fr;
            ne(S, "Promise", Fr);
        }
        if (Promise.all.length !== 1) {
            var Br = Promise.all;
            ne(Promise, "all", function all(e) { return ce.Call(Br, this, arguments); });
        }
        if (Promise.race.length !== 1) {
            var Ur = Promise.race;
            ne(Promise, "race", function race(e) { return ce.Call(Ur, this, arguments); });
        }
        if (Promise.resolve.length !== 1) {
            var $r = Promise.resolve;
            ne(Promise, "resolve", function resolve(e) { return ce.Call($r, this, arguments); });
        }
        if (Promise.reject.length !== 1) {
            var Jr = Promise.reject;
            ne(Promise, "reject", function reject(e) { return ce.Call(Jr, this, arguments); });
        }
        Mt(Promise, "all");
        Mt(Promise, "race");
        Mt(Promise, "resolve");
        Mt(Promise, "reject");
        Ce(Promise);
    }
    var Xr = function (e) { var t = n(p(e, function (e, t) { e[t] = true; return e; }, {})); return e.join(":") === t.join(":"); };
    var Kr = Xr(["z", "a", "bb"]);
    var Zr = Xr(["z", 1, "a", "3", 2]);
    if (s) {
        var Yr = function fastkey(e, t) { if (!t && !Kr) {
            return null;
        } if (se(e)) {
            return "^" + ce.ToString(e);
        }
        else if (typeof e === "string") {
            return "$" + e;
        }
        else if (typeof e === "number") {
            if (!Zr) {
                return "n" + e;
            }
            return e;
        }
        else if (typeof e === "boolean") {
            return "b" + e;
        } return null; };
        var Qr = function emptyObject() { return Object.create ? Object.create(null) : {}; };
        var en = function addIterableToMap(e, n, o) { if (r(o) || re.string(o)) {
            l(o, function (e) { if (!ce.TypeIsObject(e)) {
                throw new TypeError("Iterator value " + e + " is not an entry object");
            } n.set(e[0], e[1]); });
        }
        else if (o instanceof e) {
            t(e.prototype.forEach, o, function (e, t) { n.set(t, e); });
        }
        else {
            var i, a;
            if (!se(o)) {
                a = n.set;
                if (!ce.IsCallable(a)) {
                    throw new TypeError("bad map");
                }
                i = ce.GetIterator(o);
            }
            if (typeof i !== "undefined") {
                while (true) {
                    var u = ce.IteratorStep(i);
                    if (u === false) {
                        break;
                    }
                    var f = u.value;
                    try {
                        if (!ce.TypeIsObject(f)) {
                            throw new TypeError("Iterator value " + f + " is not an entry object");
                        }
                        t(a, n, f[0], f[1]);
                    }
                    catch (s) {
                        ce.IteratorClose(i, true);
                        throw s;
                    }
                }
            }
        } };
        var tn = function addIterableToSet(e, n, o) { if (r(o) || re.string(o)) {
            l(o, function (e) { n.add(e); });
        }
        else if (o instanceof e) {
            t(e.prototype.forEach, o, function (e) { n.add(e); });
        }
        else {
            var i, a;
            if (!se(o)) {
                a = n.add;
                if (!ce.IsCallable(a)) {
                    throw new TypeError("bad set");
                }
                i = ce.GetIterator(o);
            }
            if (typeof i !== "undefined") {
                while (true) {
                    var u = ce.IteratorStep(i);
                    if (u === false) {
                        break;
                    }
                    var f = u.value;
                    try {
                        t(a, n, f);
                    }
                    catch (s) {
                        ce.IteratorClose(i, true);
                        throw s;
                    }
                }
            }
        } };
        var rn = { Map: function () { var e = {}; var r = function MapEntry(e, t) { this.key = e; this.value = t; this.next = null; this.prev = null; }; r.prototype.isRemoved = function isRemoved() { return this.key === e; }; var n = function isMap(e) { return !!e._es6map; }; var o = function requireMapSlot(e, t) { if (!ce.TypeIsObject(e) || !n(e)) {
                throw new TypeError("Method Map.prototype." + t + " called on incompatible receiver " + ce.ToString(e));
            } }; var i = function MapIterator(e, t) { o(e, "[[MapIterator]]"); this.head = e._head; this.i = this.head; this.kind = t; }; i.prototype = { isMapIterator: true, next: function next() { if (!this.isMapIterator) {
                    throw new TypeError("Not a MapIterator");
                } var e = this.i; var t = this.kind; var r = this.head; if (typeof this.i === "undefined") {
                    return Ke();
                } while (e.isRemoved() && e !== r) {
                    e = e.prev;
                } var n; while (e.next !== r) {
                    e = e.next;
                    if (!e.isRemoved()) {
                        if (t === "key") {
                            n = e.key;
                        }
                        else if (t === "value") {
                            n = e.value;
                        }
                        else {
                            n = [e.key, e.value];
                        }
                        this.i = e;
                        return Ke(n);
                    }
                } this.i = void 0; return Ke(); } }; Me(i.prototype); var a; var u = function Map() { if (!(this instanceof Map)) {
                throw new TypeError('Constructor Map requires "new"');
            } if (this && this._es6map) {
                throw new TypeError("Bad construction");
            } var e = Ae(this, Map, a, { _es6map: true, _head: null, _map: G ? new G : null, _size: 0, _storage: Qr() }); var t = new r(null, null); t.next = t.prev = t; e._head = t; if (arguments.length > 0) {
                en(Map, e, arguments[0]);
            } return e; }; a = u.prototype; m.getter(a, "size", function () { if (typeof this._size === "undefined") {
                throw new TypeError("size method called on incompatible Map");
            } return this._size; }); b(a, { get: function get(e) { o(this, "get"); var t; var r = Yr(e, true); if (r !== null) {
                    t = this._storage[r];
                    if (t) {
                        return t.value;
                    }
                    else {
                        return;
                    }
                } if (this._map) {
                    t = V.call(this._map, e);
                    if (t) {
                        return t.value;
                    }
                    else {
                        return;
                    }
                } var n = this._head; var i = n; while ((i = i.next) !== n) {
                    if (ce.SameValueZero(i.key, e)) {
                        return i.value;
                    }
                } }, has: function has(e) { o(this, "has"); var t = Yr(e, true); if (t !== null) {
                    return typeof this._storage[t] !== "undefined";
                } if (this._map) {
                    return B.call(this._map, e);
                } var r = this._head; var n = r; while ((n = n.next) !== r) {
                    if (ce.SameValueZero(n.key, e)) {
                        return true;
                    }
                } return false; }, set: function set(e, t) { o(this, "set"); var n = this._head; var i = n; var a; var u = Yr(e, true); if (u !== null) {
                    if (typeof this._storage[u] !== "undefined") {
                        this._storage[u].value = t;
                        return this;
                    }
                    else {
                        a = this._storage[u] = new r(e, t);
                        i = n.prev;
                    }
                }
                else if (this._map) {
                    if (B.call(this._map, e)) {
                        V.call(this._map, e).value = t;
                    }
                    else {
                        a = new r(e, t);
                        U.call(this._map, e, a);
                        i = n.prev;
                    }
                } while ((i = i.next) !== n) {
                    if (ce.SameValueZero(i.key, e)) {
                        i.value = t;
                        return this;
                    }
                } a = a || new r(e, t); if (ce.SameValue(-0, e)) {
                    a.key = +0;
                } a.next = this._head; a.prev = this._head.prev; a.prev.next = a; a.next.prev = a; this._size += 1; return this; }, "delete": function (t) { o(this, "delete"); var r = this._head; var n = r; var i = Yr(t, true); if (i !== null) {
                    if (typeof this._storage[i] === "undefined") {
                        return false;
                    }
                    n = this._storage[i].prev;
                    delete this._storage[i];
                }
                else if (this._map) {
                    if (!B.call(this._map, t)) {
                        return false;
                    }
                    n = V.call(this._map, t).prev;
                    H.call(this._map, t);
                } while ((n = n.next) !== r) {
                    if (ce.SameValueZero(n.key, t)) {
                        n.key = e;
                        n.value = e;
                        n.prev.next = n.next;
                        n.next.prev = n.prev;
                        this._size -= 1;
                        return true;
                    }
                } return false; }, clear: function clear() { o(this, "clear"); this._map = G ? new G : null; this._size = 0; this._storage = Qr(); var t = this._head; var r = t; var n = r.next; while ((r = n) !== t) {
                    r.key = e;
                    r.value = e;
                    n = r.next;
                    r.next = r.prev = t;
                } t.next = t.prev = t; }, keys: function keys() { o(this, "keys"); return new i(this, "key"); }, values: function values() { o(this, "values"); return new i(this, "value"); }, entries: function entries() { o(this, "entries"); return new i(this, "key+value"); }, forEach: function forEach(e) { o(this, "forEach"); var r = arguments.length > 1 ? arguments[1] : null; var n = this.entries(); for (var i = n.next(); !i.done; i = n.next()) {
                    if (r) {
                        t(e, r, i.value[1], i.value[0], this);
                    }
                    else {
                        e(i.value[1], i.value[0], this);
                    }
                } } }); Me(a, a.entries); return u; }(), Set: function () { var e = function isSet(e) { return e._es6set && typeof e._storage !== "undefined"; }; var r = function requireSetSlot(t, r) { if (!ce.TypeIsObject(t) || !e(t)) {
                throw new TypeError("Set.prototype." + r + " called on incompatible receiver " + ce.ToString(t));
            } }; var o; var i = function Set() { if (!(this instanceof Set)) {
                throw new TypeError('Constructor Set requires "new"');
            } if (this && this._es6set) {
                throw new TypeError("Bad construction");
            } var e = Ae(this, Set, o, { _es6set: true, "[[SetData]]": null, _storage: Qr() }); if (!e._es6set) {
                throw new TypeError("bad set");
            } if (arguments.length > 0) {
                tn(Set, e, arguments[0]);
            } return e; }; o = i.prototype; var a = function (e) { var t = e; if (t === "^null") {
                return null;
            }
            else if (t === "^undefined") {
                return void 0;
            }
            else {
                var r = t.charAt(0);
                if (r === "$") {
                    return C(t, 1);
                }
                else if (r === "n") {
                    return +C(t, 1);
                }
                else if (r === "b") {
                    return t === "btrue";
                }
            } return +t; }; var u = function ensureMap(e) { if (!e["[[SetData]]"]) {
                var t = new rn.Map;
                e["[[SetData]]"] = t;
                l(n(e._storage), function (e) { var r = a(e); t.set(r, r); });
                e["[[SetData]]"] = t;
            } e._storage = null; }; m.getter(i.prototype, "size", function () { r(this, "size"); if (this._storage) {
                return n(this._storage).length;
            } u(this); return this["[[SetData]]"].size; }); b(i.prototype, { has: function has(e) { r(this, "has"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    return !!this._storage[t];
                } u(this); return this["[[SetData]]"].has(e); }, add: function add(e) { r(this, "add"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    this._storage[t] = true;
                    return this;
                } u(this); this["[[SetData]]"].set(e, e); return this; }, "delete": function (e) { r(this, "delete"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    var n = z(this._storage, t);
                    return delete this._storage[t] && n;
                } u(this); return this["[[SetData]]"]["delete"](e); }, clear: function clear() { r(this, "clear"); if (this._storage) {
                    this._storage = Qr();
                } if (this["[[SetData]]"]) {
                    this["[[SetData]]"].clear();
                } }, values: function values() { r(this, "values"); u(this); return new f(this["[[SetData]]"].values()); }, entries: function entries() { r(this, "entries"); u(this); return new f(this["[[SetData]]"].entries()); }, forEach: function forEach(e) { r(this, "forEach"); var n = arguments.length > 1 ? arguments[1] : null; var o = this; u(o); this["[[SetData]]"].forEach(function (r, i) { if (n) {
                    t(e, n, i, i, o);
                }
                else {
                    e(i, i, o);
                } }); } }); h(i.prototype, "keys", i.prototype.values, true); Me(i.prototype, i.prototype.values); var f = function SetIterator(e) { this.it = e; }; f.prototype = { isSetIterator: true, next: function next() { if (!this.isSetIterator) {
                    throw new TypeError("Not a SetIterator");
                } return this.it.next(); } }; Me(f.prototype); return i; }() };
        var nn = S.Set && !Set.prototype["delete"] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray((new Set).keys);
        if (nn) {
            S.Set = rn.Set;
        }
        if (S.Map || S.Set) {
            var on = a(function () { return new Map([[1, 2]]).get(1) === 2; });
            if (!on) {
                S.Map = function Map() { if (!(this instanceof Map)) {
                    throw new TypeError('Constructor Map requires "new"');
                } var e = new G; if (arguments.length > 0) {
                    en(Map, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, S.Map.prototype); return e; };
                S.Map.prototype = O(G.prototype);
                h(S.Map.prototype, "constructor", S.Map, true);
                m.preserveToString(S.Map, G);
            }
            var an = new Map;
            var un = function () { var e = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]); e.set(-0, e); return e.get(0) === e && e.get(-0) === e && e.has(0) && e.has(-0); }();
            var fn = an.set(1, 2) === an;
            if (!un || !fn) {
                ne(Map.prototype, "set", function set(e, r) { t(U, this, e === 0 ? 0 : e, r); return this; });
            }
            if (!un) {
                b(Map.prototype, { get: function get(e) { return t(V, this, e === 0 ? 0 : e); }, has: function has(e) { return t(B, this, e === 0 ? 0 : e); } }, true);
                m.preserveToString(Map.prototype.get, V);
                m.preserveToString(Map.prototype.has, B);
            }
            var sn = new Set;
            var cn = Set.prototype["delete"] && Set.prototype.add && Set.prototype.has && function (e) { e["delete"](0); e.add(-0); return !e.has(0); }(sn);
            var ln = sn.add(1) === sn;
            if (!cn || !ln) {
                var pn = Set.prototype.add;
                Set.prototype.add = function add(e) { t(pn, this, e === 0 ? 0 : e); return this; };
                m.preserveToString(Set.prototype.add, pn);
            }
            if (!cn) {
                var vn = Set.prototype.has;
                Set.prototype.has = function has(e) { return t(vn, this, e === 0 ? 0 : e); };
                m.preserveToString(Set.prototype.has, vn);
                var yn = Set.prototype["delete"];
                Set.prototype["delete"] = function SetDelete(e) { return t(yn, this, e === 0 ? 0 : e); };
                m.preserveToString(Set.prototype["delete"], yn);
            }
            var hn = w(S.Map, function (e) { var t = new e([]); t.set(42, 42); return t instanceof e; });
            var bn = Object.setPrototypeOf && !hn;
            var gn = function () { try {
                return !(S.Map() instanceof S.Map);
            }
            catch (e) {
                return e instanceof TypeError;
            } }();
            if (S.Map.length !== 0 || bn || !gn) {
                S.Map = function Map() { if (!(this instanceof Map)) {
                    throw new TypeError('Constructor Map requires "new"');
                } var e = new G; if (arguments.length > 0) {
                    en(Map, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, Map.prototype); return e; };
                S.Map.prototype = G.prototype;
                h(S.Map.prototype, "constructor", S.Map, true);
                m.preserveToString(S.Map, G);
            }
            var dn = w(S.Set, function (e) { var t = new e([]); t.add(42, 42); return t instanceof e; });
            var mn = Object.setPrototypeOf && !dn;
            var On = function () { try {
                return !(S.Set() instanceof S.Set);
            }
            catch (e) {
                return e instanceof TypeError;
            } }();
            if (S.Set.length !== 0 || mn || !On) {
                var wn = S.Set;
                S.Set = function Set() { if (!(this instanceof Set)) {
                    throw new TypeError('Constructor Set requires "new"');
                } var e = new wn; if (arguments.length > 0) {
                    tn(Set, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, Set.prototype); return e; };
                S.Set.prototype = wn.prototype;
                h(S.Set.prototype, "constructor", S.Set, true);
                m.preserveToString(S.Set, wn);
            }
            var jn = new S.Map;
            var Sn = !a(function () { return jn.keys().next().done; });
            if (typeof S.Map.prototype.clear !== "function" || (new S.Set).size !== 0 || jn.size !== 0 || typeof S.Map.prototype.keys !== "function" || typeof S.Set.prototype.keys !== "function" || typeof S.Map.prototype.forEach !== "function" || typeof S.Set.prototype.forEach !== "function" || u(S.Map) || u(S.Set) || typeof jn.keys().next !== "function" || Sn || !hn) {
                b(S, { Map: rn.Map, Set: rn.Set }, true);
            }
            if (S.Set.prototype.keys !== S.Set.prototype.values) {
                h(S.Set.prototype, "keys", S.Set.prototype.values, true);
            }
            Me(Object.getPrototypeOf((new S.Map).keys()));
            Me(Object.getPrototypeOf((new S.Set).keys()));
            if (c && S.Set.prototype.has.name !== "has") {
                var Tn = S.Set.prototype.has;
                ne(S.Set.prototype, "has", function has(e) { return t(Tn, this, e); });
            }
        }
        b(S, rn);
        Ce(S.Map);
        Ce(S.Set);
    }
    var In = function throwUnlessTargetIsObject(e) { if (!ce.TypeIsObject(e)) {
        throw new TypeError("target must be an object");
    } };
    var En = { apply: function apply() { return ce.Call(ce.Call, null, arguments); }, construct: function construct(e, t) { if (!ce.IsConstructor(e)) {
            throw new TypeError("First argument must be a constructor.");
        } var r = arguments.length > 2 ? arguments[2] : e; if (!ce.IsConstructor(r)) {
            throw new TypeError("new.target must be a constructor.");
        } return ce.Construct(e, t, r, "internal"); }, deleteProperty: function deleteProperty(e, t) { In(e); if (s) {
            var r = Object.getOwnPropertyDescriptor(e, t);
            if (r && !r.configurable) {
                return false;
            }
        } return delete e[t]; }, has: function has(e, t) { In(e); return t in e; } };
    if (Object.getOwnPropertyNames) {
        Object.assign(En, { ownKeys: function ownKeys(e) { In(e); var t = Object.getOwnPropertyNames(e); if (ce.IsCallable(Object.getOwnPropertySymbols)) {
                x(t, Object.getOwnPropertySymbols(e));
            } return t; } });
    }
    var Pn = function ConvertExceptionToBoolean(e) { return !i(e); };
    if (Object.preventExtensions) {
        Object.assign(En, { isExtensible: function isExtensible(e) { In(e); return Object.isExtensible(e); }, preventExtensions: function preventExtensions(e) { In(e); return Pn(function () { return Object.preventExtensions(e); }); } });
    }
    if (s) {
        var Cn = function get(e, t, r) { var n = Object.getOwnPropertyDescriptor(e, t); if (!n) {
            var o = Object.getPrototypeOf(e);
            if (o === null) {
                return void 0;
            }
            return Cn(o, t, r);
        } if ("value" in n) {
            return n.value;
        } if (n.get) {
            return ce.Call(n.get, r);
        } return void 0; };
        var Mn = function set(e, r, n, o) { var i = Object.getOwnPropertyDescriptor(e, r); if (!i) {
            var a = Object.getPrototypeOf(e);
            if (a !== null) {
                return Mn(a, r, n, o);
            }
            i = { value: void 0, writable: true, enumerable: true, configurable: true };
        } if ("value" in i) {
            if (!i.writable) {
                return false;
            }
            if (!ce.TypeIsObject(o)) {
                return false;
            }
            var u = Object.getOwnPropertyDescriptor(o, r);
            if (u) {
                return ae.defineProperty(o, r, { value: n });
            }
            else {
                return ae.defineProperty(o, r, { value: n, writable: true, enumerable: true, configurable: true });
            }
        } if (i.set) {
            t(i.set, o, n);
            return true;
        } return false; };
        Object.assign(En, { defineProperty: function defineProperty(e, t, r) { In(e); return Pn(function () { return Object.defineProperty(e, t, r); }); }, getOwnPropertyDescriptor: function getOwnPropertyDescriptor(e, t) { In(e); return Object.getOwnPropertyDescriptor(e, t); }, get: function get(e, t) { In(e); var r = arguments.length > 2 ? arguments[2] : e; return Cn(e, t, r); }, set: function set(e, t, r) { In(e); var n = arguments.length > 3 ? arguments[3] : e; return Mn(e, t, r, n); } });
    }
    if (Object.getPrototypeOf) {
        var xn = Object.getPrototypeOf;
        En.getPrototypeOf = function getPrototypeOf(e) { In(e); return xn(e); };
    }
    if (Object.setPrototypeOf && En.getPrototypeOf) {
        var Nn = function (e, t) { var r = t; while (r) {
            if (e === r) {
                return true;
            }
            r = En.getPrototypeOf(r);
        } return false; };
        Object.assign(En, { setPrototypeOf: function setPrototypeOf(e, t) { In(e); if (t !== null && !ce.TypeIsObject(t)) {
                throw new TypeError("proto must be an object or null");
            } if (t === ae.getPrototypeOf(e)) {
                return true;
            } if (ae.isExtensible && !ae.isExtensible(e)) {
                return false;
            } if (Nn(e, t)) {
                return false;
            } Object.setPrototypeOf(e, t); return true; } });
    }
    var An = function (e, t) { if (!ce.IsCallable(S.Reflect[e])) {
        h(S.Reflect, e, t);
    }
    else {
        var r = a(function () { S.Reflect[e](1); S.Reflect[e](NaN); S.Reflect[e](true); return true; });
        if (r) {
            ne(S.Reflect, e, t);
        }
    } };
    Object.keys(En).forEach(function (e) { An(e, En[e]); });
    var Rn = S.Reflect.getPrototypeOf;
    if (c && Rn && Rn.name !== "getPrototypeOf") {
        ne(S.Reflect, "getPrototypeOf", function getPrototypeOf(e) { return t(Rn, S.Reflect, e); });
    }
    if (S.Reflect.setPrototypeOf) {
        if (a(function () { S.Reflect.setPrototypeOf(1, {}); return true; })) {
            ne(S.Reflect, "setPrototypeOf", En.setPrototypeOf);
        }
    }
    if (S.Reflect.defineProperty) {
        if (!a(function () { var e = !S.Reflect.defineProperty(1, "test", { value: 1 }); var t = typeof Object.preventExtensions !== "function" || !S.Reflect.defineProperty(Object.preventExtensions({}), "test", {}); return e && t; })) {
            ne(S.Reflect, "defineProperty", En.defineProperty);
        }
    }
    if (S.Reflect.construct) {
        if (!a(function () { var e = function F() { }; return S.Reflect.construct(function () { }, [], e) instanceof e; })) {
            ne(S.Reflect, "construct", En.construct);
        }
    }
    if (String(new Date(NaN)) !== "Invalid Date") {
        var _n = Date.prototype.toString;
        var kn = function toString() { var e = +this; if (e !== e) {
            return "Invalid Date";
        } return ce.Call(_n, this); };
        ne(Date.prototype, "toString", kn);
    }
    var Ln = { anchor: function anchor(e) { return ce.CreateHTML(this, "a", "name", e); }, big: function big() { return ce.CreateHTML(this, "big", "", ""); }, blink: function blink() { return ce.CreateHTML(this, "blink", "", ""); }, bold: function bold() { return ce.CreateHTML(this, "b", "", ""); }, fixed: function fixed() { return ce.CreateHTML(this, "tt", "", ""); }, fontcolor: function fontcolor(e) { return ce.CreateHTML(this, "font", "color", e); }, fontsize: function fontsize(e) { return ce.CreateHTML(this, "font", "size", e); }, italics: function italics() { return ce.CreateHTML(this, "i", "", ""); }, link: function link(e) { return ce.CreateHTML(this, "a", "href", e); }, small: function small() { return ce.CreateHTML(this, "small", "", ""); }, strike: function strike() { return ce.CreateHTML(this, "strike", "", ""); }, sub: function sub() { return ce.CreateHTML(this, "sub", "", ""); }, sup: function sub() { return ce.CreateHTML(this, "sup", "", ""); } };
    l(Object.keys(Ln), function (e) { var r = String.prototype[e]; var n = false; if (ce.IsCallable(r)) {
        var o = t(r, "", ' " ');
        var i = P([], o.match(/"/g)).length;
        n = o !== o.toLowerCase() || i > 2;
    }
    else {
        n = true;
    } if (n) {
        ne(String.prototype, e, Ln[e]);
    } });
    var Fn = function () { if (!oe) {
        return false;
    } var e = typeof JSON === "object" && typeof JSON.stringify === "function" ? JSON.stringify : null; if (!e) {
        return false;
    } if (typeof e($()) !== "undefined") {
        return true;
    } if (e([$()]) !== "[null]") {
        return true;
    } var t = { a: $() }; t[$()] = true; if (e(t) !== "{}") {
        return true;
    } return false; }();
    var Dn = a(function () { if (!oe) {
        return true;
    } return JSON.stringify(Object($())) === "{}" && JSON.stringify([Object($())]) === "[{}]"; });
    if (Fn || !Dn) {
        var zn = JSON.stringify;
        ne(JSON, "stringify", function stringify(e) { if (typeof e === "symbol") {
            return;
        } var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o = [e]; if (!r(n)) {
            var i = ce.IsCallable(n) ? n : null;
            var a = function (e, r) { var n = i ? t(i, this, e, r) : r; if (typeof n !== "symbol") {
                if (re.symbol(n)) {
                    return Nt({})(n);
                }
                else {
                    return n;
                }
            } };
            o.push(a);
        }
        else {
            o.push(n);
        } if (arguments.length > 2) {
            o.push(arguments[2]);
        } return zn.apply(this, o); });
    }
    return S;
});
//# sourceMappingURL=es6-shim.map
//Autogenerated file - do not modify!
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var environment;
        (function (environment) {
            environment.VERSION = "13.0";
        })(environment = keyman.environment || (keyman.environment = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// By referencing this file first, before any other Keyman class definitions,
// a globally-usable 'singleton' reference to KeymanWeb can be established.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            text.Codes = {
                // Define Keyman Developer modifier bit-flags (exposed for use by other modules)
                modifierCodes: {
                    "LCTRL": 0x0001,
                    "RCTRL": 0x0002,
                    "LALT": 0x0004,
                    "RALT": 0x0008,
                    "SHIFT": 0x0010,
                    "CTRL": 0x0020,
                    "ALT": 0x0040,
                    "CAPS": 0x0100,
                    "NO_CAPS": 0x0200,
                    "NUM_LOCK": 0x0400,
                    "NO_NUM_LOCK": 0x0800,
                    "SCROLL_LOCK": 0x1000,
                    "NO_SCROLL_LOCK": 0x2000,
                    "VIRTUAL_KEY": 0x4000
                },
                modifierBitmasks: {
                    "ALL": 0x007F,
                    "ALT_GR_SIM": (0x0001 | 0x0004),
                    "CHIRAL": 0x001F,
                    "IS_CHIRAL": 0x000F,
                    "NON_CHIRAL": 0x0070 // The default bitmask, for non-chiral keyboards
                },
                stateBitmasks: {
                    "ALL": 0x3F00,
                    "CAPS": 0x0300,
                    "NUM_LOCK": 0x0C00,
                    "SCROLL_LOCK": 0x3000
                },
                // Define standard keycode numbers (exposed for use by other modules)
                keyCodes: {
                    "K_BKSP": 8, "K_TAB": 9, "K_ENTER": 13,
                    "K_SHIFT": 16, "K_CONTROL": 17, "K_ALT": 18, "K_PAUSE": 19, "K_CAPS": 20,
                    "K_ESC": 27, "K_SPACE": 32, "K_PGUP": 33,
                    "K_PGDN": 34, "K_END": 35, "K_HOME": 36, "K_LEFT": 37, "K_UP": 38,
                    "K_RIGHT": 39, "K_DOWN": 40, "K_SEL": 41, "K_PRINT": 42, "K_EXEC": 43,
                    "K_INS": 45, "K_DEL": 46, "K_HELP": 47, "K_0": 48,
                    "K_1": 49, "K_2": 50, "K_3": 51, "K_4": 52, "K_5": 53, "K_6": 54, "K_7": 55,
                    "K_8": 56, "K_9": 57, "K_A": 65, "K_B": 66, "K_C": 67, "K_D": 68, "K_E": 69,
                    "K_F": 70, "K_G": 71, "K_H": 72, "K_I": 73, "K_J": 74, "K_K": 75, "K_L": 76,
                    "K_M": 77, "K_N": 78, "K_O": 79, "K_P": 80, "K_Q": 81, "K_R": 82, "K_S": 83,
                    "K_T": 84, "K_U": 85, "K_V": 86, "K_W": 87, "K_X": 88, "K_Y": 89, "K_Z": 90,
                    "K_NP0": 96, "K_NP1": 97, "K_NP2": 98,
                    "K_NP3": 99, "K_NP4": 100, "K_NP5": 101, "K_NP6": 102,
                    "K_NP7": 103, "K_NP8": 104, "K_NP9": 105, "K_NPSTAR": 106,
                    "K_NPPLUS": 107, "K_SEPARATOR": 108, "K_NPMINUS": 109, "K_NPDOT": 110,
                    "K_NPSLASH": 111, "K_F1": 112, "K_F2": 113, "K_F3": 114, "K_F4": 115,
                    "K_F5": 116, "K_F6": 117, "K_F7": 118, "K_F8": 119, "K_F9": 120,
                    "K_F10": 121, "K_F11": 122, "K_F12": 123, "K_NUMLOCK": 144, "K_SCROLL": 145,
                    "K_LSHIFT": 160, "K_RSHIFT": 161, "K_LCONTROL": 162, "K_RCONTROL": 163,
                    "K_LALT": 164, "K_RALT": 165,
                    "K_COLON": 186, "K_EQUAL": 187, "K_COMMA": 188, "K_HYPHEN": 189,
                    "K_PERIOD": 190, "K_SLASH": 191, "K_BKQUOTE": 192,
                    "K_LBRKT": 219, "K_BKSLASH": 220, "K_RBRKT": 221,
                    "K_QUOTE": 222, "K_oE2": 226, "K_OE2": 226,
                    "K_LOPT": 50001, "K_ROPT": 50002,
                    "K_NUMERALS": 50003, "K_SYMBOLS": 50004, "K_CURRENCIES": 50005,
                    "K_UPPER": 50006, "K_LOWER": 50007, "K_ALPHA": 50008,
                    "K_SHIFTED": 50009, "K_ALTGR": 50010,
                    "K_TABBACK": 50011, "K_TABFWD": 50012
                },
                codesUS: [
                    ['0123456789', ';=,-./`', '[\\]\''],
                    [')!@#$%^&*(', ':+<_>?~', '{|}"']
                ]
            };
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Establishes key-code definitions.
/// <reference path="codes.ts" />
// Defines our generalized "KeyEvent" class.
/// <reference path="keyEvent.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_1) {
        var text;
        (function (text) {
            var LegacyKeyEvent = /** @class */ (function () {
                function LegacyKeyEvent() {
                }
                return LegacyKeyEvent;
            }());
            text.LegacyKeyEvent = LegacyKeyEvent;
            var Processor = /** @class */ (function () {
                function Processor() {
                    // Tracks the simulated value for supported state keys, allowing the OSK to mirror a physical keyboard for them.
                    // Using the exact keyCode name from the Codes definitions will allow for certain optimizations elsewhere in the code.
                    this.stateKeys = {
                        "K_CAPS": false,
                        "K_NUMLOCK": false,
                        "K_SCROLL": false
                    };
                    // Tracks the most recent modifier state information in order to quickly detect changes
                    // in keyboard state not otherwise captured by the hosting page in the browser.
                    // Needed for AltGr simulation.
                    this.modStateFlags = 0;
                    // Denotes whether or not KMW needs to 'swallow' the next keypress.
                    this.swallowKeypress = false;
                }
                /**
                 * Get the default key string. If keyName is U_xxxxxx, use that Unicode codepoint.
                 * Otherwise, lookup the  virtual key code (physical keyboard mapping)
                 *
                 * @param   {object}  Lkc  The pre-analyzed key event object
                 * @param   {number}  keyShiftState
                 * @param   {boolean} usingOSK
                 * @return  {string}
                 */
                Processor.prototype.defaultKeyOutput = function (Lkc, keyShiftState, usingOSK, disableDOM) {
                    var Lkc;
                    var keyName = Lkc.kName;
                    var n = Lkc.Lcode;
                    var Lelem = Lkc.Ltarg;
                    var keyman = com.keyman.singleton;
                    var domManager = keyman.domManager;
                    var activeKeyboard = keyman.keyboardManager.activeKeyboard;
                    var quiet = keyman.interface.activeTargetOutput instanceof text.Mock;
                    var ch = '', checkCodes = false;
                    var touchAlias = (Lelem && typeof (Lelem.base) != 'undefined');
                    // check if exact match to SHIFT's code.  Only the 'default' and 'shift' layers should have default key outputs.
                    if (keyShiftState == 0) {
                        checkCodes = true;
                    }
                    else if (keyShiftState == text.Codes.modifierCodes['SHIFT']) {
                        checkCodes = true;
                        keyShiftState = 1; // It's used as an index.
                    }
                    else {
                        if (!quiet) {
                            console.warn("KMW only defines default key output for the 'default' and 'shift' layers!");
                        }
                    }
                    // If this was triggered by the OSK -or- if it was triggered within a touch-aliased DIV element.
                    if (touchAlias || usingOSK) {
                        var code = text.Codes.keyCodes[keyName];
                        if (!code) {
                            code = n;
                        }
                        switch (code) {
                            case text.Codes.keyCodes['K_BKSP']: //Only desktop UI, not touch devices. TODO: add repeat while mouse down for desktop UI
                                if (disableDOM) {
                                    return '\b'; // the escape sequence for backspace.
                                }
                                else {
                                    // If we have an available target (via Lkc/Lelem), use that instead of 
                                    // forcing defaultBackspace to search for it.
                                    var target;
                                    if (Lelem && Lelem._kmwAttachment) {
                                        target = Lelem._kmwAttachment.interface;
                                    }
                                    keyman.interface.defaultBackspace(target);
                                }
                                return '';
                            case text.Codes.keyCodes['K_TAB']:
                                if (!disableDOM) {
                                    domManager.moveToNext(keyShiftState);
                                }
                                break;
                            case text.Codes.keyCodes['K_TABBACK']:
                                if (!disableDOM) {
                                    domManager.moveToNext(true);
                                }
                                break;
                            case text.Codes.keyCodes['K_TABFWD']:
                                if (!disableDOM) {
                                    domManager.moveToNext(false);
                                }
                                break;
                            case text.Codes.keyCodes['K_ENTER']:
                                // Insert new line in text area fields
                                if (Lelem.nodeName == 'TEXTAREA' || (typeof Lelem.base != 'undefined' && Lelem.base.nodeName == 'TEXTAREA')) {
                                    return '\n';
                                    // Or move to next field from TEXT fields
                                }
                                else if (usingOSK) {
                                    var inputEle;
                                    if (keyman.isEmbedded) { // In embedded mode, the OutputTarget may not meet other conditions.
                                        return '\n';
                                    }
                                    else if (keyman_1.dom.Utils.instanceof(Lelem, "HTMLInputElement")) {
                                        inputEle = Lelem;
                                    }
                                    else if (typeof (Lelem.base) != 'undefined' && keyman_1.dom.Utils.instanceof(Lelem.base, "HTMLInputElement")) {
                                        inputEle = Lelem.base;
                                    }
                                    if (!disableDOM) {
                                        if (inputEle && (inputEle.type == 'search' || inputEle.type == 'submit')) {
                                            inputEle.disabled = false;
                                            inputEle.form.submit();
                                        }
                                        else {
                                            domManager.moveToNext(false);
                                        }
                                    }
                                }
                                break;
                            case text.Codes.keyCodes['K_SPACE']:
                                return ' ';
                            // break;
                            //
                            // // Problem:  clusters, and doing them right.
                            // // The commented-out code below should be a decent starting point, but clusters make it complex.
                            //
                            // case VisualKeyboard.keyCodes['K_LEFT']:
                            //   if(touchAlias) {
                            //     var caretPos = keymanweb.getTextCaret(Lelem);
                            //     keymanweb.setTextCaret(Lelem, caretPos - 1 >= 0 ? caretPos - 1 : 0);
                            //   }
                            //   break;
                            // case VisualKeyboard.keyCodes['K_RIGHT']:
                            //   if(touchAlias) {
                            //     var caretPos = keymanweb.getTextCaret(Lelem);
                            //     keymanweb.setTextCaret(Lelem, caretPos + 1);
                            //   }
                            //   if(code == VisualKeyboard.keyCodes['K_RIGHT']) {
                            //     break;
                            //   }
                            // // Should we include this?  It could be tricky to do correctly...
                            // case VisualKeyboard.keyCodes['K_DEL']:
                            //   // Move caret right one unit, then backspace.
                            //   if(touchAlias) {
                            //     var caretPos = keymanweb.getTextCaret(Lelem);
                            //     keymanweb.setTextCaret(Lelem, caretPos + 1);
                            //     if(caretPos == keymanweb.getTextCaret(Lelem)) {
                            //       // Failed to move right - there's nothing to delete.
                            //       break;
                            //     }
                            //     kbdInterface.defaultBackspace();
                            //   }
                        }
                        // Only desktop UI, not touch devices. TODO: add repeat while mouse down for desktop UI
                        //
                        // Can easily occur from mnemonic keyboards, which create synthetic events without
                        // the appropriate kName value.
                        //
                        // Not strictly if `Lkc.vkCode` is properly maintained, but it's good to have an
                        // extra safety; this would have blocked the backspace bug as well.
                    }
                    else if (Lkc.Lcode == 8) {
                        if (disableDOM) {
                            return '\b'; // the escape sequence for backspace.
                        }
                        else {
                            keyman.interface.defaultBackspace();
                            return '';
                        }
                    }
                    // Translate numpad keystrokes into their non-numpad equivalents
                    // TODO:  Make part of 'defaultKeyOutput'.
                    if (Lkc.Lcode >= text.Codes.keyCodes["K_NP0"] && Lkc.Lcode <= text.Codes.keyCodes["K_NPSLASH"] && activeKeyboard && !activeKeyboard['KM']) {
                        // Number pad, numlock on
                        if (Lkc.Lcode < 106) {
                            var Lch = Lkc.Lcode - 48;
                        }
                        else {
                            Lch = Lkc.Lcode - 64;
                        }
                        ch = String._kmwFromCharCode(Lch); //I3319
                        return ch;
                    }
                    // TODO:  Refactor the overloading of the 'n' parameter here into separate methods.
                    // Test for fall back to U_xxxxxx key id
                    // For this first test, we ignore the keyCode and use the keyName
                    if (keyName && keyName.substr(0, 2) == 'U_') {
                        var codePoint = parseInt(keyName.substr(2, 6), 16);
                        if (((0x0 <= codePoint) && (codePoint <= 0x1F)) || ((0x80 <= codePoint) && (codePoint <= 0x9F))) {
                            // Code points [U_0000 - U_001F] and [U_0080 - U_009F] refer to Unicode C0 and C1 control codes.
                            // Check the codePoint number and do not allow output of these codes via U_xxxxxx shortcuts.
                            if (!quiet) {
                                console.log("Suppressing Unicode control code: U_00" + codePoint.toString(16));
                            }
                            return ch;
                        }
                        else {
                            // String.fromCharCode() is inadequate to handle the entire range of Unicode
                            // Someday after upgrading to ES2015, can use String.fromCodePoint()
                            ch = String.kmwFromCharCode(codePoint);
                        }
                        // Hereafter, we refer to keyCodes.
                    }
                    else if (checkCodes) { // keyShiftState can only be '1' or '2'.
                        try {
                            if (n >= text.Codes.keyCodes['K_0'] && n <= text.Codes.keyCodes['K_9']) { // The number keys.
                                ch = text.Codes.codesUS[keyShiftState][0][n - text.Codes.keyCodes['K_0']];
                            }
                            else if (n >= text.Codes.keyCodes['K_A'] && n <= text.Codes.keyCodes['K_Z']) { // The base letter keys
                                ch = String.fromCharCode(n + (keyShiftState ? 0 : 32)); // 32 is the offset from uppercase to lowercase.
                            }
                            else if (n >= text.Codes.keyCodes['K_COLON'] && n <= text.Codes.keyCodes['K_BKQUOTE']) {
                                ch = text.Codes.codesUS[keyShiftState][1][n - text.Codes.keyCodes['K_COLON']];
                            }
                            else if (n >= text.Codes.keyCodes['K_LBRKT'] && n <= text.Codes.keyCodes['K_QUOTE']) {
                                ch = text.Codes.codesUS[keyShiftState][2][n - text.Codes.keyCodes['K_LBRKT']];
                            }
                        }
                        catch (e) {
                            if (!quiet) {
                                console.error("Error detected with default mapping for key:  code = " + n + ", shift state = " + (keyShiftState == 1 ? 'shift' : 'default'));
                            }
                        }
                    }
                    return ch;
                };
                Processor.getOutputTarget = function (Lelem) {
                    var keyman = com.keyman.singleton;
                    if (!Lelem && !keyman.isHeadless) {
                        Lelem = keyman.domManager.getLastActiveElement();
                        if (!Lelem) {
                            // If we're trying to find an active target but one doesn't exist, just return null.
                            return null;
                        }
                    }
                    // If we were provided an element or found an active element but it's improperly attached, that should cause an error.
                    if (Lelem._kmwAttachment && Lelem._kmwAttachment.interface) {
                        return Lelem._kmwAttachment.interface;
                    }
                    else {
                        throw new Error("OSK could not find element output target data!");
                    }
                };
                Processor.prototype._GetClickEventProperties = function (e, Lelem) {
                    var keyman = com.keyman.singleton;
                    var activeKeyboard = keyman.keyboardManager.activeKeyboard;
                    var formFactor = keyman.util.device.formFactor;
                    // Get key name and keyboard shift state (needed only for default layouts and physical keyboard handling)
                    // Note - virtual keys should be treated case-insensitive, so we force uppercasing here.
                    var layer = e.layer || e.displayLayer || '', keyName = e.id.toUpperCase();
                    // Start:  mirrors _GetKeyEventProperties
                    // Override key shift state if specified for key in layout (corrected for popup keys KMEW-93)
                    var keyShiftState = this.getModifierState(layer);
                    // First check the virtual key, and process shift, control, alt or function keys
                    var Lkc = {
                        Ltarg: Lelem,
                        Lmodifiers: keyShiftState,
                        Lstates: 0,
                        Lcode: text.Codes.keyCodes[keyName],
                        LisVirtualKey: true,
                        vkCode: 0,
                        kName: keyName,
                        kLayer: layer,
                        kbdLayer: e.displayLayer,
                        kNextLayer: e.nextlayer
                    };
                    // If it's actually a state key modifier, trigger its effects immediately, as KeyboardEvents would do the same.
                    switch (keyName) {
                        case 'K_CAPS':
                        case 'K_NUMLOCK':
                        case 'K_SCROLL':
                            this.stateKeys[keyName] = !this.stateKeys[keyName];
                    }
                    // Performs common pre-analysis for both 'native' and 'embedded' OSK key & subkey input events.
                    this.commonClickEventPreprocessing(Lkc);
                    // End - mirrors _GetKeyEventProperties
                    // Include *limited* support for mnemonic keyboards (Sept 2012)
                    // If a touch layout has been defined for a mnemonic keyout, do not perform mnemonic mapping for rules on touch devices.
                    if (activeKeyboard && activeKeyboard['KM'] && !(activeKeyboard['KVKL'] && formFactor != 'desktop')) {
                        if (Lkc.Lcode != text.Codes.keyCodes['K_SPACE']) { // exception required, March 2013
                            // Jan 2019 - interesting that 'K_SPACE' also affects the caps-state check...
                            Lkc.vkCode = Lkc.Lcode;
                            this.setMnemonicCode(Lkc, layer.indexOf('shift') != -1, this.stateKeys['K_CAPS']);
                        }
                    }
                    else {
                        Lkc.vkCode = Lkc.Lcode;
                    }
                    // Support version 1.0 KeymanWeb keyboards that do not define positional vs mnemonic
                    if (typeof activeKeyboard['KM'] == 'undefined') {
                        Lkc.Lcode = keyman.keyMapManager._USKeyCodeToCharCode(Lkc);
                        Lkc.LisVirtualKey = false;
                    }
                    return Lkc;
                };
                Processor.prototype.commonClickEventPreprocessing = function (Lkc) {
                    // Set the flags for the state keys.
                    Lkc.Lstates |= this.stateKeys['K_CAPS'] ? text.Codes.modifierCodes['CAPS'] : text.Codes.modifierCodes['NO_CAPS'];
                    Lkc.Lstates |= this.stateKeys['K_NUMLOCK'] ? text.Codes.modifierCodes['NUM_LOCK'] : text.Codes.modifierCodes['NO_NUM_LOCK'];
                    Lkc.Lstates |= this.stateKeys['K_SCROLL'] ? text.Codes.modifierCodes['SCROLL_LOCK'] : text.Codes.modifierCodes['NO_SCROLL_LOCK'];
                    // Set LisVirtualKey to false to ensure that nomatch rule does fire for U_xxxx keys
                    if (Lkc.kName.substr(0, 2) == 'U_') {
                        Lkc.LisVirtualKey = false;
                    }
                    // Get code for non-physical keys (T_KOKAI, U_05AB etc)
                    if (typeof Lkc.Lcode == 'undefined') {
                        Lkc.Lcode = this.getVKDictionaryCode(Lkc.kName); // Updated for Build 347
                        if (!Lkc.Lcode) {
                            // Special case for U_xxxx keys. This vk code will never be used
                            // in a keyboard, so we use this to ensure that keystroke processing
                            // occurs for the key.
                            Lkc.Lcode = 1;
                        }
                    }
                    // Handles modifier states when the OSK is emulating rightalt through the leftctrl-leftalt layer.
                    if ((Lkc.Lmodifiers & text.Codes.modifierBitmasks['ALT_GR_SIM']) == text.Codes.modifierBitmasks['ALT_GR_SIM'] && keyman_1.osk.Layouts.emulatesAltGr()) {
                        Lkc.Lmodifiers &= ~text.Codes.modifierBitmasks['ALT_GR_SIM'];
                        Lkc.Lmodifiers |= text.Codes.modifierCodes['RALT'];
                    }
                };
                Processor.prototype.processKeystroke = function (keyEvent, outputTarget, fromOSK, disableDOM) {
                    var keyman = com.keyman.singleton;
                    var activeKeyboard = keyman.keyboardManager.activeKeyboard;
                    var kbdInterface = keyman.interface;
                    var keyMapManager = keyman.keyMapManager;
                    if (!keyman.isEmbedded && !fromOSK && keyman.util.device.browser == 'firefox') {
                        // I1466 - Convert the - keycode on mnemonic as well as positional layouts
                        // FireFox, Mozilla Suite
                        if (keyMapManager.browserMap.FF['k' + keyEvent.Lcode]) {
                            keyEvent.Lcode = keyMapManager.browserMap.FF['k' + keyEvent.Lcode];
                        }
                    }
                    var LeventMatched = 0;
                    this.swallowKeypress = false;
                    // Pass this key code and state to the keyboard program
                    if (activeKeyboard && keyEvent.Lcode != 0) {
                        LeventMatched = LeventMatched || kbdInterface.processKeystroke(fromOSK ? keyman.util.device : keyman.util.physicalDevice, outputTarget, keyEvent);
                    }
                    if (!LeventMatched) {
                        // Restore the virtual key code if a mnemonic keyboard is being used
                        // If no vkCode value was stored, maintain the original Lcode value.
                        keyEvent.Lcode = keyEvent.vkCode || keyEvent.Lcode;
                        // Handle unmapped keys, including special keys
                        // The following is physical layout dependent, so should be avoided if possible.  All keys should be mapped.
                        kbdInterface.activeTargetOutput = outputTarget;
                        var ch = this.defaultKeyOutput(keyEvent, keyEvent.Lmodifiers, true, disableDOM);
                        kbdInterface.activeTargetOutput = null;
                        if (ch) {
                            if (ch == '\b') { // Is only returned when disableDOM is true, which prevents automatic default backspace application.
                                // defaultKeyOutput can't always find the outputTarget if we're working with alternates!
                                kbdInterface.defaultBackspace(outputTarget);
                            }
                            else {
                                kbdInterface.output(0, outputTarget, ch);
                            }
                            LeventMatched = 1;
                        }
                        else if (keyEvent.Lcode == 8) { // Backspace
                            LeventMatched = 1;
                        }
                    }
                    return LeventMatched == 1;
                };
                /**
                 * Simulate a keystroke according to the touched keyboard button element
                 *
                 * Handles default output and keyboard processing for both OSK and physical keystrokes.
                 *
                 * @param       {Object}      e      The abstracted KeyEvent to use for keystroke processing
                 */
                Processor.prototype.processKeyEvent = function (keyEvent, e) {
                    var keyman = com.keyman.singleton;
                    var fromOSK = !!e; // If specified, it's from the OSK.
                    // Enables embedded-path OSK sourcing detection.
                    if (typeof e == 'boolean') {
                        e = null; // Cast is necessary for TS type-checking later in the method.
                    }
                    var formFactor = keyman.util.device.formFactor;
                    var keyMapManager = keyman.keyMapManager;
                    this.swallowKeypress = false;
                    if (fromOSK && !keyman.isEmbedded) {
                        keyman.domManager.initActiveElement(keyEvent.Ltarg);
                        // Turn off key highlighting (or preview)
                        keyman['osk'].vkbd.highlightKey(e, false);
                    }
                    // Exclude menu and OSK hide keys from normal click processing
                    if (keyEvent.kName == 'K_LOPT' || keyEvent.kName == 'K_ROPT') {
                        keyman['osk'].vkbd.optionKey(e, keyEvent.kName, true);
                        return true;
                    }
                    // The default OSK layout for desktop devices does not include nextlayer info, relying on modifier detection here.
                    // It's the OSK equivalent to doModifierPress on 'desktop' form factors.
                    if ((formFactor == 'desktop' || keyman.keyboardManager.layoutIsDesktopBased()) && fromOSK) {
                        // If it's a desktop OSK style and this triggers a layer change,
                        // a modifier key was clicked.  No output expected, so it's safe to instantly exit.
                        if (this.selectLayer(keyEvent.kName, keyEvent.kNextLayer)) {
                            return true;
                        }
                    }
                    // Will handle keystroke-based non-layer change modifier & state keys, mapping them through the physical keyboard's version
                    // of state management.
                    if (!fromOSK && this.doModifierPress(keyEvent, !fromOSK)) {
                        return true;
                    }
                    if (!keyman.isEmbedded && !fromOSK && keyman.util.device.browser == 'firefox') {
                        // I1466 - Convert the - keycode on mnemonic as well as positional layouts
                        // FireFox, Mozilla Suite
                        if (keyMapManager.browserMap.FF['k' + keyEvent.Lcode]) {
                            keyEvent.Lcode = keyMapManager.browserMap.FF['k' + keyEvent.Lcode];
                        }
                    } //else 
                    //{
                    // Safari, IE, Opera?
                    //}
                    // If suggestions exist AND space is pressed, accept the suggestion and do not process the keystroke.
                    // If a suggestion was just accepted AND backspace is pressed, revert the change and do not process the backspace.
                    // We check the first condition here, while the prediction UI handles the second through the try__() methods below.
                    if (keyman.modelManager.enabled) {
                        // The following code relies on JS's logical operator "short-circuit" properties to prevent unwanted triggering of the second condition.
                        // Can the suggestion UI revert a recent suggestion?  If so, do that and swallow the backspace.
                        if ((keyEvent.kName == "K_BKSP" || keyEvent.Lcode == text.Codes.keyCodes["K_BKSP"]) && keyman.modelManager.tryRevertSuggestion()) {
                            return;
                            // Can the suggestion UI accept an existing suggestion?  If so, do that and swallow the space character.
                        }
                        else if ((keyEvent.kName == "K_SPACE" || keyEvent.Lcode == text.Codes.keyCodes["K_SPACE"]) && keyman.modelManager.tryAcceptSuggestion('space')) {
                            return;
                        }
                    }
                    if (fromOSK && !keyman.isEmbedded) {
                        keyman.uiManager.setActivatingUI(true);
                        com.keyman.DOMEventHandlers.states._IgnoreNextSelChange = 100;
                        keyman.domManager.focusLastActiveElement();
                        com.keyman.DOMEventHandlers.states._IgnoreNextSelChange = 0;
                    }
                    // // ...end I3363 (Build 301)
                    // Determine the current target for text output and create a "mock" backup
                    // of its current, pre-input state.
                    var outputTarget = Processor.getOutputTarget(keyEvent.Ltarg);
                    var preInputMock = text.Mock.from(outputTarget);
                    var LeventMatched = this.processKeystroke(keyEvent, outputTarget, fromOSK, false);
                    // Swap layer as appropriate.
                    if (keyEvent.kNextLayer) {
                        this.selectLayer(keyEvent.kName, keyEvent.kNextLayer);
                    }
                    // Should we swallow any further processing of keystroke events for this keydown-keypress sequence?
                    if (LeventMatched) {
                        var alternates = void 0;
                        // Note - we don't yet do fat-fingering with longpress keys.
                        if (keyEvent.keyDistribution && keyEvent.kbdLayer) {
                            var activeLayout = keyman['osk'].vkbd.layout;
                            alternates = [];
                            for (var _i = 0, _a = keyEvent.keyDistribution; _i < _a.length; _i++) {
                                var pair = _a[_i];
                                var mock = text.Mock.from(preInputMock);
                                var altKey = activeLayout.getLayer(keyEvent.kbdLayer).getKey(pair.keyId);
                                if (!altKey) {
                                    console.warn("Potential fat-finger key could not be found in layer!");
                                    continue;
                                }
                                var altEvent = this._GetClickEventProperties(altKey, keyEvent.Ltarg);
                                if (this.processKeystroke(altEvent, mock, fromOSK, true)) {
                                    alternates.push({ sample: mock.buildTransformFrom(preInputMock), 'p': pair.p });
                                }
                            }
                        }
                        // Notify the ModelManager of new input
                        var transcription = outputTarget.buildTranscriptionFrom(preInputMock, keyEvent, alternates);
                        keyman.modelManager.predict(transcription);
                        // Since this method now performs changes for 'default' keystrokes, synthetic 'change' event generation
                        // belongs here, rather than only in interface.processKeystroke() as in versions pre-12.
                        if (outputTarget.getElement()) {
                            keyman['interface'].doInputEvent(outputTarget.getElement());
                        }
                        this.swallowKeypress = (e && keyEvent.Lcode != 8 ? keyEvent.Lcode != 0 : false);
                        if (keyEvent.Lcode == 8) {
                            this.swallowKeypress = false;
                        }
                        return false;
                    }
                    else {
                        this.swallowKeypress = false;
                    }
                    /* I732 END - 13/03/2007 MCD: End Positional Layout support in OSK */
                    if (fromOSK && !keyman.isEmbedded) {
                        keyman.uiManager.setActivatingUI(false); // I2498 - KeymanWeb OSK does not accept clicks in FF when using automatic UI
                    }
                    // Special case for embedded to pass K_TAB back to device to process
                    if (keyman.isEmbedded && (keyEvent.Lcode == text.Codes.keyCodes["K_TAB"] ||
                        keyEvent.Lcode == text.Codes.keyCodes["K_TABBACK"] || keyEvent.Lcode == text.Codes.keyCodes["K_TABFWD"])) {
                        return false;
                    }
                    return !LeventMatched;
                };
                /**
                 * Simulate a keystroke according to the touched keyboard button element
                 *
                 * Note that the test-case oriented 'recorder' stubs this method to facilitate OSK-based input
                 * recording for use in test cases.  If changing this function, please ensure the recorder is
                 * not affected.
                 *
                 * @param       {Object}      e      element touched (or clicked)
                 */
                Processor.prototype.clickKey = function (e, touch, layerId, keyDistribution) {
                    var keyman = com.keyman.singleton;
                    var Lelem = keyman.domManager.getLastActiveElement();
                    if (Lelem != null) {
                        // Handle any DOM state management related to click inputs.
                        var outputTarget = Processor.getOutputTarget(Lelem);
                        keyman.domManager.initActiveElement(Lelem);
                        // Turn off key highlighting (or preview)
                        keyman['osk'].vkbd.highlightKey(e, false);
                        // Clear any cached codepoint data; we can rebuild it if it's unchanged.
                        outputTarget.invalidateSelection();
                        // Deadkey matching continues to be troublesome.
                        // Deleting matched deadkeys here seems to correct some of the issues.   (JD 6/6/14)
                        outputTarget.deadkeys().deleteMatched(); // Delete any matched deadkeys before continuing
                        var Lkc = this._GetClickEventProperties(e['key'].spec, Lelem);
                        if (keyman.modelManager.enabled) {
                            Lkc.source = touch;
                            Lkc.keyDistribution = keyDistribution;
                        }
                        return this.processKeyEvent(Lkc, e);
                    }
                    else {
                        return true;
                    }
                };
                // FIXME:  makes some bad assumptions.
                Processor.prototype.setMnemonicCode = function (Lkc, shifted, capsActive) {
                    // K_SPACE is not handled by defaultKeyOutput for physical keystrokes unless using touch-aliased elements.
                    // It's also a "exception required, March 2013" for clickKey, so at least they both have this requirement.
                    if (Lkc.Lcode != text.Codes.keyCodes['K_SPACE']) {
                        // So long as the key name isn't prefixed with 'U_', we'll get a default mapping based on the Lcode value.
                        // We need to determine the mnemonic base character - for example, SHIFT + K_PERIOD needs to map to '>'.
                        var mappingEvent = new text.KeyEvent();
                        for (var key in Lkc) {
                            mappingEvent[key] = Lkc[key];
                        }
                        // To facilitate storing relevant commands, we should probably reverse-lookup
                        // the actual keyname instead.
                        mappingEvent.kName = 'K_xxxx';
                        mappingEvent.Ltarg = null;
                        var mappedChar = this.defaultKeyOutput(mappingEvent, (shifted ? 0x10 : 0), false, true);
                        /* First, save a backup of the original code.  This one won't needlessly trigger keyboard
                         * rules, but allows us to replicate/emulate commands after rule processing if needed.
                         * (Like backspaces)
                         */
                        Lkc.vkCode = Lkc.Lcode;
                        if (mappedChar) {
                            // Will return 96 for 'a', which is a keycode corresponding to Codes.keyCodes('K_NP1') - a numpad key.
                            // That stated, we're in mnemonic mode - this keyboard's rules are based on the char codes.
                            Lkc.Lcode = mappedChar.charCodeAt(0);
                        }
                        else {
                            // Don't let command-type keys (like K_DEL, which will output '.' otherwise!)
                            // trigger keyboard rules.
                            delete Lkc.Lcode;
                        }
                    }
                    if (capsActive) {
                        // TODO:  Needs fixing - does not properly mirror physical keystrokes, as Lcode range 96-111 corresponds
                        // to numpad keys!  (Physical keyboard section has its own issues here.)
                        if ((Lkc.Lcode >= 65 && Lkc.Lcode <= 90) /* 'A' - 'Z' */ || (Lkc.Lcode >= 97 && Lkc.Lcode <= 122) /* 'a' - 'z' */) {
                            Lkc.Lmodifiers ^= 0x10; // Flip the 'shifted' bit, so it'll act as the opposite key.
                            Lkc.Lcode ^= 0x20; // Flips the 'upper' vs 'lower' bit for the base 'a'-'z' ASCII alphabetics.
                        }
                    }
                };
                /**
                 * Get modifier key state from layer id
                 *
                 * @param       {string}      layerId       layer id (e.g. ctrlshift)
                 * @return      {number}                    modifier key state (desktop keyboards)
                 */
                Processor.prototype.getModifierState = function (layerId) {
                    var modifier = 0;
                    if (layerId.indexOf('shift') >= 0) {
                        modifier |= text.Codes.modifierCodes['SHIFT'];
                    }
                    // The chiral checks must not be directly exclusive due each other to visual OSK feedback.
                    var ctrlMatched = false;
                    if (layerId.indexOf('leftctrl') >= 0) {
                        modifier |= text.Codes.modifierCodes['LCTRL'];
                        ctrlMatched = true;
                    }
                    if (layerId.indexOf('rightctrl') >= 0) {
                        modifier |= text.Codes.modifierCodes['RCTRL'];
                        ctrlMatched = true;
                    }
                    if (layerId.indexOf('ctrl') >= 0 && !ctrlMatched) {
                        modifier |= text.Codes.modifierCodes['CTRL'];
                    }
                    var altMatched = false;
                    if (layerId.indexOf('leftalt') >= 0) {
                        modifier |= text.Codes.modifierCodes['LALT'];
                        altMatched = true;
                    }
                    if (layerId.indexOf('rightalt') >= 0) {
                        modifier |= text.Codes.modifierCodes['RALT'];
                        altMatched = true;
                    }
                    if (layerId.indexOf('alt') >= 0 && !altMatched) {
                        modifier |= text.Codes.modifierCodes['ALT'];
                    }
                    return modifier;
                };
                /**
                 * @summary Look up a custom virtual key code in the virtual key code dictionary KVKD.  On first run, will build the dictionary.
                 *
                 * `VKDictionary` is constructed from the keyboard's `KVKD` member. This list is constructed
                 * at compile-time and is a list of 'additional' virtual key codes, starting at 256 (i.e.
                 * outside the range of standard virtual key codes). These additional codes are both
                 * `[T_xxx]` and `[U_xxxx]` custom key codes from the Keyman keyboard language. However,
                 * `[U_xxxx]` keys only generate an entry in `KVKD` if there is a corresponding rule that
                 * is associated with them in the keyboard rules. If the `[U_xxxx]` key code is only
                 * referenced as the id of a key in the touch layout, then it does not get an entry in
                 * the `KVKD` property.
                 *
                 * @private
                 * @param       {string}      keyName   custom virtual key code to lookup in the dictionary
                 * @return      {number}                key code > 255 on success, or 0 if not found
                 */
                Processor.prototype.getVKDictionaryCode = function (keyName) {
                    var keyman = com.keyman.singleton;
                    var activeKeyboard = keyman.keyboardManager.activeKeyboard;
                    if (!activeKeyboard['VKDictionary']) {
                        var a = [];
                        if (typeof activeKeyboard['KVKD'] == 'string') {
                            // Build the VK dictionary
                            // TODO: Move the dictionary build into the compiler -- so compiler generates code such as following.  
                            // Makes the VKDictionary member unnecessary.
                            //       this.KVKD={"K_ABC":256,"K_DEF":257,...};
                            var s = activeKeyboard['KVKD'].split(' ');
                            for (var i = 0; i < s.length; i++) {
                                a[s[i].toUpperCase()] = i + 256; // We force upper-case since virtual keys should be case-insensitive.
                            }
                        }
                        activeKeyboard['VKDictionary'] = a;
                    }
                    var res = activeKeyboard['VKDictionary'][keyName.toUpperCase()];
                    return res ? res : 0;
                };
                /**
                 * Function     _UpdateVKShift
                 * Scope        Private
                 * @param       {Object}            e     OSK event
                 * @param       {number}            v     keyboard shift state
                 * @param       {(boolean|number)}  d     set (1) or clear(0) shift state bits
                 * @return      {boolean}                 Always true
                 * Description  Updates the current shift state within KMW, updating the OSK's visualization thereof.
                 */
                Processor.prototype._UpdateVKShift = function (e, v, d) {
                    var keyShiftState = 0, lockStates = 0, i;
                    var keyman = com.keyman.singleton;
                    var lockNames = ['CAPS', 'NUM_LOCK', 'SCROLL_LOCK'];
                    var lockKeys = ['K_CAPS', 'K_NUMLOCK', 'K_SCROLL'];
                    if (e) {
                        // read shift states from Pevent
                        keyShiftState = e.Lmodifiers;
                        lockStates = e.Lstates;
                        // Are we simulating AltGr?  If it's a simulation and not real, time to un-simulate for the OSK.
                        if (keyman.keyboardManager.isChiral() && keyman_1.osk.Layouts.emulatesAltGr() &&
                            (this.modStateFlags & text.Codes.modifierBitmasks['ALT_GR_SIM']) == text.Codes.modifierBitmasks['ALT_GR_SIM']) {
                            keyShiftState |= text.Codes.modifierBitmasks['ALT_GR_SIM'];
                            keyShiftState &= ~text.Codes.modifierCodes['RALT'];
                        }
                        for (i = 0; i < lockNames.length; i++) {
                            if (lockStates & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = lockStates & text.Codes.modifierCodes[lockNames[i]];
                            }
                        }
                    }
                    else if (d) {
                        keyShiftState |= v;
                        for (i = 0; i < lockNames.length; i++) {
                            if (v & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = true;
                            }
                        }
                    }
                    else {
                        keyShiftState &= ~v;
                        for (i = 0; i < lockNames.length; i++) {
                            if (v & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = false;
                            }
                        }
                    }
                    // Find and display the selected OSK layer
                    if (keyman['osk'].vkbd) {
                        keyman['osk'].vkbd.showLayer(this.getLayerId(keyShiftState));
                    }
                    // osk._UpdateVKShiftStyle will be called automatically upon the next _Show.
                    if (keyman.osk._Visible) {
                        keyman.osk._Show();
                    }
                    return true;
                };
                Processor.prototype.getLayerId = function (modifier) {
                    return keyman_1.osk.Layouts.getLayerId(modifier);
                };
                /**
                 * Select the OSK's next keyboard layer based upon layer switching keys as a default
                 * The next layer will be determined from the key name unless otherwise specifed
                 *
                 *  @param  {string}                    keyName     key identifier
                 *  @param  {number|string|undefined}   nextLayerIn optional next layer identifier
                 *  @return {boolean}                               return true if keyboard layer changed
                 */
                Processor.prototype.selectLayer = function (keyName, nextLayerIn) {
                    var nextLayer = arguments.length < 2 ? null : nextLayerIn;
                    var keyman = com.keyman.singleton;
                    var isChiral = keyman.keyboardManager.isChiral();
                    // Layer must be identified by name, not number (27/08/2015)
                    if (typeof nextLayer == 'number') {
                        nextLayer = this.getLayerId(nextLayer * 0x10);
                    }
                    // Identify next layer, if required by key
                    if (!nextLayer) {
                        switch (keyName) {
                            case 'K_LSHIFT':
                            case 'K_RSHIFT':
                            case 'K_SHIFT':
                                nextLayer = 'shift';
                                break;
                            case 'K_LCONTROL':
                            case 'K_LCTRL':
                                if (isChiral) {
                                    nextLayer = 'leftctrl';
                                    break;
                                }
                            case 'K_RCONTROL':
                            case 'K_RCTRL':
                                if (isChiral) {
                                    nextLayer = 'rightctrl';
                                    break;
                                }
                            case 'K_CTRL':
                                nextLayer = 'ctrl';
                                break;
                            case 'K_LMENU':
                            case 'K_LALT':
                                if (isChiral) {
                                    nextLayer = 'leftalt';
                                    break;
                                }
                            case 'K_RMENU':
                            case 'K_RALT':
                                if (isChiral) {
                                    nextLayer = 'rightalt';
                                    break;
                                }
                            case 'K_ALT':
                                nextLayer = 'alt';
                                break;
                            case 'K_ALTGR':
                                if (isChiral) {
                                    nextLayer = 'leftctrl-rightalt';
                                }
                                else {
                                    nextLayer = 'ctrl-alt';
                                }
                                break;
                            case 'K_CURRENCIES':
                            case 'K_NUMERALS':
                            case 'K_SHIFTED':
                            case 'K_UPPER':
                            case 'K_LOWER':
                            case 'K_SYMBOLS':
                                nextLayer = 'default';
                                break;
                        }
                    }
                    // If no key corresponding to a layer transition is pressed, maintain the current layer.
                    if (!nextLayer) {
                        return false;
                    }
                    // Change layer and refresh OSK
                    this.updateLayer(nextLayer);
                    com.keyman.singleton.osk._Show();
                    return true;
                };
                /**
                 * Sets the new layer id, allowing for toggling shift/ctrl/alt while preserving the remainder
                 * of the modifiers represented by the current layer id (where applicable)
                 *
                 * @param       {string}      id      layer id (e.g. ctrlshift)
                 */
                Processor.prototype.updateLayer = function (id) {
                    var keyman = com.keyman.singleton;
                    var vkbd = keyman['osk'].vkbd;
                    if (!vkbd) {
                        return;
                    }
                    var activeLayer = vkbd.layerId;
                    var s = activeLayer;
                    // Do not change layer unless needed (27/08/2015)
                    if (id == activeLayer && keyman.util.device.formFactor != 'desktop') {
                        return false;
                    }
                    var idx = id;
                    var i;
                    if (keyman.util.device.formFactor == 'desktop') {
                        // Need to test if target layer is a standard layer (based on the plain 'default')
                        var replacements = ['leftctrl', 'rightctrl', 'ctrl', 'leftalt', 'rightalt', 'alt', 'shift'];
                        for (i = 0; i < replacements.length; i++) {
                            // Don't forget to remove the kebab-case hyphens!
                            idx = idx.replace(replacements[i] + '-', '');
                            idx = idx.replace(replacements[i], '');
                        }
                        // If we are presently on the default layer, drop the 'default' and go straight to the shifted mode.
                        // If on a common symbolic layer, drop out of symbolic mode and go straight to the shifted mode.
                        if (activeLayer == 'default' || activeLayer == 'numeric' || activeLayer == 'symbol' || activeLayer == 'currency' || idx != '') {
                            s = id;
                        }
                        // Otherwise, we are based upon a layer that accepts modifier variations.
                        // Modify the layer according to the current state and key pressed.
                        //
                        // TODO:  Consider:  should this ever be allowed for a base layer other than 'default'?  If not,
                        // if(idx == '') with accompanying if-else structural shift would be a far better test here.
                        else {
                            // Save our current modifier state.
                            var modifier = this.getModifierState(s);
                            // Strip down to the base modifiable layer.
                            for (i = 0; i < replacements.length; i++) {
                                // Don't forget to remove the kebab-case hyphens!
                                s = s.replace(replacements[i] + '-', '');
                                s = s.replace(replacements[i], '');
                            }
                            // Toggle the modifier represented by our input argument.
                            switch (id) {
                                case 'shift':
                                    modifier ^= text.Codes.modifierCodes['SHIFT'];
                                    break;
                                case 'leftctrl':
                                    modifier ^= text.Codes.modifierCodes['LCTRL'];
                                    break;
                                case 'rightctrl':
                                    modifier ^= text.Codes.modifierCodes['RCTRL'];
                                    break;
                                case 'ctrl':
                                    modifier ^= text.Codes.modifierCodes['CTRL'];
                                    break;
                                case 'leftalt':
                                    modifier ^= text.Codes.modifierCodes['LALT'];
                                    break;
                                case 'rightalt':
                                    modifier ^= text.Codes.modifierCodes['RALT'];
                                    break;
                                case 'alt':
                                    modifier ^= text.Codes.modifierCodes['ALT'];
                                    break;
                                default:
                                    s = id;
                            }
                            // Combine our base modifiable layer and attach the new modifier variation info to obtain our destination layer.
                            if (s != 'default') {
                                if (s == '') {
                                    s = this.getLayerId(modifier);
                                }
                                else {
                                    s = this.getLayerId(modifier) + '-' + s;
                                }
                            }
                        }
                        if (s == '') {
                            s = 'default';
                        }
                    }
                    else {
                        // Mobile form-factor.  Either the layout is specified by a keyboard developer with direct layer name references
                        // or all layers are accessed via subkey of a single layer-shifting key - no need for modifier-combining logic.
                        s = id;
                    }
                    // Actually set the new layer id.
                    if (vkbd) {
                        if (!vkbd.showLayer(s)) {
                            vkbd.showLayer('default');
                        }
                    }
                };
                /**
                 * Function     _GetEventKeyCode
                 * Scope        Private
                 * @param       {Event}       e         Event object
                 * Description  Finds the key code represented by the event.
                 */
                Processor.prototype._GetEventKeyCode = function (e) {
                    if (e.keyCode) {
                        return e.keyCode;
                    }
                    else if (e.which) {
                        return e.which;
                    }
                    else {
                        return null;
                    }
                };
                // Returns true if the key event is a modifier press, allowing keyPress to return selectively
                // in those cases.
                Processor.prototype.doModifierPress = function (Levent, isKeyDown) {
                    var keyman = com.keyman.singleton;
                    switch (Levent.Lcode) {
                        case 8:
                            Processor.getOutputTarget(Levent.Ltarg).deadkeys().clear();
                            break; // I3318 (always clear deadkeys after backspace) 
                        case 16: //"K_SHIFT":16,"K_CONTROL":17,"K_ALT":18
                        case 17:
                        case 18:
                        case 20: //"K_CAPS":20, "K_NUMLOCK":144,"K_SCROLL":145
                        case 144:
                        case 145:
                            // For eventual integration - we bypass an OSK update for physical keystrokes when in touch mode.
                            keyman['interface'].notifyKeyboard(Levent.Lcode, Levent.Ltarg, isKeyDown ? 1 : 0);
                            if (!keyman.util.device.touchable) {
                                return this._UpdateVKShift(Levent, Levent.Lcode - 15, 1); // I2187
                            }
                            else {
                                return true;
                            }
                    }
                    if (Levent.LmodifierChange) {
                        keyman['interface'].notifyKeyboard(0, Levent.Ltarg, 1);
                        this._UpdateVKShift(Levent, 0, 1);
                    }
                    // No modifier keypresses detected.
                    return false;
                };
                /**
                 * Function     _GetKeyEventProperties
                 * Scope        Private
                 * @param       {Event}       e         Event object
                 * @param       {boolean=}    keyState  true if call results from a keyDown event, false if keyUp, undefined if keyPress
                 * @return      {Object.<string,*>}     KMW keyboard event object:
                 * Description  Get object with target element, key code, shift state, virtual key state
                 *                Ltarg=target element
                 *                Lcode=keyCode
                 *                Lmodifiers=shiftState
                 *                LisVirtualKeyCode e.g. ctrl/alt key
                 *                LisVirtualKey     e.g. Virtual key or non-keypress event
                 */
                Processor.prototype._GetKeyEventProperties = function (e, keyState) {
                    var keyman = com.keyman.singleton;
                    var s = new text.KeyEvent();
                    e = keyman._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                    if (e.cancelBubble === true) {
                        return null; // I2457 - Facebook meta-event generation mess -- two events generated for a keydown in Facebook contentEditable divs
                    }
                    s.Ltarg = keyman.util.eventTarget(e);
                    if (s.Ltarg == null) {
                        return null;
                    }
                    else if (s.Ltarg.nodeType == 3) { // defeat Safari bug
                        s.Ltarg = s.Ltarg.parentNode;
                    }
                    s.Lcode = this._GetEventKeyCode(e);
                    if (s.Lcode == null) {
                        return null;
                    }
                    // Stage 1 - track the true state of the keyboard's modifiers.
                    var prevModState = this.modStateFlags, curModState = 0x0000;
                    var ctrlEvent = false, altEvent = false;
                    var keyCodes = text.Codes.keyCodes;
                    switch (s.Lcode) {
                        case keyCodes['K_CTRL']: // The 3 shorter "K_*CTRL" entries exist in some legacy keyboards.
                        case keyCodes['K_LCTRL']:
                        case keyCodes['K_RCTRL']:
                        case keyCodes['K_CONTROL']:
                        case keyCodes['K_LCONTROL']:
                        case keyCodes['K_RCONTROL']:
                            ctrlEvent = true;
                            break;
                        case keyCodes['K_LMENU']: // The 2 "K_*MENU" entries exist in some legacy keyboards.
                        case keyCodes['K_RMENU']:
                        case keyCodes['K_ALT']:
                        case keyCodes['K_LALT']:
                        case keyCodes['K_RALT']:
                            altEvent = true;
                            break;
                    }
                    /**
                     * Two separate conditions exist that should trigger chiral modifier detection.  Examples below use CTRL but also work for ALT.
                     *
                     * 1.  The user literally just pressed CTRL, so the event has a valid `location` property we can utilize.
                     *     Problem: its layer isn't presently activated within the OSK.
                     *
                     * 2.  CTRL has been held a while, so the OSK layer is valid, but the key event doesn't tell us the chirality of the active CTRL press.
                     *     Bonus issue:  RAlt simulation may cause erasure of this location property, but it should ONLY be empty if pressed in this case.
                     *     We default to the 'left' variants since they're more likely to exist and cause less issues with RAlt simulation handling.
                     *
                     * In either case, `e.getModifierState("Control")` is set to true, but as a result does nothing to tell us which case is active.
                     *
                     * `e.location != 0` if true matches condition 1 and matches condition 2 if false.
                     */
                    curModState |= (e.getModifierState("Shift") ? 0x10 : 0);
                    var modifierCodes = text.Codes.modifierCodes;
                    if (e.getModifierState("Control")) {
                        curModState |= ((e.location != 0 && ctrlEvent) ?
                            (e.location == 1 ? modifierCodes['LCTRL'] : modifierCodes['RCTRL']) : // Condition 1
                            prevModState & 0x0003); // Condition 2
                    }
                    if (e.getModifierState("Alt")) {
                        curModState |= ((e.location != 0 && altEvent) ?
                            (e.location == 1 ? modifierCodes['LALT'] : modifierCodes['RALT']) : // Condition 1
                            prevModState & 0x000C); // Condition 2
                    }
                    // Stage 2 - detect state key information.  It can be looked up per keypress with no issue.
                    s.Lstates = 0;
                    s.Lstates |= e.getModifierState('CapsLock') ? modifierCodes['CAPS'] : modifierCodes['NO_CAPS'];
                    s.Lstates |= e.getModifierState('NumLock') ? modifierCodes['NUM_LOCK'] : modifierCodes['NO_NUM_LOCK'];
                    s.Lstates |= (e.getModifierState('ScrollLock') || e.getModifierState("Scroll")) // "Scroll" for IE9.
                        ? modifierCodes['SCROLL_LOCK'] : modifierCodes['NO_SCROLL_LOCK'];
                    // We need these states to be tracked as well for proper OSK updates.
                    curModState |= s.Lstates;
                    // Stage 3 - Set our modifier state tracking variable and perform basic AltGr-related management.
                    s.LmodifierChange = this.modStateFlags != curModState;
                    this.modStateFlags = curModState;
                    // For European keyboards, not all browsers properly send both key-up events for the AltGr combo.
                    var altGrMask = modifierCodes['RALT'] | modifierCodes['LCTRL'];
                    if ((prevModState & altGrMask) == altGrMask && (curModState & altGrMask) != altGrMask) {
                        // We just released AltGr - make sure it's all released.
                        curModState &= ~altGrMask;
                    }
                    // Perform basic filtering for Windows-based ALT_GR emulation on European keyboards.
                    if (curModState & modifierCodes['RALT']) {
                        curModState &= ~modifierCodes['LCTRL'];
                    }
                    var modifierBitmasks = text.Codes.modifierBitmasks;
                    // Stage 4 - map the modifier set to the appropriate keystroke's modifiers.
                    if (keyman.keyboardManager.isChiral()) {
                        s.Lmodifiers = curModState & modifierBitmasks.CHIRAL;
                        // Note for future - embedding a kill switch here or in keymanweb.osk.emulatesAltGr would facilitate disabling
                        // AltGr / Right-alt simulation.
                        if (keyman_1.osk.Layouts.emulatesAltGr() && (s.Lmodifiers & modifierBitmasks['ALT_GR_SIM']) == modifierBitmasks['ALT_GR_SIM']) {
                            s.Lmodifiers ^= modifierBitmasks['ALT_GR_SIM'];
                            s.Lmodifiers |= modifierCodes['RALT'];
                        }
                    }
                    else {
                        // No need to sim AltGr here; we don't need chiral ALTs.
                        s.Lmodifiers =
                            (curModState & 0x10) | // SHIFT
                                ((curModState & (modifierCodes['LCTRL'] | modifierCodes['RCTRL'])) ? 0x20 : 0) |
                                ((curModState & (modifierCodes['LALT'] | modifierCodes['RALT'])) ? 0x40 : 0);
                    }
                    // Mnemonic handling.
                    var activeKeyboard = keyman.keyboardManager.activeKeyboard;
                    if (activeKeyboard && activeKeyboard['KM']) {
                        // The following will never set a code corresponding to a modifier key, so it's fine to do this,
                        // which may change the value of Lcode, here.
                        this.setMnemonicCode(s, e.getModifierState("Shift"), e.getModifierState("CapsLock"));
                    }
                    // The 0x6F used to be 0x60 - this adjustment now includes the chiral alt and ctrl modifiers in that check.
                    var LisVirtualKeyCode = (typeof e.charCode != 'undefined' && e.charCode != null && (e.charCode == 0 || (s.Lmodifiers & 0x6F) != 0));
                    s.LisVirtualKey = LisVirtualKeyCode || e.type != 'keypress';
                    var keyMapManager = keyman.keyMapManager;
                    // Other minor physical-keyboard adjustments
                    if (activeKeyboard && !activeKeyboard['KM']) {
                        // Positional Layout
                        /* 13/03/2007 MCD: Swedish: Start mapping of keystroke to US keyboard */
                        var Lbase = keyMapManager.languageMap[com.keyman.osk.Layouts._BaseLayout];
                        if (Lbase && Lbase['k' + s.Lcode]) {
                            s.Lcode = Lbase['k' + s.Lcode];
                        }
                        /* 13/03/2007 MCD: Swedish: End mapping of keystroke to US keyboard */
                        if (typeof (activeKeyboard['KM']) == 'undefined' && !(s.Lmodifiers & 0x60)) {
                            // Support version 1.0 KeymanWeb keyboards that do not define positional vs mnemonic
                            s = {
                                Lcode: keyMapManager._USKeyCodeToCharCode(s),
                                Ltarg: s.Ltarg,
                                Lmodifiers: 0,
                                LisVirtualKey: false,
                                vkCode: s.Lcode,
                                Lstates: s.Lstates,
                                kName: ''
                            };
                        }
                    }
                    return s;
                };
                /**
                 * Function     keyDown
                 * Scope        Public
                 * Description  Processes keydown event and passes data to keyboard.
                 *
                 * Note that the test-case oriented 'recorder' stubs this method to facilitate keystroke
                 * recording for use in test cases.  If changing this function, please ensure the recorder is
                 * not affected.
                 */
                Processor.prototype.keyDown = function (e) {
                    this.swallowKeypress = false;
                    // Get event properties  
                    var Levent = this._GetKeyEventProperties(e, true);
                    if (Levent == null) {
                        return true;
                    }
                    var LeventMatched = !this.processKeyEvent(Levent);
                    if (LeventMatched) {
                        if (e && e.preventDefault) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }
                    return !LeventMatched;
                };
                // KeyUp basically exists for two purposes:
                // 1)  To detect browser form submissions (handled in kmwdomevents.ts)
                // 2)  To detect modifier state changes.
                Processor.prototype.keyUp = function (e) {
                    var Levent = this._GetKeyEventProperties(e, false);
                    if (Levent == null) {
                        return true;
                    }
                    return this.doModifierPress(Levent, false);
                };
                Processor.prototype.keyPress = function (e) {
                    var keyman = com.keyman.singleton;
                    var Levent = this._GetKeyEventProperties(e);
                    if (Levent == null || Levent.LisVirtualKey) {
                        return true;
                    }
                    // _Debug('KeyPress code='+Levent.Lcode+'; Ltarg='+Levent.Ltarg.tagName+'; LisVirtualKey='+Levent.LisVirtualKey+'; _KeyPressToSwallow='+keymanweb._KeyPressToSwallow+'; keyCode='+(e?e.keyCode:'nothing'));
                    /* I732 START - 13/03/2007 MCD: Swedish: Start positional keyboard layout code: prevent keystroke */
                    if (!keyman.keyboardManager.activeKeyboard['KM']) {
                        if (!this.swallowKeypress) {
                            return true;
                        }
                        if (Levent.Lcode < 0x20 || (keyman._BrowserIsSafari && (Levent.Lcode > 0xF700 && Levent.Lcode < 0xF900))) {
                            return true;
                        }
                        e = keyman._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                        if (e) {
                            e.returnValue = false;
                        }
                        return false;
                    }
                    /* I732 END - 13/03/2007 MCD: Swedish: End positional keyboard layout code */
                    var outputTarget = Processor.getOutputTarget(Levent.Ltarg);
                    // Only reached if it's a mnemonic keyboard.
                    if (this.swallowKeypress || keyman['interface'].processKeystroke(keyman.util.physicalDevice, outputTarget, Levent)) {
                        this.swallowKeypress = false;
                        if (e && e.preventDefault) {
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        return false;
                    }
                    this.swallowKeypress = false;
                    return true;
                };
                return Processor;
            }());
            text.Processor = Processor;
        })(text = keyman_1.text || (keyman_1.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman_2) {
        /*
        * Note that for many of the actual events represented by methods in this file, `this` is replaced
        * automatically by JavaScript's event handling system.  As such, many 'wrapper' variants of the events
        * exist to restore the object-oriented hierarchy below.
        *
        */
        var CommonDOMStates = /** @class */ (function () {
            function CommonDOMStates() {
                this._DisableInput = false; // Should input be disabled?
                this._IgnoreNextSelChange = 0; // when a visual keyboard key is mouse-down, ignore the next sel change because this stuffs up our history  
                this._IgnoreBlurFocus = false; // Used to temporarily ignore focus changes
                this._Selection = null;
                this._SelectionControl = null; // Type behavior is as with activeElement and the like.
            }
            /* ----------------------- Static event-related methods ------------------------ */
            CommonDOMStates.prototype.setFocusTimer = function () {
                this.focusing = true;
                this.focusTimer = window.setTimeout(function () {
                    this.focusing = false;
                }.bind(this), 1000);
            };
            return CommonDOMStates;
        }());
        keyman_2.CommonDOMStates = CommonDOMStates;
        /**
         * Declares a base, non-touch oriented implementation of all relevant DOM-related event handlers and state functions.
         */
        var DOMEventHandlers = /** @class */ (function () {
            function DOMEventHandlers(keyman) {
                /**
                 * Handle receiving focus by simulated input field
                 */
                this.setFocus = function (e) {
                    // Touch-only handler.
                }.bind(this);
                /**
                 * Handles touch-based loss of focus events.
                 */
                this.setBlur = function (e) {
                    // Touch-only handler.
                }.bind(this);
                // End of I3363 (Build 301) additions
                // Universal DOM event handlers (both desktop + touch)
                //TODO: add more complete description of what ControlFocus really does
                /**
                 * Respond to KeymanWeb-aware input element receiving focus
                 */
                this._ControlFocus = function (e) {
                    var Ltarg, Ln;
                    var device = this.keyman.util.device;
                    var osk = this.keyman.osk;
                    e = this.keyman._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                    Ltarg = this.keyman.util.eventTarget(e);
                    if (Ltarg == null) {
                        return true;
                    }
                    if (Ltarg['body']) {
                        Ltarg = Ltarg['body']; // Occurs in Firefox for design-mode iframes.
                    }
                    // Prevent any action if a protected input field
                    if (device.touchable && (Ltarg.className == null || Ltarg.className.indexOf('keymanweb-input') < 0)) {
                        return true;
                    }
                    // Or if not a remappable input field
                    var en = Ltarg.nodeName.toLowerCase();
                    if (Ltarg.ownerDocument && Ltarg instanceof Ltarg.ownerDocument.defaultView.HTMLInputElement) {
                        var et = Ltarg.type.toLowerCase();
                        if (!(et == 'text' || et == 'search')) {
                            return true;
                        }
                    }
                    else if (Ltarg.ownerDocument && Ltarg.ownerDocument.designMode == 'on') {
                        // continue; don't block this one!
                    }
                    else if ((device.touchable || !Ltarg.isContentEditable)
                        && !(Ltarg.ownerDocument && Ltarg instanceof Ltarg.ownerDocument.defaultView.HTMLTextAreaElement)) {
                        return true;
                    }
                    DOMTouchHandlers.states.activeElement = Ltarg; // I3363 (Build 301)  
                    if (Ltarg.nodeType == 3) { // defeat Safari bug
                        Ltarg = Ltarg.parentNode;
                    }
                    var LfocusTarg = Ltarg;
                    // Ensure that focussed element is visible above the keyboard
                    if (Ltarg.className == null || Ltarg.className.indexOf('keymanweb-input') < 0) {
                        if (this instanceof DOMTouchHandlers) {
                            this.scrollBody(Ltarg);
                        }
                    }
                    if (Ltarg.ownerDocument && Ltarg instanceof Ltarg.ownerDocument.defaultView.HTMLIFrameElement) { //**TODO: check case reference
                        this.keyman.domManager._AttachToIframe(Ltarg);
                        Ltarg = Ltarg.contentWindow.document.body;
                    }
                    //??keymanweb._Selection = null;
                    // We condition on 'priorElement' below as a check to allow KMW to set a default active keyboard.
                    var priorElement = DOMEventHandlers.states.lastActiveElement;
                    DOMEventHandlers.states.lastActiveElement = Ltarg;
                    if (this.keyman.uiManager.justActivated) {
                        this._BlurKeyboardSettings();
                    }
                    else {
                        this._FocusKeyboardSettings(priorElement ? false : true);
                    }
                    // Always do the common focus stuff, instantly returning if we're in an editable iframe.
                    if (this._CommonFocusHelper(Ltarg)) {
                        return true;
                    }
                    ;
                    // Set element directionality (but only if element is empty)
                    if (Ltarg.ownerDocument && Ltarg instanceof Ltarg.ownerDocument.defaultView.HTMLElement) {
                        this.keyman.domManager._SetTargDir(Ltarg);
                    }
                    //Execute external (UI) code needed on focus if required
                    this.doControlFocused(LfocusTarg, DOMEventHandlers.states.lastActiveElement);
                    // Force display of OSK for touch input device, or if a CJK keyboard, to ensure visibility of pick list
                    if (device.touchable) {
                        osk._Enabled = true;
                    }
                    else {
                        // Conditionally show the OSK when control receives the focus
                        if (osk.ready) {
                            if (this.keyman.keyboardManager.isCJK()) {
                                osk._Enabled = true;
                            }
                            if (osk._Enabled) {
                                osk._Show();
                            }
                            else {
                                osk._Hide(false);
                            }
                        }
                    }
                    return true;
                }.bind(this);
                /**
                 * Respond to KMW losing focus on event
                 */
                this._ControlBlur = function (e) {
                    var Ltarg;
                    e = this.keyman._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                    Ltarg = this.keyman.util.eventTarget(e);
                    if (Ltarg == null) {
                        return true;
                    }
                    if (Ltarg['body']) {
                        Ltarg = Ltarg['body']; // Occurs in Firefox for design-mode iframes.
                    }
                    if (DOMEventHandlers.states._IgnoreBlurFocus) {
                        // Prevent triggering other blur-handling events (as possible)
                        e.cancelBubble = true;
                        e.stopPropagation();
                        return true;
                    }
                    // Hide the touch device input caret, if applicable  I3363 (Build 301)
                    if (keyman_2.dom.Utils.instanceof(DOMEventHandlers.states.activeElement, "TouchAliasElement")) {
                        var lastAlias = DOMEventHandlers.states.activeElement;
                        lastAlias.hideCaret();
                    }
                    DOMEventHandlers.states.activeElement = null; // I3363 (Build 301)
                    if (Ltarg.nodeType == 3) { // defeat Safari bug
                        Ltarg = Ltarg.parentNode;
                    }
                    // TODO:  Needs tidy-up.
                    if (Ltarg.ownerDocument) {
                        if (Ltarg instanceof Ltarg.ownerDocument.defaultView.HTMLIFrameElement) {
                            Ltarg = Ltarg.contentWindow.document;
                        }
                    }
                    ////keymanweb._SelectionControl = null;    
                    this._BlurKeyboardSettings();
                    // Now that we've handled all prior-element maintenance, update the 'last active element'.
                    DOMEventHandlers.states.lastActiveElement = Ltarg;
                    /* If the KeymanWeb UI is active as a user changes controls, all UI-based effects should be restrained to this control in case
                    * the user is manually specifying languages on a per-control basis.
                    */
                    this.keyman.uiManager.justActivated = false;
                    var isActivating = this.keyman.uiManager.isActivating;
                    if (!isActivating) {
                        this.keyman['interface'].notifyKeyboard(0, Ltarg, 0); // I2187
                    }
                    //e = this.keyman._GetEventObject<FocusEvent>(e);   // I2404 - Manage IE events in IFRAMEs  //TODO: is this really needed again????
                    this.doControlBlurred(Ltarg, e, isActivating);
                    // Hide the OSK when the control is blurred, unless the UI is being temporarily selected
                    if (this.keyman.osk.ready && !isActivating) {
                        this.keyman.osk._Hide(false);
                    }
                    this.doChangeEvent(Ltarg);
                    this.keyman.interface.resetContext();
                    return true;
                }.bind(this);
                /**
                 * Function   _SelectionChange
                 * Scope      Private
                 * Description Respond to selection change event
                 */
                this._SelectionChange = function () {
                    if (DOMEventHandlers.states._IgnoreNextSelChange) {
                        DOMEventHandlers.states._IgnoreNextSelChange--;
                    }
                    return true;
                }.bind(this);
                /**
                 * Function     _KeyDown
                 * Scope        Private
                 * Description  Processes keydown event and passes data to keyboard.
                 *
                 * Note that the test-case oriented 'recorder' stubs this method to facilitate keystroke
                 * recording for use in test cases.  If changing this function, please ensure the recorder is
                 * not affected.
                 */
                this._KeyDown = function (e) {
                    var activeKeyboard = this.keyman.keyboardManager.activeKeyboard;
                    var osk = this.keyman.osk;
                    var util = this.keyman.util;
                    if (DOMEventHandlers.states._DisableInput || activeKeyboard == null) {
                        return true;
                    }
                    // Prevent mapping element is readonly or tagged as kmw-disabled
                    var el = util.eventTarget(e);
                    if (util.device.touchable) {
                        if (el && typeof el.kmwInput != 'undefined' && el.kmwInput == false) {
                            return true;
                        }
                    }
                    else if (el && el.className.indexOf('kmw-disabled') >= 0) {
                        return true;
                    }
                    // Or if OSK not yet ready (for any reason)
                    if (!osk.ready) {
                        return true;
                    }
                    return this.keyman.textProcessor.keyDown(e);
                }.bind(this);
                /**
                 * Function     _KeyPress
                 * Scope        Private
                 * Description Processes keypress event (does not pass data to keyboard)
                 */
                this._KeyPress = function (e) {
                    if (DOMEventHandlers.states._DisableInput || this.keyman.keyboardManager.activeKeyboard == null) {
                        return true;
                    }
                    return this.keyman.textProcessor.keyPress(e);
                }.bind(this);
                /**
                 * Function     _KeyUp
                 * Scope        Private
                 * Description Processes keyup event and passes event data to keyboard
                 */
                this._KeyUp = function (e) {
                    var keyboardManager = this.keyman.keyboardManager;
                    var processor = this.keyman.textProcessor;
                    var osk = this.keyman.osk;
                    var Levent = processor._GetKeyEventProperties(e, false);
                    if (Levent == null || !osk.ready) {
                        return true;
                    }
                    // Since this part concerns DOM element + browser interaction management, we preprocess it for
                    // browser form commands before passing control to the Processor module.
                    if (Levent.Lcode == 13) {
                        var ignore = false;
                        if (Levent.Ltarg instanceof Levent.Ltarg.ownerDocument.defaultView.HTMLTextAreaElement) {
                            ignore = true;
                        }
                        if (Levent.Ltarg.base && Levent.Ltarg.base instanceof Levent.Ltarg.base.ownerDocument.defaultView.HTMLTextAreaElement) {
                            ignore = true;
                        }
                        if (!ignore) {
                            // For input fields, move to next input element
                            if (Levent.Ltarg instanceof Levent.Ltarg.ownerDocument.defaultView.HTMLInputElement) {
                                var inputEle = Levent.Ltarg;
                                if (inputEle.type == 'search' || inputEle.type == 'submit') {
                                    inputEle.form.submit();
                                }
                                else {
                                    this.keyman.domManager.moveToNext(false);
                                }
                            }
                            return true;
                        }
                    }
                    return processor.keyUp(e);
                }.bind(this);
                this.keyman = keyman;
            }
            /**
             * Function     doControlFocused
             * Scope        Private
             * @param       {Object}            _target         element gaining focus
             * @param       {Object}            _activeControl  currently active control
             * @return      {boolean}
             * Description  Execute external (UI) code needed on focus
             */
            DOMEventHandlers.prototype.doControlFocused = function (_target, _activeControl) {
                var p = {};
                p['target'] = _target;
                p['activeControl'] = _activeControl;
                return this.keyman.util.callEvent('kmw.controlfocused', p);
            };
            /**
             * Function     doControlBlurred
             * Scope        Private
             * @param       {Object}            _target       element losing focus
             * @param       {Event}             _event        event object
             * @param       {(boolean|number)}  _isActivating activation state
             * @return      {boolean}
             * Description  Execute external (UI) code needed on blur
             */
            DOMEventHandlers.prototype.doControlBlurred = function (_target, _event, _isActivating) {
                var p = {};
                p['target'] = _target;
                p['event'] = _event;
                p['isActivating'] = _isActivating;
                return this.keyman.util.callEvent('kmw.controlblurred', p);
            };
            /**
             * Function             _BlurKeyboardSettings
             * Description          Stores the last active element's keyboard settings.  Should be called
             *                      whenever a KMW-enabled page element loses control.
             */
            DOMEventHandlers.prototype._BlurKeyboardSettings = function (PInternalName, PLgCode) {
                var keyboardID = this.keyman.keyboardManager.activeKeyboard ? this.keyman.keyboardManager.activeKeyboard['KI'] : '';
                var langCode = this.keyman.keyboardManager.getActiveLanguage();
                if (PInternalName !== undefined && PLgCode !== undefined) {
                    keyboardID = PInternalName;
                    langCode = PLgCode;
                }
                var lastElem = DOMEventHandlers.states.lastActiveElement;
                if (lastElem && lastElem._kmwAttachment.keyboard != null) {
                    lastElem._kmwAttachment.keyboard = keyboardID;
                    lastElem._kmwAttachment.languageCode = langCode;
                }
                else {
                    this.keyman.globalKeyboard = keyboardID;
                    this.keyman.globalLanguageCode = langCode;
                }
            };
            /**
             * Function             _FocusKeyboardSettings
             * @param   {boolean}   blockGlobalChange   A flag indicating if the global keyboard setting should be ignored for this call.
             * Description          Restores the newly active element's keyboard settings.  Should be called
             *                      whenever a KMW-enabled page element gains control, but only once the prior
             *                      element's loss of control is guaranteed.
             */
            DOMEventHandlers.prototype._FocusKeyboardSettings = function (blockGlobalChange) {
                var lastElem = DOMEventHandlers.states.lastActiveElement;
                if (lastElem && lastElem._kmwAttachment.keyboard != null) {
                    this.keyman.keyboardManager.setActiveKeyboard(lastElem._kmwAttachment.keyboard, lastElem._kmwAttachment.languageCode);
                }
                else if (!blockGlobalChange) {
                    this.keyman.keyboardManager.setActiveKeyboard(this.keyman.globalKeyboard, this.keyman.globalLanguageCode);
                }
                // Now that we've fully entered the new context, invalidate the context so we can generate initial predictions from it.
                if (this.keyman.modelManager) {
                    this.keyman.modelManager.invalidateContext();
                }
            };
            /**
             * Function             _CommonFocusHelper
             * @param   {Element}   target
             * @returns {boolean}
             * Description          Performs common state management for the various focus events of KeymanWeb.
             *                      The return value indicates whether (true) or not (false) the calling event handler
             *                      should be terminated immediately after the call.
             */
            DOMEventHandlers.prototype._CommonFocusHelper = function (target) {
                var uiManager = this.keyman.uiManager;
                //TODO: the logic of the following line doesn't look right!!  Both variables are true, but that doesn't make sense!
                //_Debug(keymanweb._IsIEEditableIframe(Ltarg,1) + '...' +keymanweb._IsMozillaEditableIframe(Ltarg,1));
                if (target.ownerDocument && target instanceof target.ownerDocument.defaultView.HTMLIFrameElement) {
                    if (!this.keyman.domManager._IsIEEditableIframe(target, 1) ||
                        !this.keyman.domManager._IsMozillaEditableIframe(target, 1)) {
                        DOMEventHandlers.states._DisableInput = true;
                        return true;
                    }
                }
                DOMEventHandlers.states._DisableInput = false;
                if (!uiManager.justActivated) {
                    if (target && keyman_2.text.Processor.getOutputTarget(target)) {
                        keyman_2.text.Processor.getOutputTarget(target).deadkeys().clear();
                    }
                    this.keyman['interface'].notifyKeyboard(0, target, 1); // I2187
                }
                if (!uiManager.justActivated && DOMEventHandlers.states._SelectionControl != target) {
                    uiManager.isActivating = false;
                }
                uiManager.justActivated = false;
                DOMEventHandlers.states._SelectionControl = target;
                return false;
            };
            DOMEventHandlers.prototype.doChangeEvent = function (_target) {
                if (DOMEventHandlers.states.changed) {
                    var event;
                    if (typeof Event == 'function') {
                        event = new Event('change', { "bubbles": true, "cancelable": false });
                    }
                    else { // IE path
                        event = document.createEvent("HTMLEvents");
                        event.initEvent('change', true, false);
                    }
                    // Ensure that touch-aliased elements fire as if from the aliased element.
                    if (_target['base'] && _target['base']['kmw_ip']) {
                        _target = _target['base'];
                    }
                    _target.dispatchEvent(event);
                }
                DOMEventHandlers.states.changed = false;
            };
            // This is only static within a given initialization of KeymanWeb.  Perhaps it would be best as an initialization 
            // parameter and member field?
            DOMEventHandlers.states = new CommonDOMStates();
            return DOMEventHandlers;
        }());
        keyman_2.DOMEventHandlers = DOMEventHandlers;
        // -------------------------------------------------------------------------
        /**
         * Defines numerous functions for handling and modeling touch-based aliases.
         */
        var DOMTouchHandlers = /** @class */ (function (_super) {
            __extends(DOMTouchHandlers, _super);
            function DOMTouchHandlers(keyman) {
                var _this = _super.call(this, keyman) || this;
                /**
                 * Handle receiving focus by simulated input field
                 *
                 */
                _this.setFocus = function (e) {
                    DOMEventHandlers.states.setFocusTimer();
                    var tEvent;
                    if (e && keyman_2.dom.Utils.instanceof(e, "TouchEvent")) {
                        tEvent = e.touches[0];
                    }
                    else { // Allow external code to set focus and thus display the OSK on touch devices if required (KMEW-123)
                        tEvent = { clientX: 0, clientY: 0 };
                        // Will usually be called from setActiveElement, which should define DOMEventHandlers.states.lastActiveElement
                        if (DOMEventHandlers.states.lastActiveElement) {
                            tEvent.target = DOMEventHandlers.states.lastActiveElement['kmw_ip'];
                            // but will default to first input or text area on page if DOMEventHandlers.states.lastActiveElement is null
                        }
                        else {
                            tEvent.target = this.keyman.domManager.sortedInputs[0]['kmw_ip'];
                        }
                    }
                    this.setFocusWithTouch(tEvent);
                }.bind(_this);
                /**
                 * Handle losing focus from simulated input field
                 */
                _this.setBlur = function (e) {
                    // This works OK for iOS, but may need something else for other platforms
                    this.keyman.interface.resetContext();
                    if (('relatedTarget' in e) && e.relatedTarget) {
                        var elem = e.relatedTarget;
                        this.doChangeEvent(elem);
                        if (elem.nodeName != 'DIV' || elem.className.indexOf('keymanweb-input') == -1) {
                            this.cancelInput();
                            return;
                        }
                    }
                    //Hide the OSK
                    if (!DOMEventHandlers.states.focusing) {
                        this.cancelInput();
                    }
                }.bind(_this);
                /**
                 * Handle the touch move event for an input element
                 */
                _this.dragInput = function (e) {
                    // Prevent dragging window 
                    e.preventDefault();
                    e.stopPropagation();
                    // Identify the target from the touch list or the event argument (IE 10 only)
                    var target;
                    if (keyman_2.dom.Utils.instanceof(e, "TouchEvent")) {
                        target = e.targetTouches[0].target;
                    }
                    else {
                        target = e.target;
                    }
                    if (target == null) {
                        return;
                    }
                    // Identify the input element from the touch event target (touched element may be contained by input)
                    if (target.className == null || target.className.indexOf('keymanweb-input') < 0)
                        target = target.parentNode;
                    if (target.className == null || target.className.indexOf('keymanweb-input') < 0)
                        target = target.parentNode;
                    if (target.className == null || target.className.indexOf('keymanweb-input') < 0)
                        return;
                    var x, y;
                    if (keyman_2.dom.Utils.instanceof(e, "TouchEvent")) {
                        x = e.touches[0].screenX;
                        y = e.touches[0].screenY;
                    }
                    else {
                        x = e.screenX;
                        y = e.screenY;
                    }
                    // Allow content of input elements to be dragged horizontally or vertically
                    if (typeof this.firstTouch == 'undefined' || this.firstTouch == null) {
                        this.firstTouch = { x: x, y: y };
                    }
                    else {
                        var x0 = this.firstTouch.x, y0 = this.firstTouch.y, scroller = target.firstChild, dx, dy, x1;
                        if (target.base.nodeName == 'TEXTAREA') {
                            var yOffset = parseInt(scroller.style.top, 10);
                            if (isNaN(yOffset))
                                yOffset = 0;
                            dy = y0 - y;
                            if (dy < -4 || dy > 4) {
                                scroller.style.top = (yOffset < dy ? yOffset - dy : 0) + 'px';
                                this.firstTouch.y = y;
                            }
                        }
                        else {
                            var xOffset = parseInt(scroller.style.left, 10);
                            if (isNaN(xOffset))
                                xOffset = 0;
                            dx = x0 - x;
                            if (dx < -4 || dx > 4) {
                                // Limit dragging beyond the defined text (to avoid dragging the text completely out of view)
                                var xMin = 0, xMax = keyman_2.dom.Utils.getAbsoluteX(target) + target.offsetWidth - scroller.offsetWidth - 32;
                                if (target.base.dir == 'rtl')
                                    xMin = 16;
                                else
                                    xMax = xMax - 24;
                                x1 = xOffset - dx;
                                if (x1 > xMin)
                                    x1 = xMin;
                                if (x1 < xMax)
                                    x1 = xMax;
                                scroller.style.left = x1 + 'px';
                                this.firstTouch.x = x;
                            }
                        }
                    }
                    this.setScrollBar(target);
                }.bind(_this);
                return _this;
            }
            DOMTouchHandlers.prototype.setFocusWithTouch = function (tEvent) {
                var osk = this.keyman.osk;
                var touchX = tEvent.clientX, touchY = tEvent.clientY;
                var tTarg = tEvent.target;
                var scroller;
                // Identify the scroller element
                if (tTarg && keyman_2.dom.Utils.instanceof(tTarg, "HTMLSpanElement")) {
                    scroller = tTarg.parentNode;
                }
                else if (tTarg && (tTarg.className != null && tTarg.className.indexOf('keymanweb-input') >= 0)) {
                    scroller = tTarg.firstChild;
                }
                else {
                    scroller = tTarg;
                }
                // And the actual target element        
                var target = scroller.parentNode;
                // Move the caret and refocus if necessary     
                if (DOMEventHandlers.states.activeElement != target) {
                    // Hide the KMW caret
                    var prevTarget = DOMEventHandlers.states.activeElement;
                    if (prevTarget) {
                        prevTarget.hideCaret();
                    }
                    DOMEventHandlers.states.activeElement = target;
                    // The issue here is that touching a DIV does not actually set the focus for iOS, even when enabled to accept focus (by setting tabIndex=0)
                    // We must explicitly set the focus in order to remove focus from any non-KMW input
                    target.focus(); //Android native browsers may not like this, but it is needed for Chrome, Safari
                }
                // Correct element directionality if required
                this.keyman.domManager._SetTargDir(target);
                // What we really want to do is to blur any active element that is not a KMW input, 
                // but the following line does not work as might be expected, even though the correct element is referenced.
                // It is as though blur is ignored if focus is supposed to have been moved, even if it has not in fact been moved?
                //if(document.activeElement.nodeName != 'DIV' && document.activeElement.nodeName != 'BODY') document.activeElement.blur();
                // And display the OSK if not already visible
                if (osk.ready && !osk._Visible) {
                    osk._Show();
                }
                // If clicked on DIV, set caret to end of text
                if (tTarg && keyman_2.dom.Utils.instanceof(tTarg, "TouchAliasElement")) {
                    var x, cp;
                    x = keyman_2.dom.Utils.getAbsoluteX(scroller.firstChild);
                    if (target.dir == 'rtl') {
                        x += scroller.firstChild.offsetWidth;
                        cp = (touchX > x ? 0 : 100000);
                    }
                    else {
                        cp = (touchX < x ? 0 : 100000);
                    }
                    target.setTextCaret(cp);
                    target.scrollInput();
                }
                else { // Otherwise, if clicked on text in SPAN, set at touch position
                    var caret, cp, cpMin, cpMax, x, y, dy, yRow, iLoop;
                    caret = scroller.childNodes[1]; //caret span
                    cpMin = 0;
                    cpMax = target.getText()._kmwLength();
                    cp = target.getTextCaret();
                    dy = document.body.scrollTop;
                    // Vertical scrolling
                    if (target.base instanceof target.base.ownerDocument.defaultView.HTMLTextAreaElement) {
                        yRow = Math.round(target.base.offsetHeight / target.base.rows);
                        for (iLoop = 0; iLoop < 16; iLoop++) {
                            y = keyman_2.dom.Utils.getAbsoluteY(caret) - dy; //top of caret            
                            if (y > touchY && cp > cpMin && cp != cpMax) {
                                cpMax = cp;
                                cp = Math.round((cp + cpMin) / 2);
                            }
                            else if (y < touchY - yRow && cp < cpMax && cp != cpMin) {
                                cpMin = cp;
                                cp = Math.round((cp + cpMax) / 2);
                            }
                            else
                                break;
                            target.setTextCaret(cp);
                        }
                        while (keyman_2.dom.Utils.getAbsoluteY(caret) - dy > touchY && cp > cpMin) {
                            target.setTextCaret(--cp);
                        }
                        while (keyman_2.dom.Utils.getAbsoluteY(caret) - dy < touchY - yRow && cp < cpMax) {
                            target.setTextCaret(++cp);
                        }
                    }
                    // Caret repositioning for horizontal scrolling of RTL text
                    // snapOrder - 'snaps' the touch location in a manner corresponding to the 'ltr' vs 'rtl' orientation.
                    // Think of it as performing a floor() function, but the floor depends on the origin's direction.
                    var snapOrder;
                    if (target.dir == 'rtl') { // I would use arrow functions, but IE doesn't like 'em.
                        snapOrder = function (a, b) {
                            return a < b;
                        };
                    }
                    else {
                        snapOrder = function (a, b) {
                            return a > b;
                        };
                    }
                    for (iLoop = 0; iLoop < 16; iLoop++) {
                        x = keyman_2.dom.Utils.getAbsoluteX(caret); //left of caret            
                        if (snapOrder(x, touchX) && cp > cpMin && cp != cpMax) {
                            cpMax = cp;
                            cp = Math.round((cp + cpMin) / 2);
                        }
                        else if (!snapOrder(x, touchX) && cp < cpMax && cp != cpMin) {
                            cpMin = cp;
                            cp = Math.round((cp + cpMax) / 2);
                        }
                        else {
                            break;
                        }
                        target.setTextCaret(cp);
                    }
                    while (snapOrder(keyman_2.dom.Utils.getAbsoluteX(caret), touchX) && cp > cpMin) {
                        target.setTextCaret(--cp);
                    }
                    while (!snapOrder(keyman_2.dom.Utils.getAbsoluteX(caret), touchX) && cp < cpMax) {
                        target.setTextCaret(++cp);
                    }
                }
                /**
                 * This event will trigger before keymanweb.setBlur is triggered.  Now that we're allowing independent keyboard settings
                 * for controls, we have to act here to preserve the outgoing control's keyboard settings.
                 *
                 * If we 'just activated' the KeymanWeb UI, we need to save the new keyboard change as appropriate.
                 */
                this._BlurKeyboardSettings();
                // With the attachment API update, we now directly track the old legacy control behavior.
                DOMEventHandlers.states.lastActiveElement = target;
                target.showCaret();
                /**
                 * If we 'just activated' the KeymanWeb UI, we need to save the new keyboard change as appropriate.
                 * If not, we need to activate the control's preferred keyboard.
                 */
                this._FocusKeyboardSettings(false);
                // Always do the common focus stuff, instantly returning if we're in an editable iframe.
                // This parallels the if-statement in _ControlFocus - it may be needed as this if-statement in the future,
                // despite its present redundancy.
                if (this._CommonFocusHelper(target)) {
                    return;
                }
            };
            /**
             * Close OSK and remove simulated caret on losing focus
             */
            DOMTouchHandlers.prototype.cancelInput = function () {
                if (DOMEventHandlers.states.activeElement && DOMEventHandlers.states.activeElement.hideCaret) {
                    DOMEventHandlers.states.activeElement.hideCaret();
                }
                DOMEventHandlers.states.activeElement = null;
                this.keyman.osk.hideNow();
            };
            ;
            /**
             * Display and position a scrollbar in the input field if needed
             *
             * @param   {Object}  e   input DIV element (copy of INPUT or TEXTAREA)
             */
            DOMTouchHandlers.prototype.setScrollBar = function (e) {
                // Display the scrollbar if necessary.  Added TEXTAREA condition to correct rotation issue KMW-5.  Fixed for 310 beta.
                var scroller = e.childNodes[0], sbs = e.childNodes[1].style;
                if ((scroller.offsetWidth > e.offsetWidth || scroller.offsetLeft < 0) && (e.base.nodeName != 'TEXTAREA')) {
                    sbs.height = '4px';
                    sbs.width = 100 * (e.offsetWidth / scroller.offsetWidth) + '%';
                    sbs.left = 100 * (-scroller.offsetLeft / scroller.offsetWidth) + '%';
                    sbs.top = '0';
                    sbs.visibility = 'visible';
                }
                else if (scroller.offsetHeight > e.offsetHeight || scroller.offsetTop < 0) {
                    sbs.width = '4px';
                    sbs.height = 100 * (e.offsetHeight / scroller.offsetHeight) + '%';
                    sbs.top = 100 * (-scroller.offsetTop / scroller.offsetHeight) + '%';
                    sbs.left = '0';
                    sbs.visibility = 'visible';
                }
                else {
                    sbs.visibility = 'hidden';
                }
            };
            /**
             * Scroll the document body vertically to bring the active input into view
             *
             * @param       {Object}      e        simulated input field object being focussed
             */
            DOMTouchHandlers.prototype.scrollBody = function (e) {
                var osk = this.keyman.osk;
                var util = this.keyman.util;
                if (!e || e.className == null || e.className.indexOf('keymanweb-input') < 0 || !osk.ready) {
                    return;
                }
                // Get the absolute position of the caret
                var s2 = e.firstChild.childNodes[1], y = keyman_2.dom.Utils.getAbsoluteY(s2), t = window.pageYOffset, dy = 0;
                if (y < t) {
                    dy = y - t;
                }
                else {
                    dy = y - t - (window.innerHeight - osk._Box.offsetHeight - s2.offsetHeight - 2);
                    if (dy < 0)
                        dy = 0;
                }
                // Hide OSK, then scroll, then re-anchor OSK with absolute position (on end of scroll event)
                if (dy != 0) {
                    window.scrollTo(0, dy + window.pageYOffset);
                }
            };
            return DOMTouchHandlers;
        }(DOMEventHandlers));
        keyman_2.DOMTouchHandlers = DOMTouchHandlers;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Ensure that this class contains no reference into core KMW code - it is referenced
// by components intended to be modular and possible to separate from core KMW.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            // Dotted-decimal version
            var Version = /** @class */ (function () {
                /**
                 * Parses version information, preparing it for use in comparisons.
                 * @param text Either a string representing a version number (ex: "9.0.0") or an array representing
                 *             its components (ex: [9, 0, 0]).
                 */
                function Version(text) {
                    // If a keyboard doesn't specify a version, use the DEVELOPER_VERSION_FALLBACK values.
                    if (text === undefined || text === null) {
                        this.components = [].concat(Version.DEVELOPER_VERSION_FALLBACK.components);
                        return;
                    }
                    if (Array.isArray(text)) {
                        var components = text;
                        if (components.length < 2) {
                            throw new Error("Version string must have at least a major and minor component!");
                        }
                        else {
                            this.components = [].concat(components);
                            return;
                        }
                    }
                    // else, standard constructor path.
                    var parts = text.split('.');
                    var componentArray = [];
                    if (parts.length < 2) {
                        throw new Error("Version string must have at least a major and minor component!");
                    }
                    for (var i = 0; i < parts.length; i++) {
                        var value = parseInt(parts[i], 10);
                        if (isNaN(value)) {
                            throw new Error("Version string components must be numerical!");
                        }
                        componentArray.push(value);
                    }
                    this.components = componentArray;
                }
                Object.defineProperty(Version.prototype, "major", {
                    get: function () {
                        return this.components[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Version.prototype, "minor", {
                    get: function () {
                        return this.components[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Version.prototype.toString = function () {
                    return this.components.join('.');
                };
                Version.prototype.equals = function (other) {
                    return this.compareTo(other) == 0;
                };
                Version.prototype.precedes = function (other) {
                    return this.compareTo(other) < 0;
                };
                Version.prototype.compareTo = function (other) {
                    // If the version info depth differs, we need a flag to indicate which instance is shorter.
                    var isShorter = this.components.length < other.components.length;
                    var maxDepth = (this.components.length < other.components.length) ? this.components.length : other.components.length;
                    var i;
                    for (i = 0; i < maxDepth; i++) {
                        var delta = this.components[i] - other.components[i];
                        if (delta != 0) {
                            return delta;
                        }
                    }
                    var longList = isShorter ? other.components : this.components;
                    do {
                        if (longList[i] > 0) {
                            return isShorter ? -1 : 1;
                        }
                        i++;
                    } while (i < longList.length);
                    // Equal.
                    return 0;
                };
                // Represents a default version value for keyboards compiled before this was compiled into keyboards.
                // The exact version is unknown at this point, but the value is "good enough" for what we need.
                Version.DEVELOPER_VERSION_FALLBACK = new Version([9, 0, 0]);
                // For 12.0, the old default behavior of adding missing keycaps to the default layers was removed,
                // as it results in unexpected, bug-like behavior for keyboard designers when it is unwanted.
                Version.NO_DEFAULT_KEYCAPS = new Version([12, 0]);
                Version.MAC_POSSIBLE_IPAD_ALIAS = new Version([10, 15]);
                return Version;
            }());
            utils.Version = Version;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Includes Device definitions, which may play a role in constant logic.
///<reference path="../kmwdevice.ts" />
/*
 * This file is intended for CSS-styling constants that see use with the OSK.
 */
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Defines device-level constants used for CSS styling.
             */
            var StyleConstants = /** @class */ (function () {
                function StyleConstants(device) {
                    // popupCanvasBackgroundColor
                    if (device.OS == 'Android') {
                        this.popupCanvasBackgroundColor = '#999';
                    }
                    else {
                        this.popupCanvasBackgroundColor = device.colorScheme == 'dark' ? '#0f1319' : '#ffffff';
                    }
                }
                return StyleConstants;
            }());
            utils.StyleConstants = StyleConstants;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Includes version-related functionality
///<reference path="utils/version.ts"/>
///<reference path="utils/styleConstants.ts" />
// The Device object definition -------------------------------------------------
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var Device = /** @class */ (function () {
            // Generates a default Device value.
            function Device() {
                this.detected = false;
                this.touchable = !!('ontouchstart' in window);
                this.OS = '';
                this.formFactor = 'desktop';
                this.dyPortrait = 0;
                this.dyLandscape = 0;
                this.version = '0';
                this.orientation = window.orientation;
                this.browser = '';
            }
            /**
             * Get device horizontal DPI for touch devices, to set actual size of active regions
             * Note that the actual physical DPI may be somewhat different.
             *
             * @return      {number}
             */
            Device.prototype.getDPI = function () {
                var t = document.createElement('DIV'), s = t.style, dpi = 96;
                if (document.readyState !== 'complete') {
                    return dpi;
                }
                t.id = 'calculateDPI';
                s.position = 'absolute';
                s.display = 'block';
                s.visibility = 'hidden';
                s.left = '10px';
                s.top = '10px';
                s.width = '1in';
                s.height = '10px';
                document.body.appendChild(t);
                dpi = (typeof window.devicePixelRatio == 'undefined') ? t.offsetWidth : t.offsetWidth * window.devicePixelRatio;
                document.body.removeChild(t);
                return dpi;
            };
            Device.prototype.detect = function () {
                var IEVersion = Device._GetIEVersion();
                var possMacSpoof = false;
                if (navigator && navigator.userAgent) {
                    var agent = navigator.userAgent;
                    if (agent.indexOf('iPad') >= 0) {
                        this.OS = 'iOS';
                        this.formFactor = 'tablet';
                        this.dyPortrait = this.dyLandscape = 0;
                    }
                    else if (agent.indexOf('iPhone') >= 0) {
                        this.OS = 'iOS';
                        this.formFactor = 'phone';
                        this.dyPortrait = this.dyLandscape = 25;
                    }
                    else if (agent.indexOf('Android') >= 0) {
                        this.OS = 'Android';
                        this.formFactor = 'phone'; // form factor may be redefined on initialization
                        this.dyPortrait = 75;
                        this.dyLandscape = 25;
                        try {
                            var rx = new RegExp("(?:Android\\s+)(\\d+\\.\\d+\\.\\d+)");
                            this.version = agent.match(rx)[1];
                        }
                        catch (ex) { }
                    }
                    else if (agent.indexOf('Linux') >= 0) {
                        this.OS = 'Linux';
                    }
                    else if (agent.indexOf('Macintosh') >= 0) {
                        // Starting with 13.1, "Macintosh" can reflect iPads (by default) or iPhones 
                        // (by user setting); a new "Request Desktop Website" setting for Safari will
                        // change the user agent string to match a desktop Mac.
                        //
                        // Firefox uses '.' between version components, while Chrome and Safari use
                        // '_' instead.  So, we have to check for both.  Yay.
                        var regex = /Intel Mac OS X (\d+(?:[_\.]\d+)+)/i;
                        var results = regex.exec(agent);
                        // Match result:  a version string with components separated by underscores.
                        if (!results) {
                            console.warn("KMW could not properly parse the user agent string."
                                + "A suboptimal keyboard layout may result.");
                            this.OS = 'MacOSX';
                        }
                        else if (results.length > 1 && results[1]) {
                            // Convert version string into a usable form.
                            var versionString = results[1].replace('_', '.');
                            var version = new keyman.utils.Version(versionString);
                            possMacSpoof = keyman.utils.Version.MAC_POSSIBLE_IPAD_ALIAS.compareTo(version) <= 0;
                            this.OS = 'MacOSX';
                        }
                    }
                    else if (agent.indexOf('Windows NT') >= 0) {
                        this.OS = 'Windows';
                        if (agent.indexOf('Touch') >= 0) {
                            this.formFactor = 'phone'; // will be redefined as tablet if resolution high enough
                        }
                        // Windows Phone and Tablet PC
                        if (typeof navigator.msMaxTouchPoints == 'number' && navigator.msMaxTouchPoints > 0) {
                            this.touchable = true;
                        }
                    }
                }
                // var sxx=device.formFactor;
                // Check and possibly revise form factor according to actual screen size (adjusted for Galaxy S, maybe OK generally?)
                if (this.formFactor == 'tablet' && Math.min(screen.width, screen.height) < 400) {
                    this.formFactor = 'phone';
                }
                // Trust what iOS tells us for phone vs tablet.
                if (this.formFactor == 'phone' && Math.max(screen.width, screen.height) > 720 && this.OS != 'iOS') {
                    this.formFactor = 'tablet';
                }
                // Test for potential Chrome emulation on Windows or macOS X (used only in next if-check)
                var possibleChromeEmulation = navigator.platform == 'Win32' || navigator.platform == 'MacIntel';
                //                           alert(sxx+'->'+device.formFactor);
                // Check for phony iOS devices (but don't undo for Chrome emulation used during development)
                if (this.OS == 'iOS' && !('ongesturestart' in window) && !possibleChromeEmulation) {
                    this.OS = 'Android';
                }
                // Determine application or browser
                this.browser = 'web';
                if (IEVersion < 999) {
                    this.browser = 'ie';
                }
                else {
                    if (this.OS == 'iOS' || this.OS.toLowerCase() == 'macosx') {
                        this.browser = 'safari';
                    }
                    var bMatch = /Firefox|Chrome|OPR|Safari|Edge/;
                    if (bMatch.test(navigator.userAgent)) {
                        if ((navigator.userAgent.indexOf('Firefox') >= 0) && ('onmozorientationchange' in screen)) {
                            this.browser = 'firefox';
                        }
                        else if (navigator.userAgent.indexOf('OPR') >= 0) {
                            this.browser = 'opera';
                        }
                        else if (navigator.userAgent.indexOf(' Edge/') >= 0) {
                            // Edge is too common a word, so test for Edge/ :)
                            // Must come before Chrome and Safari test because
                            // Edge pretends to be both
                            this.browser = 'edge';
                        }
                        else if (navigator.userAgent.indexOf('Chrome') >= 0) {
                            // This test must come before Safari test because on macOS,
                            // Chrome also reports "Safari"
                            this.browser = 'chrome';
                        }
                        else if (navigator.userAgent.indexOf('Safari') >= 0) {
                            this.browser = 'safari';
                        }
                    }
                }
                if (possMacSpoof && this.browser == 'safari') {
                    // Indistinguishable user agent string!  We need a different test; fortunately, true macOS
                    // Safari doesn't support TouchEvents.  (Chrome does, though!  Hence the filter above.)
                    if (window['TouchEvent']) {
                        this.OS = 'iOS';
                        this.formFactor = 'tablet';
                        this.dyPortrait = this.dyLandscape = 0;
                        // It's currently impossible to differentiate between iPhone and iPad here
                        // except for by screen dimensions.
                        var aspectRatio = screen.height / screen.width;
                        if (aspectRatio < 1) {
                            aspectRatio = 1 / aspectRatio;
                        }
                        // iPhones usually have a ratio of 16:9 (or 1.778) or higher, while iPads use 4:3 (or 1.333)
                        if (aspectRatio > 1.6) {
                            // Override - we'll treat this device as an iPhone.
                            this.formFactor = 'phone';
                            this.dyPortrait = this.dyLandscape = 25;
                        }
                    }
                }
                this.colorScheme = this.prefersDarkMode() ? 'dark' : 'light';
                this.detected = true;
            };
            Device._GetIEVersion = function () {
                var n, agent = '';
                if ('userAgent' in navigator) {
                    agent = navigator.userAgent;
                }
                // Test first for old versions
                if ('selection' in document) { // only defined for IE and not for IE 11!!!       
                    var appVer = navigator.appVersion;
                    n = appVer.indexOf('MSIE ');
                    if (n >= 0) {
                        // Check for quirks mode page, always return 6 if so
                        if (document.compatMode == 'BackCompat') {
                            return 6;
                        }
                        appVer = appVer.substr(n + 5);
                        n = appVer.indexOf('.');
                        if (n > 0) {
                            return parseInt(appVer.substr(0, n), 10);
                        }
                    }
                }
                // Finally test for IE 11 (and later?)
                n = agent.indexOf('Trident/');
                if (n < 0) {
                    return 999;
                }
                agent = agent.substr(n + 8);
                n = agent.indexOf('.');
                if (n > 0) {
                    return parseInt(agent.substr(0, n), 10) + 4;
                }
                return 999;
            };
            /**
             * Checks is a user's browser is in dark mode, if the feature is supported.  Returns false otherwise.
             *
             * Thanks to https://stackoverflow.com/a/57795518 for this code.
             */
            Device.prototype.prefersDarkMode = function () {
                // Ensure the detector exists (otherwise, returns false)
                return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            };
            Object.defineProperty(Device.prototype, "styles", {
                get: function () {
                    if (!this._styles) {
                        if (!this.detected) {
                            this.detect();
                        }
                        this._styles = new keyman.utils.StyleConstants(this);
                    }
                    return this._styles;
                },
                enumerable: true,
                configurable: true
            });
            return Device;
        }());
        keyman.Device = Device;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var dom;
        (function (dom) {
            // Defines DOM-related utility functions that are not reliant on KMW's internal state.
            var Utils = /** @class */ (function () {
                function Utils() {
                }
                /**
                 * Function     getAbsoluteX
                 * Scope        Public
                 * @param       {Object}    Pobj        HTML element
                 * @return      {number}
                 * Description  Returns x-coordinate of Pobj element absolute position with respect to page
                 */
                Utils.getAbsoluteX = function (Pobj) {
                    var Lobj;
                    if (!Pobj) {
                        return 0;
                    }
                    var Lcurleft = Pobj.offsetLeft ? Pobj.offsetLeft : 0;
                    Lobj = Pobj; // I2404 - Support for IFRAMEs
                    if (Lobj.offsetParent) {
                        while (Lobj.offsetParent) {
                            Lobj = Lobj.offsetParent;
                            Lcurleft += Lobj.offsetLeft;
                        }
                        // On mobile devices, the OSK uses 'fixed' - this requires some extra offset work to handle.
                        var Ldoc_1 = Lobj.ownerDocument;
                        if (Lobj.style.position == 'fixed' && Ldoc_1 && Ldoc_1.scrollingElement) {
                            Lcurleft += Ldoc_1.scrollingElement.scrollLeft;
                        }
                    }
                    // Correct position if element is within a frame (but not if the controller is in document within that frame)
                    // We used to reference a KMW state variable `this.keyman._MasterDocument`, but it was only ever set to `window.document`.
                    if (Lobj && Lobj.ownerDocument && (Pobj.ownerDocument != window.document)) {
                        var Ldoc = Lobj.ownerDocument; // I2404 - Support for IFRAMEs
                        if (Ldoc && Ldoc.defaultView && Ldoc.defaultView.frameElement) {
                            return Lcurleft + Utils.getAbsoluteX(Ldoc.defaultView.frameElement) - Ldoc.documentElement.scrollLeft;
                        }
                    }
                    return Lcurleft;
                };
                /**
                 * Function     getAbsoluteY
                 * Scope        Public
                 * @param       {Object}    Pobj        HTML element
                 * @return      {number}
                 * Description  Returns y-coordinate of Pobj element absolute position with respect to page
                 */
                Utils.getAbsoluteY = function (Pobj) {
                    var Lobj;
                    if (!Pobj) {
                        return 0;
                    }
                    var Lcurtop = Pobj.offsetTop ? Pobj.offsetTop : 0;
                    Lobj = Pobj; // I2404 - Support for IFRAMEs
                    if (Lobj.ownerDocument && Lobj instanceof Lobj.ownerDocument.defaultView.HTMLElement) {
                        while (Lobj.offsetParent) {
                            Lobj = Lobj.offsetParent;
                            Lcurtop += Lobj.offsetTop;
                        }
                        // On mobile devices, the OSK uses 'fixed' - this requires some extra offset work to handle.
                        var Ldoc_2 = Lobj.ownerDocument;
                        if (Lobj.style.position == 'fixed' && Ldoc_2 && Ldoc_2.scrollingElement) {
                            Lcurtop += Ldoc_2.scrollingElement.scrollTop;
                        }
                    }
                    // Correct position if element is within a frame (but not if the controller is in document within that frame)
                    // We used to reference a KMW state variable `this.keyman._MasterDocument`, but it was only ever set to `window.document`.
                    if (Lobj && Lobj.ownerDocument && (Pobj.ownerDocument != window.document)) {
                        var Ldoc = Lobj.ownerDocument; // I2404 - Support for IFRAMEs
                        if (Ldoc && Ldoc.defaultView && Ldoc.defaultView.frameElement) {
                            return Lcurtop + Utils.getAbsoluteY(Ldoc.defaultView.frameElement);
                        }
                    }
                    return Lcurtop;
                };
                /**
                 * Checks the type of an input DOM-related object while ensuring that it is checked against the correct prototype,
                 * as class prototypes are (by specification) scoped upon the owning Window.
                 *
                 * See https://stackoverflow.com/questions/43587286/why-does-instanceof-return-false-on-chrome-safari-and-edge-and-true-on-firefox
                 * for more details.
                 *
                 * @param {Element|Event}   Pelem       An element of the web page or one of its IFrame-based subdocuments.
                 * @param {string}          className   The plain-text name of the expected Element type.
                 * @return {boolean}
                 */
                Utils.instanceof = function (Pelem, className) {
                    // We must write special checks for our custom-defined element types!
                    if (className == "TouchAliasElement") {
                        if (this.instanceof(Pelem, "HTMLDivElement")) {
                            var div = Pelem;
                            // We should probably implement a slightly more robust check, but this should get us started well enough.
                            return div['base'] !== undefined;
                        }
                        else {
                            return false;
                        }
                    }
                    var scopedClass;
                    if (!Pelem) {
                        // If we're bothering to check something's type, null references don't match
                        // what we're looking for. 
                        return false;
                    }
                    if (Pelem['Window']) { // Window objects contain the class definitions for types held within them.  So, we can check for those.
                        return className == 'Window';
                    }
                    else if (Pelem['defaultView']) { // Covers Document.
                        scopedClass = Pelem['defaultView'][className];
                    }
                    else if (Pelem['ownerDocument']) {
                        scopedClass = Pelem.ownerDocument.defaultView[className];
                    }
                    else if (Pelem['target']) {
                        var event = Pelem;
                        if (this.instanceof(event.target, 'Window')) {
                            scopedClass = event.target[className];
                        }
                        else if (this.instanceof(event.target, 'Document')) {
                            scopedClass = event.target.defaultView[className];
                        }
                        else if (this.instanceof(event.target, 'HTMLElement')) {
                            scopedClass = event.target.ownerDocument.defaultView[className];
                        }
                    }
                    if (scopedClass) {
                        return Pelem instanceof scopedClass;
                    }
                    else {
                        return false;
                    }
                };
                Utils.forceScroll = function (element) {
                    // Needed to allow ./build_dev_resources.sh to complete;
                    // only executes when com.keyman.DOMEventHandlers is defined.
                    //
                    // We also bypass this whenever operating in the embedded format.
                    if (com && com.keyman && com.keyman['DOMEventHandlers'] && !com.keyman['singleton']['isEmbedded']) {
                        var DOMEventHandlers_1 = com.keyman['DOMEventHandlers'];
                        var selectionStart = element.selectionStart;
                        var selectionEnd = element.selectionEnd;
                        DOMEventHandlers_1.states._IgnoreBlurFocus = true;
                        //Forces scrolling; the re-focus triggers the scroll, at least.
                        element.blur();
                        element.focus();
                        DOMEventHandlers_1.states._IgnoreBlurFocus = false;
                        // On Edge, it appears that the blur/focus combination will reset the caret position
                        // under certain scenarios during unit tests.  So, we re-set it afterward.
                        element.selectionStart = selectionStart;
                        element.selectionEnd = selectionEnd;
                    }
                };
                return Utils;
            }());
            dom.Utils = Utils;
        })(dom = keyman.dom || (keyman.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// References the KMW string extensions.
/// <reference path="../text/kmwstring.ts" />
// References extra HTML definitions not included by default in TS.
/// <reference path="../kmwexthtml.ts" />
// References device-specific code checks (separable module from KMW)
/// <reference path="../kmwdevice.ts" />
// References common DOM utility functions (separate module from KMW)
/// <reference path="utils.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var dom;
        (function (dom) {
            // Many thanks to https://www.typescriptlang.org/docs/handbook/advanced-types.html for this.
            function link(elem, data) {
                var e = elem;
                // Merges all properties and methods of KeyData onto the underlying HTMLDivElement, creating a merged class.
                for (var id in data) {
                    if (!e.hasOwnProperty(id)) {
                        e[id] = data[id];
                    }
                }
                return e;
            }
            function constructTouchAlias(base) {
                var div = document.createElement("div");
                var ele = link(div, new TouchAliasData());
                if (base) {
                    ele.initWithBase(base);
                }
                else {
                    ele.init();
                }
                return ele;
            }
            dom.constructTouchAlias = constructTouchAlias;
            /**
             * The core definition for touch-alias 'subclassing' of HTMLDivElement.
             * It's 'merged' with HTMLDivElement to avoid issues with DOM inheritance and DOM element creation.
             */
            var TouchAliasData = /** @class */ (function () {
                function TouchAliasData() {
                    this['base'] = null; // NOT undefined; we can use this distinction for 'type-checking'.
                    this.__activeCaret = false;
                }
                TouchAliasData.getDevice = function () {
                    if (!TouchAliasData.device) {
                        var device = new com.keyman.Device();
                        device.detect();
                        TouchAliasData.device = device;
                    }
                    return TouchAliasData.device;
                };
                TouchAliasData.getOS = function () {
                    return this.getDevice().OS;
                };
                TouchAliasData.prototype.isMultiline = function () {
                    return this['base'] && this['base'].nodeName == "TEXTAREA";
                };
                TouchAliasData.prototype.initCaret = function () {
                    /**
                     * Create a caret to be appended to the scroller of the focussed input field.
                     * The caret is appended to the scroller so that it will automatically be clipped
                     * when the user manually scrolls it outside the element boundaries.
                     * It is positioned exactly over the hidden span (__caretSpan) that is inserted
                     * between the text spans before and after the insertion point.
                     */
                    this.__caretDiv = document.createElement('DIV');
                    var cs = this.__caretDiv.style;
                    cs.position = 'absolute';
                    cs.height = '16px'; // default height, actual height set from element properties
                    cs.width = '2px';
                    cs.backgroundColor = 'blue';
                    cs.border = 'none';
                    cs.left = cs.top = '0px'; // actual position set relative to parent when displayed
                    cs.display = 'block';
                    cs.visibility = 'hidden';
                    cs.zIndex = '9998'; // immediately below the OSK
                    // Start the caret flash timer
                    this.__caretTimerId = window.setInterval(this.flashCaret.bind(this), 500);
                };
                TouchAliasData.prototype.init = function () {
                    // Remember, this type exists to be merged into HTMLDivElements, so this will work.
                    // We have to trick TS a bit to make it happy, though.
                    var divThis = this;
                    divThis.className = 'keymanweb-input';
                    // Add a scrollable interior div 
                    var d = this.__scrollDiv = document.createElement('div');
                    var xs = divThis.style;
                    xs.overflow = 'hidden';
                    xs.position = 'absolute';
                    //xs.border='1px solid gray';
                    xs.border = 'hidden'; // hide when element empty - KMW-3
                    xs.border = 'none';
                    xs.borderRadius = '5px';
                    // Add a scroll bar (horizontal for INPUT elements, vertical for TEXTAREA elements)
                    var sb = this.__scrollBar = document.createElement('div'), sbs = sb.style;
                    sbs.position = 'absolute';
                    sbs.height = sbs.width = '4px';
                    sbs.left = sbs.top = '0';
                    sbs.display = 'block';
                    sbs.visibility = 'hidden';
                    sbs.backgroundColor = '#808080';
                    sbs.borderRadius = '2px';
                    // And add two spans for the text content before and after the caret, and a caret span
                    this.__preCaret = document.createElement('span');
                    this.__postCaret = document.createElement('span');
                    this.__caretSpan = document.createElement('span');
                    this.__preCaret.innerHTML = this.__postCaret.innerHTML = this.__caretSpan.innerHTML = '';
                    this.__preCaret.className = this.__postCaret.className = this.__caretSpan.className = 'keymanweb-font';
                    d.appendChild(this.__preCaret);
                    d.appendChild(this.__caretSpan);
                    d.appendChild(this.__postCaret);
                    divThis.appendChild(d);
                    divThis.appendChild(sb);
                    var ds = d.style;
                    ds.position = 'absolute';
                    var preCaretStyle = this.__preCaret.style;
                    var postCaretStyle = this.__postCaret.style;
                    var styleCaret = this.__caretSpan.style;
                    preCaretStyle.border = postCaretStyle.border = 'none';
                    //preCaretStyle.backgroundColor='rgb(220,220,255)';
                    //postCaretStyle.backgroundColor='rgb(220,255,220)'; //only for testing 
                    preCaretStyle.height = postCaretStyle.height = '100%';
                    // The invisible caret-positioning span must have a border to ensure that 
                    // it remains in the layout, but colour doesn't matter, as it is never visible.
                    // Span margins are adjusted to compensate for the border and maintain text positioning.  
                    styleCaret.border = '1px solid red';
                    styleCaret.visibility = 'hidden';
                    styleCaret.marginLeft = styleCaret.marginRight = '-1px';
                    // Set the outer element padding *after* appending the element, 
                    // otherwise Firefox misaligns the two elements
                    xs.padding = '8px';
                    // Set internal padding to match the TEXTAREA and INPUT elements
                    ds.padding = '0px 2px'; // OK for iPad, possibly device-dependent
                    // Set the tabindex to 0 to allow a DIV to accept focus and keyboard input 
                    // c.f. http://www.w3.org/WAI/GL/WCAG20/WD-WCAG20-TECHS/SCR29.html
                    divThis.tabIndex = 0;
                    // Disable (internal) pan and zoom on KMW input elements for IE10
                    divThis.style.msTouchAction = 'none';
                    ds.minWidth = xs.width;
                    ds.height = xs.height;
                    this.initCaret();
                };
                TouchAliasData.prototype.initWithBase = function (base) {
                    this['base'] = base;
                    this.init();
                    var divThis = this;
                    // There's quite a bit of setup for touch-alias elements that only occurs if it has an associated base.
                    this['base']['kmw_ip'] = divThis;
                    base.disabled = true;
                    var baseStyle = window.getComputedStyle(base, null);
                    var scrollDivStyle = this.__scrollDiv.style;
                    var preCaretStyle = this.__preCaret.style;
                    var postCaretStyle = this.__postCaret.style;
                    divThis.dir = base.dir;
                    preCaretStyle.fontFamily = postCaretStyle.fontFamily = scrollDivStyle.fontFamily = baseStyle.fontFamily;
                    // Set vertical centering for input elements
                    if (base.nodeName.toLowerCase() == 'input') {
                        if (!isNaN(parseInt(baseStyle.height, 10))) {
                            preCaretStyle.lineHeight = postCaretStyle.lineHeight = baseStyle.height;
                        }
                    }
                    if (TouchAliasData.getOS() == 'Android' && baseStyle.backgroundColor == 'transparent') {
                        scrollDivStyle.backgroundColor = '#fff';
                    }
                    else {
                        scrollDivStyle.backgroundColor = baseStyle.backgroundColor;
                    }
                    if (divThis.base.nodeName.toLowerCase() == 'textarea') {
                        preCaretStyle.whiteSpace = postCaretStyle.whiteSpace = 'pre-wrap'; //scroll vertically
                    }
                    else {
                        preCaretStyle.whiteSpace = postCaretStyle.whiteSpace = 'pre'; //scroll horizontally
                    }
                    divThis.base.parentNode.appendChild(divThis);
                    divThis.updateInput();
                    var style = divThis.style;
                    style.color = baseStyle.color;
                    //style.backgroundColor=bs.backgroundColor; 
                    style.fontFamily = baseStyle.fontFamily;
                    style.fontSize = baseStyle.fontSize;
                    style.fontWeight = baseStyle.fontWeight;
                    style.textDecoration = baseStyle.textDecoration;
                    style.padding = baseStyle.padding;
                    style.margin = baseStyle.margin;
                    style.border = baseStyle.border;
                    style.borderRadius = baseStyle.borderRadius;
                    //xs.color='red';  //use only for checking alignment
                    // Prevent highlighting of underlying element (Android)
                    if ('webkitTapHighlightColor' in style) {
                        style.webkitTapHighlightColor = 'rgba(0,0,0,0)';
                    }
                    if (base instanceof base.ownerDocument.defaultView.HTMLTextAreaElement) {
                        // Correct rows value if defaulted and box height set by CSS
                        // The rows value is used when setting the caret vertically
                        if (base.rows == 2) { // 2 is default value
                            var h = parseInt(baseStyle.height, 10) - parseInt(baseStyle.paddingTop, 10) - parseInt(baseStyle.paddingBottom, 10), dh = parseInt(baseStyle.fontSize, 10), calcRows = Math.round(h / dh);
                            if (calcRows > base.rows + 1) {
                                base.rows = calcRows;
                            }
                        }
                        scrollDivStyle.width = style.width;
                        scrollDivStyle.minHeight = style.height;
                    }
                    else {
                        scrollDivStyle.minWidth = style.width;
                        scrollDivStyle.height = style.height;
                    }
                    base.style.visibility = 'hidden'; // hide by default: KMW-3
                    // Add an explicit event listener to allow the duplicated input element 
                    // to be adjusted for any changes in base element location or size
                    // This will be called for each element after any rotation, as well as after user-initiated changes
                    // It has to be wrapped in an anonymous function to preserve scope and be applied to each element.
                    (function (xx) {
                        xx.__resizeHandler = function () {
                            /* A timeout is needed to let the base element complete its resizing before our
                            * simulated element can properly resize itself.
                            *
                            * Not doing this causes errors if the input elements are resized for whatever reason, such as
                            * changing languages to a text with greater height.
                            */
                            window.setTimeout(function () {
                                xx.updateInput();
                            }, 1);
                        };
                        xx.base.addEventListener('resize', xx.__resizeHandler, false);
                        xx.base.addEventListener('orientationchange', xx.__resizeHandler, false);
                    })(divThis);
                    var textValue;
                    if (base instanceof base.ownerDocument.defaultView.HTMLTextAreaElement
                        || base instanceof base.ownerDocument.defaultView.HTMLInputElement) {
                        textValue = base.value;
                    }
                    else {
                        textValue = base.textContent;
                    }
                    // And copy the text content
                    this.setText(textValue, null);
                };
                TouchAliasData.prototype.setText = function (t, cp) {
                    var tLen = 0;
                    var t1, t2;
                    // Read current text if null passed (for caret positioning)
                    if (t === null) {
                        t1 = this.__preCaret.textContent;
                        t2 = this.__postCaret.textContent;
                        t = t1 + t2;
                    }
                    if (cp < 0) {
                        cp = 0; //if(typeof t._kmwLength == 'undefined') return;
                    }
                    tLen = t._kmwLength();
                    if (cp === null || cp === undefined || cp > tLen) {
                        cp = tLen;
                    }
                    t1 = t._kmwSubstr(0, cp);
                    t2 = t._kmwSubstr(cp);
                    this.__preCaret.textContent = t1;
                    this.__postCaret.textContent = t2;
                    this.updateBaseElement(); // KMW-3, KMW-29
                };
                TouchAliasData.prototype.getTextBeforeCaret = function () {
                    return this.__preCaret.textContent;
                };
                TouchAliasData.prototype.getTextAfterCaret = function () {
                    return this.__postCaret.textContent;
                };
                TouchAliasData.prototype.setTextBeforeCaret = function (t) {
                    var tLen = 0;
                    // Collapse (trailing) whitespace to a single space for INPUT fields (also prevents wrapping)
                    if (!this.isMultiline()) {
                        t = t.replace(/\s+$/, ' ');
                    }
                    this.__preCaret.textContent = t;
                    // Test total length in order to control base element visibility
                    tLen = t.length;
                    tLen = tLen + this.__postCaret.textContent.length;
                    // Update the base element then scroll into view if necessary      
                    this.updateBaseElement(); //KMW-3, KMW-29      
                    this.scrollInput();
                };
                TouchAliasData.prototype.getTextCaret = function () {
                    return this.getTextBeforeCaret()._kmwLength();
                };
                TouchAliasData.prototype.setTextCaret = function (cp) {
                    this.setText(null, cp);
                    this.showCaret();
                };
                /**
                 * Set content, visibility, background and borders of input and base elements (KMW-3,KMW-29)
                 */
                TouchAliasData.prototype.updateBaseElement = function () {
                    var e = this;
                    // Only proceed if we actually have a base element.
                    if (!e['base']) {
                        return;
                    }
                    var Ldv = e.base.ownerDocument.defaultView;
                    if (e.base instanceof Ldv.HTMLInputElement || e.base instanceof Ldv.HTMLTextAreaElement) {
                        e.base.value = this.getText(); //KMW-29
                    }
                    else {
                        e.base.textContent = this.getText();
                    }
                    var n = this.getText()._kmwLength();
                    e.style.backgroundColor = (n == 0 ? 'transparent' : window.getComputedStyle(e.base, null).backgroundColor);
                    if (TouchAliasData.getOS() == 'iOS') {
                        e.base.style.visibility = (n == 0 ? 'visible' : 'hidden');
                    }
                };
                TouchAliasData.prototype.flashCaret = function () {
                    // Significant change - each element manages its own caret, and its activation is managed through show/hideCaret()
                    // without referencing core KMW code.  (KMW must thus check if the active element is a TouchAliasElement, then use these
                    // methods as appropriate.)
                    if (this.__activeCaret) {
                        var cs = this.__caretDiv.style;
                        cs.visibility = cs.visibility != 'visible' ? 'visible' : 'hidden';
                    }
                };
                ;
                /**
                 * Position the caret at the start of the second span within the scroller
                 */
                TouchAliasData.prototype.showCaret = function () {
                    var scroller = this.__scrollDiv, cs = this.__caretDiv.style, sp2 = this.__caretSpan;
                    // Attach the caret to this scroller and position it over the caret span
                    if (this.__caretDiv.parentNode != scroller) {
                        scroller.appendChild(this.__caretDiv);
                    }
                    cs.left = sp2.offsetLeft + 'px';
                    cs.top = sp2.offsetTop + 'px';
                    cs.height = (sp2.offsetHeight - 1) + 'px';
                    cs.visibility = 'hidden'; // best to wait for timer to display caret
                    this.__activeCaret = true;
                    // Scroll into view if required
                    this.scrollBody();
                    // Display and position the scrollbar if necessary
                    this.setScrollBar();
                };
                TouchAliasData.prototype.hideCaret = function () {
                    var e = this;
                    // Always copy text back to underlying field on blur
                    if (e.base instanceof e.base.ownerDocument.defaultView.HTMLTextAreaElement
                        || e.base instanceof e.base.ownerDocument.defaultView.HTMLInputElement) {
                        e.base.value = this.getText();
                    }
                    // And set the scroller caret to the end of the element content (null preserves text)
                    this.setText(null, 100000);
                    // Set the element scroll to zero (or max for RTL INPUT)
                    var ss = this.__scrollDiv.style;
                    if (e.isMultiline()) {
                        ss.top = '0';
                    }
                    else {
                        if (e.base.dir == 'rtl') {
                            ss.left = (e.offsetWidth - this.__scrollDiv.offsetWidth - 8) + 'px';
                        }
                        else {
                            ss.left = '0';
                        }
                    }
                    // And hide the caret and scrollbar       
                    if (this.__caretDiv.parentNode) {
                        this.__caretDiv.parentNode.removeChild(this.__caretDiv);
                    }
                    this.__caretDiv.style.visibility = 'hidden';
                    this.__scrollBar.style.visibility = 'hidden';
                    this.__activeCaret = false;
                };
                TouchAliasData.prototype.getText = function () {
                    return this.textContent;
                };
                TouchAliasData.prototype.updateInput = function () {
                    if (this['base']) {
                        var divThis = this;
                        var xs = divThis.style, b = divThis.base, s = window.getComputedStyle(b, null), mLeft = parseInt(s.marginLeft, 10), mTop = parseInt(s.marginTop, 10), x1 = dom.Utils.getAbsoluteX(b), y1 = dom.Utils.getAbsoluteY(b);
                        var p = divThis.offsetParent;
                        if (p) {
                            x1 = x1 - dom.Utils.getAbsoluteX(p);
                            y1 = y1 - dom.Utils.getAbsoluteY(p);
                        }
                        if (isNaN(mLeft)) {
                            mLeft = 0;
                        }
                        if (isNaN(mTop)) {
                            mTop = 0;
                        }
                        xs.left = (x1 - mLeft) + 'px';
                        xs.top = (y1 - mTop) + 'px';
                        // FireFox does not want the offset!
                        if (typeof (s.MozBoxSizing) != 'undefined') {
                            xs.left = x1 + 'px';
                            xs.top = y1 + 'px';
                        }
                        var w = b.offsetWidth, h = b.offsetHeight, pLeft = parseInt(s.paddingLeft, 10), pRight = parseInt(s.paddingRight, 10), pTop = parseInt(s.paddingTop, 10), pBottom = parseInt(s.paddingBottom, 10), bLeft = parseInt(s.borderLeft, 10), bRight = parseInt(s.borderRight, 10), bTop = parseInt(s.borderTop, 10), bBottom = parseInt(s.borderBottom, 10);
                        // If using content-box model, must subtract the padding and border, 
                        // but *not* for border-box (as for WordPress PlugIn)
                        var boxSizing = 'undefined';
                        if (typeof (s.boxSizing) != 'undefined') {
                            boxSizing = s.boxSizing;
                        }
                        else if (typeof (s.MozBoxSizing) != 'undefined') {
                            boxSizing = s.MozBoxSizing;
                        }
                        if (boxSizing == 'content-box') {
                            if (!isNaN(pLeft))
                                w -= pLeft;
                            if (!isNaN(pRight))
                                w -= pRight;
                            if (!isNaN(bLeft))
                                w -= bLeft;
                            if (!isNaN(bRight))
                                w -= bRight;
                            if (!isNaN(pTop))
                                h -= pTop;
                            if (!isNaN(pBottom))
                                h -= pBottom;
                            if (!isNaN(bTop))
                                h -= bTop;
                            if (!isNaN(bBottom))
                                h -= bBottom;
                        }
                        if (TouchAliasData.getOS() == 'Android') {
                            // FireFox - adjust padding to match input and text area defaults 
                            if (typeof (s.MozBoxSizing) != 'undefined') {
                                xs.paddingTop = (pTop + 1) + 'px';
                                xs.paddingLeft = pLeft + 'px';
                                if (this.isMultiline()) {
                                    xs.marginTop = '1px';
                                }
                                else {
                                    xs.marginLeft = '1px';
                                }
                                w--;
                                h--;
                            }
                            else { // Chrome, Opera, native browser (?)
                                w++;
                                h++;
                            }
                        }
                        xs.width = w + 'px';
                        xs.height = h + 'px';
                    }
                };
                /**
                 * Scroll the input field horizontally (INPUT base element) or
                 * vertically (TEXTAREA base element) to bring the caret into view
                 * as text is entered or deleted form an element
                 */
                TouchAliasData.prototype.scrollInput = function () {
                    var scroller = this.__scrollDiv;
                    var divThis = this;
                    // Get the actual absolute position of the caret and the element 
                    var s2 = this.__caretSpan, cx = dom.Utils.getAbsoluteX(s2), cy = dom.Utils.getAbsoluteY(s2), ex = dom.Utils.getAbsoluteX(divThis), ey = dom.Utils.getAbsoluteY(divThis), x = parseInt(scroller.style.left, 10), y = parseInt(scroller.style.top, 10), dx = 0, dy = 0;
                    // Scroller offsets must default to zero
                    if (isNaN(x))
                        x = 0;
                    if (isNaN(y))
                        y = 0;
                    // Scroll input field vertically if necessary
                    if (divThis.isMultiline()) {
                        var rowHeight = Math.round(divThis.offsetHeight / divThis.base.rows);
                        if (cy < ey) {
                            dy = cy - ey;
                        }
                        if (cy > ey + divThis.offsetHeight - rowHeight) {
                            dy = cy - ey - divThis.offsetHeight + rowHeight;
                        }
                        if (dy != 0) {
                            scroller.style.top = (y < dy ? y - dy : 0) + 'px';
                        }
                    }
                    else { // or scroll horizontally if needed
                        if (cx < ex + 8) {
                            dx = cx - ex - 12;
                        }
                        if (cx > ex + divThis.offsetWidth - 12) {
                            dx = cx - ex - divThis.offsetWidth + 12;
                        }
                        if (dx != 0) {
                            scroller.style.left = (x < dx ? x - dx : 0) + 'px';
                        }
                    }
                    // Display the caret (and scroll into view if necessary)
                    this.showCaret();
                };
                /**
                 * Scroll the document body vertically to bring the active input into view
                 */
                TouchAliasData.prototype.scrollBody = function () {
                    // Note the deliberate lack of typing; we don't want to include KMW's core in isolated
                    // element interface testing, so we can't use it here.
                    var oskHeight = 0;
                    if (window['keyman']) {
                        var osk = window['keyman'].osk;
                        if (osk && osk._Box) {
                            oskHeight = osk._Box.offsetHeight;
                        }
                    }
                    // Get the absolute position of the caret
                    var s2 = this.__caretSpan, y = dom.Utils.getAbsoluteY(s2), t = window.pageYOffset, dy = 0;
                    if (y < t) {
                        dy = y - t;
                    }
                    else {
                        dy = y - t - (window.innerHeight - oskHeight - s2.offsetHeight - 2);
                        if (dy < 0) {
                            dy = 0;
                        }
                    }
                    // Hide OSK, then scroll, then re-anchor OSK with absolute position (on end of scroll event)
                    if (dy != 0) {
                        window.scrollTo(0, dy + window.pageYOffset);
                    }
                };
                /**
                 * Display and position a scrollbar in the input field if needed
                 */
                TouchAliasData.prototype.setScrollBar = function () {
                    var e = this;
                    // Display the scrollbar if necessary.  Added TEXTAREA condition to correct rotation issue KMW-5.  Fixed for 310 beta.
                    var scroller = this.__scrollDiv, sbs = this.__scrollBar.style;
                    if ((scroller.offsetWidth > e.offsetWidth || scroller.offsetLeft < 0) && !e.isMultiline()) {
                        sbs.height = '4px';
                        sbs.width = 100 * (e.offsetWidth / scroller.offsetWidth) + '%';
                        sbs.left = 100 * (-scroller.offsetLeft / scroller.offsetWidth) + '%';
                        sbs.top = '0';
                        sbs.visibility = 'visible';
                    }
                    else if (scroller.offsetHeight > e.offsetHeight || scroller.offsetTop < 0) {
                        sbs.width = '4px';
                        sbs.height = 100 * (e.offsetHeight / scroller.offsetHeight) + '%';
                        sbs.top = 100 * (-scroller.offsetTop / scroller.offsetHeight) + '%';
                        sbs.left = '0';
                        sbs.visibility = 'visible';
                    }
                    else {
                        sbs.visibility = 'hidden';
                    }
                };
                return TouchAliasData;
            }());
        })(dom = keyman.dom || (keyman.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="../text/outputTarget.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var dom;
        (function (dom) {
            var Input = /** @class */ (function (_super) {
                __extends(Input, _super);
                function Input(ele) {
                    var _this = _super.call(this) || this;
                    _this.root = ele;
                    _this._cachedSelectionStart = -1;
                    return _this;
                }
                Input.prototype.getElement = function () {
                    return this.root;
                };
                Input.prototype.clearSelection = function () {
                    // Processes our codepoint-based variants of selectionStart and selectionEnd.
                    var caret = this.getCaret();
                    this.root.value = this.root.value._kmwSubstring(0, caret) + this.root.value._kmwSubstring(this.processedSelectionEnd); //I3319
                    this.setCaret(caret);
                };
                Input.prototype.hasSelection = function () {
                    return true;
                };
                Input.prototype.invalidateSelection = function () {
                    // Since .selectionStart will never return this value, we use it to indicate
                    // the need to refresh our processed indices.
                    this._cachedSelectionStart = -1;
                };
                Input.prototype.getCaret = function () {
                    if (this.root.selectionStart == this._cachedSelectionStart) {
                        return this.processedSelectionStart;
                    }
                    else {
                        this._cachedSelectionStart = this.root.selectionStart; // KMW-1
                        this.processedSelectionStart = this.root.value._kmwCodeUnitToCodePoint(this.root.selectionStart); // I3319
                        this.processedSelectionEnd = this.root.value._kmwCodeUnitToCodePoint(this.root.selectionEnd); // I3319
                        return this.processedSelectionStart;
                    }
                };
                Input.prototype.getDeadkeyCaret = function () {
                    return this.getCaret();
                };
                Input.prototype.setCaret = function (caret) {
                    this.setSelection(caret, caret);
                };
                Input.prototype.setSelection = function (start, end) {
                    var domStart = this.root.value._kmwCodePointToCodeUnit(start);
                    var domEnd = this.root.value._kmwCodePointToCodeUnit(end);
                    this.root.setSelectionRange(domStart, domEnd);
                    this.processedSelectionStart = start;
                    this.processedSelectionEnd = end;
                    dom.Utils.forceScroll(this.root);
                };
                Input.prototype.getTextBeforeCaret = function () {
                    return this.getText()._kmwSubstring(0, this.getCaret());
                };
                Input.prototype.setTextBeforeCaret = function (text) {
                    this.getCaret();
                    var newCaret = text._kmwLength();
                    this.root.value = text + this.getText()._kmwSubstring(this.processedSelectionStart);
                    this.setCaret(newCaret);
                };
                Input.prototype.setTextAfterCaret = function (s) {
                    var c = this.getCaret();
                    this.root.value = this.getTextBeforeCaret() + s;
                    this.setCaret(c);
                };
                Input.prototype.getTextAfterCaret = function () {
                    this.getCaret();
                    return this.getText()._kmwSubstring(this.processedSelectionEnd);
                };
                Input.prototype.getText = function () {
                    return this.root.value;
                };
                Input.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (dn > 0) {
                        var curText = this.getTextBeforeCaret();
                        var caret = this.getCaret();
                        if (dn > caret) {
                            dn = caret;
                        }
                        this.adjustDeadkeys(-dn);
                        this.setTextBeforeCaret(curText.kmwSubstring(0, this.getCaret() - dn));
                        this.setCaret(caret - dn);
                    }
                };
                Input.prototype.insertTextBeforeCaret = function (s) {
                    if (!s) {
                        return;
                    }
                    var caret = this.getCaret();
                    var front = this.getTextBeforeCaret();
                    var back = this.getText()._kmwSubstring(this.processedSelectionStart);
                    this.adjustDeadkeys(s._kmwLength());
                    this.root.value = front + s + back;
                    this.setCaret(caret + s._kmwLength());
                };
                return Input;
            }(keyman.text.OutputTarget));
            dom.Input = Input;
        })(dom = keyman.dom || (keyman.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var dom;
        (function (dom) {
            var TextArea = /** @class */ (function (_super) {
                __extends(TextArea, _super);
                function TextArea(ele) {
                    var _this = _super.call(this) || this;
                    _this.root = ele;
                    _this._cachedSelectionStart = -1;
                    return _this;
                }
                TextArea.prototype.getElement = function () {
                    return this.root;
                };
                TextArea.prototype.clearSelection = function () {
                    // Processes our codepoint-based variants of selectionStart and selectionEnd.
                    var caret = this.getCaret();
                    this.root.value = this.root.value._kmwSubstring(0, caret) + this.root.value._kmwSubstring(this.processedSelectionEnd); //I3319
                    this.setCaret(caret);
                };
                TextArea.prototype.hasSelection = function () {
                    return true;
                };
                TextArea.prototype.invalidateSelection = function () {
                    // Since .selectionStart will never return this value, we use it to indicate
                    // the need to refresh our processed indices.
                    this._cachedSelectionStart = -1;
                };
                TextArea.prototype.getCaret = function () {
                    if (this.root.selectionStart == this._cachedSelectionStart) {
                        return this.processedSelectionStart;
                    }
                    else {
                        this._cachedSelectionStart = this.root.selectionStart; // KMW-1
                        this.processedSelectionStart = this.root.value._kmwCodeUnitToCodePoint(this.root.selectionStart); // I3319
                        this.processedSelectionEnd = this.root.value._kmwCodeUnitToCodePoint(this.root.selectionEnd); // I3319
                        return this.processedSelectionStart;
                    }
                };
                TextArea.prototype.getDeadkeyCaret = function () {
                    return this.getCaret();
                };
                TextArea.prototype.setCaret = function (caret) {
                    this.setSelection(caret, caret);
                };
                TextArea.prototype.setSelection = function (start, end) {
                    var domStart = this.root.value._kmwCodePointToCodeUnit(start);
                    var domEnd = this.root.value._kmwCodePointToCodeUnit(end);
                    this.root.setSelectionRange(domStart, domEnd);
                    this.processedSelectionStart = start;
                    this.processedSelectionEnd = end;
                    dom.Utils.forceScroll(this.root);
                };
                TextArea.prototype.getTextBeforeCaret = function () {
                    return this.getText()._kmwSubstring(0, this.getCaret());
                };
                TextArea.prototype.setTextBeforeCaret = function (text) {
                    this.getCaret();
                    var newCaret = text._kmwLength();
                    this.root.value = text + this.getText()._kmwSubstring(this.processedSelectionStart);
                    this.setCaret(newCaret);
                };
                TextArea.prototype.setTextAfterCaret = function (s) {
                    var c = this.getCaret();
                    this.root.value = this.getTextBeforeCaret() + s;
                    this.setCaret(c);
                };
                TextArea.prototype.getTextAfterCaret = function () {
                    this.getCaret();
                    return this.getText()._kmwSubstring(this.processedSelectionEnd);
                };
                TextArea.prototype.getText = function () {
                    return this.root.value;
                };
                TextArea.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (dn > 0) {
                        var curText = this.getTextBeforeCaret();
                        var caret = this.getCaret();
                        if (dn > caret) {
                            dn = caret;
                        }
                        this.adjustDeadkeys(-dn);
                        this.setTextBeforeCaret(curText.kmwSubstring(0, this.getCaret() - dn));
                        this.setCaret(caret - dn);
                    }
                };
                TextArea.prototype.insertTextBeforeCaret = function (s) {
                    if (!s) {
                        return;
                    }
                    var caret = this.getCaret();
                    var front = this.getTextBeforeCaret();
                    var back = this.getText()._kmwSubstring(this.processedSelectionStart);
                    this.adjustDeadkeys(s._kmwLength());
                    this.root.value = front + s + back;
                    this.setCaret(caret + s._kmwLength());
                };
                return TextArea;
            }(keyman.text.OutputTarget));
            dom.TextArea = TextArea;
        })(dom = keyman.dom || (keyman.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var dom;
        (function (dom) {
            var SelectionCaret = /** @class */ (function () {
                function SelectionCaret(node, offset) {
                    this.node = node;
                    this.offset = offset;
                }
                return SelectionCaret;
            }());
            var SelectionRange = /** @class */ (function () {
                function SelectionRange(start, end) {
                    this.start = start;
                    this.end = end;
                }
                return SelectionRange;
            }());
            var ContentEditable = /** @class */ (function (_super) {
                __extends(ContentEditable, _super);
                function ContentEditable(ele) {
                    var _this = this;
                    if (ele.isContentEditable) {
                        _this = _super.call(this) || this;
                        _this.root = ele;
                    }
                    else {
                        throw "Specified element is not already content-editable!";
                    }
                    return _this;
                }
                ContentEditable.prototype.getElement = function () {
                    return this.root;
                };
                ContentEditable.prototype.hasSelection = function () {
                    var Lsel = this.root.ownerDocument.getSelection();
                    // We can't completely rely on this.root.contains because of a weird IE 11 bug.
                    // Apparently, the text node contains the HTMLElement?
                    var ie11ParentChild = function (parent, child) {
                        // It's explicitly a text node bug.
                        if (child.nodeType != 3) {
                            return null;
                        }
                        var code = child.compareDocumentPosition(parent);
                        return (code & 8) != 0; // Yep.  Text node contains its root.
                    };
                    if (this.root != Lsel.anchorNode && !this.root.contains(Lsel.anchorNode) && !ie11ParentChild(this.root, Lsel.anchorNode)) {
                        return false;
                    }
                    if (this.root != Lsel.focusNode && !this.root.contains(Lsel.focusNode) && !ie11ParentChild(this.root, Lsel.anchorNode)) {
                        return false;
                    }
                    return true;
                };
                ContentEditable.prototype.clearSelection = function () {
                    if (this.hasSelection()) {
                        var Lsel = this.root.ownerDocument.getSelection();
                        if (!Lsel.isCollapsed) {
                            Lsel.deleteFromDocument(); // I2134, I2192
                        }
                    }
                    else {
                        console.warn("Attempted to clear an unowned Selection!");
                    }
                };
                ContentEditable.prototype.invalidateSelection = function () {
                };
                ContentEditable.prototype.getCarets = function () {
                    var Lsel = this.root.ownerDocument.getSelection();
                    var code = Lsel.anchorNode.compareDocumentPosition(Lsel.focusNode);
                    if (Lsel.isCollapsed) {
                        var caret = new SelectionCaret(Lsel.anchorNode, Lsel.anchorOffset);
                        return new SelectionRange(caret, caret);
                    }
                    else {
                        var anchor = new SelectionCaret(Lsel.anchorNode, Lsel.anchorOffset);
                        var focus_1 = new SelectionCaret(Lsel.focusNode, Lsel.focusOffset);
                        if (anchor.node == focus_1.node) {
                            code = (focus_1.offset - anchor.offset > 0) ? 2 : 4;
                        }
                        if (code & 2) {
                            return new SelectionRange(anchor, focus_1);
                        }
                        else { // Default
                            // can test against code & 4 to ensure Focus is before anchor, though.
                            return new SelectionRange(focus_1, anchor);
                        }
                    }
                };
                ContentEditable.prototype.getDeadkeyCaret = function () {
                    return this.getTextBeforeCaret().kmwLength();
                };
                ContentEditable.prototype.getTextBeforeCaret = function () {
                    if (!this.hasSelection()) {
                        return;
                    }
                    var caret = this.getCarets().start;
                    if (caret.node.nodeType != 3) {
                        return ''; // Must be a text node to provide a context.
                    }
                    return caret.node.textContent.substr(0, caret.offset);
                };
                ContentEditable.prototype.getTextAfterCaret = function () {
                    if (!this.hasSelection()) {
                        return;
                    }
                    var caret = this.getCarets().end;
                    if (caret.node.nodeType != 3) {
                        return ''; // Must be a text node to provide a context.
                    }
                    return caret.node.textContent.substr(caret.offset);
                };
                ContentEditable.prototype.getText = function () {
                    return this.root.innerText;
                };
                ContentEditable.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (!this.hasSelection() || dn <= 0) {
                        return;
                    }
                    var start = this.getCarets().start;
                    // Bounds-check on the number of chars to delete.
                    if (dn > start.offset) {
                        dn = start.offset;
                    }
                    if (start.node.nodeType != 3) {
                        console.warn("Deletion of characters requested without available context!");
                        return; // No context to delete characters from.
                    }
                    var range = this.root.ownerDocument.createRange();
                    var dnOffset = start.offset - start.node.nodeValue.substr(0, start.offset)._kmwSubstr(-dn).length;
                    range.setStart(start.node, dnOffset);
                    range.setEnd(start.node, start.offset);
                    this.adjustDeadkeys(-dn);
                    range.deleteContents();
                    // No need to reposition the caret - the DOM will auto-move the selection accordingly, since
                    // we didn't use the selection to delete anything.
                };
                ContentEditable.prototype.insertTextBeforeCaret = function (s) {
                    if (!this.hasSelection()) {
                        return;
                    }
                    var start = this.getCarets().start;
                    var delta = s._kmwLength();
                    var Lsel = this.root.ownerDocument.getSelection();
                    if (delta == 0) {
                        return;
                    }
                    this.adjustDeadkeys(delta);
                    // While Selection.extend() is really nice for this, IE doesn't support it whatsoever.
                    // However, IE (11, at least) DOES support setting selections via ranges, so we can still
                    // manage the caret properly.
                    var finalCaret = this.root.ownerDocument.createRange();
                    if (start.node.nodeType == 3) {
                        var textStart = start.node;
                        textStart.insertData(start.offset, s);
                        finalCaret.setStart(textStart, start.offset + s.length);
                    }
                    else {
                        // Create a new text node - empty control
                        var n = start.node.ownerDocument.createTextNode(s);
                        var range = this.root.ownerDocument.createRange();
                        range.setStart(start.node, start.offset);
                        range.collapse(true);
                        range.insertNode(n);
                        finalCaret.setStart(n, s.length);
                    }
                    finalCaret.collapse(true);
                    Lsel.removeAllRanges();
                    try {
                        Lsel.addRange(finalCaret);
                    }
                    catch (e) {
                        // Chrome (through 4.0 at least) throws an exception because it has not synchronised its content with the selection.
                        // scrollIntoView synchronises the content for selection
                        start.node.parentElement.scrollIntoView();
                        Lsel.addRange(finalCaret);
                    }
                    Lsel.collapseToEnd();
                };
                ContentEditable.prototype.setTextAfterCaret = function (s) {
                    if (!this.hasSelection()) {
                        return;
                    }
                    var caret = this.getCarets().end;
                    var delta = s._kmwLength();
                    var Lsel = this.root.ownerDocument.getSelection();
                    if (delta == 0) {
                        return;
                    }
                    // This is designed explicitly for use in direct-setting operations; deadkeys
                    // will be handled after this method.
                    if (caret.node.nodeType == 3) {
                        var textStart = caret.node;
                        textStart.replaceData(caret.offset, textStart.length, s);
                    }
                    else {
                        // Create a new text node - empty control
                        var n = caret.node.ownerDocument.createTextNode(s);
                        var range = this.root.ownerDocument.createRange();
                        range.setStart(caret.node, caret.offset);
                        range.collapse(true);
                        range.insertNode(n);
                    }
                };
                return ContentEditable;
            }(keyman.text.OutputTarget));
            dom.ContentEditable = ContentEditable;
        })(dom = keyman.dom || (keyman.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var dom;
        (function (dom) {
            var SelectionCaret = /** @class */ (function () {
                function SelectionCaret(node, offset) {
                    this.node = node;
                    this.offset = offset;
                }
                return SelectionCaret;
            }());
            var SelectionRange = /** @class */ (function () {
                function SelectionRange(start, end) {
                    this.start = start;
                    this.end = end;
                }
                return SelectionRange;
            }());
            var StyleCommand = /** @class */ (function () {
                function StyleCommand(c, s) {
                    this.cmd = c;
                    this.stateType = s;
                }
                return StyleCommand;
            }());
            var DesignIFrame = /** @class */ (function (_super) {
                __extends(DesignIFrame, _super);
                function DesignIFrame(ele) {
                    var _this = _super.call(this) || this;
                    _this.root = ele;
                    if (ele.contentWindow && ele.contentWindow.document && ele.contentWindow.document.designMode == 'on') {
                        _this.doc = ele.contentWindow.document;
                        _this.docRoot = ele.contentWindow.document.documentElement;
                    }
                    else {
                        throw "Specified IFrame is not in design-mode!";
                    }
                    return _this;
                }
                DesignIFrame.prototype.getElement = function () {
                    return this.root;
                };
                DesignIFrame.prototype.hasSelection = function () {
                    var Lsel = this.doc.getSelection();
                    var outerSel = document.getSelection();
                    // If the outer doc's selection matches, we're active.
                    if (outerSel.anchorNode == Lsel.anchorNode && outerSel.focusNode == Lsel.focusNode) {
                        return true;
                    }
                    else {
                        // Problem:  for testing, we can't enforce the ideal (ie: first) condition.
                        // Technically, the IFrame _will_ always have its own internal selection, though... so... it kinda works?
                        return true;
                    }
                };
                DesignIFrame.prototype.clearSelection = function () {
                    if (this.hasSelection()) {
                        var Lsel = this.doc.getSelection();
                        if (!Lsel.isCollapsed) {
                            Lsel.deleteFromDocument(); // I2134, I2192
                        }
                    }
                    else {
                        console.warn("Attempted to clear an unowned Selection!");
                    }
                };
                DesignIFrame.prototype.invalidateSelection = function () {
                };
                DesignIFrame.prototype.getCarets = function () {
                    var Lsel = this.doc.getSelection();
                    var code = Lsel.anchorNode.compareDocumentPosition(Lsel.focusNode);
                    if (Lsel.isCollapsed) {
                        var caret = new SelectionCaret(Lsel.anchorNode, Lsel.anchorOffset);
                        return new SelectionRange(caret, caret);
                    }
                    else {
                        var anchor = new SelectionCaret(Lsel.anchorNode, Lsel.anchorOffset);
                        var focus_2 = new SelectionCaret(Lsel.focusNode, Lsel.focusOffset);
                        if (anchor.node == focus_2.node) {
                            code = (focus_2.offset - anchor.offset > 0) ? 2 : 4;
                        }
                        if (code & 2) {
                            return new SelectionRange(anchor, focus_2);
                        }
                        else { // Default
                            // can test against code & 4 to ensure Focus is before anchor, though.
                            return new SelectionRange(focus_2, anchor);
                        }
                    }
                };
                DesignIFrame.prototype.getDeadkeyCaret = function () {
                    return this.getTextBeforeCaret().kmwLength();
                };
                DesignIFrame.prototype.getTextBeforeCaret = function () {
                    if (!this.hasSelection()) {
                        return;
                    }
                    var caret = this.getCarets().start;
                    if (caret.node.nodeType != 3) {
                        return ''; // Must be a text node to provide a context.
                    }
                    return caret.node.textContent.substr(0, caret.offset);
                };
                DesignIFrame.prototype.getTextAfterCaret = function () {
                    if (!this.hasSelection()) {
                        return;
                    }
                    var caret = this.getCarets().end;
                    if (caret.node.nodeType != 3) {
                        return ''; // Must be a text node to provide a context.
                    }
                    return caret.node.textContent.substr(caret.offset);
                };
                DesignIFrame.prototype.getText = function () {
                    return this.docRoot.innerText;
                };
                DesignIFrame.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (!this.hasSelection() || dn <= 0) {
                        return;
                    }
                    var start = this.getCarets().start;
                    // Bounds-check on the number of chars to delete.
                    if (dn > start.offset) {
                        dn = start.offset;
                    }
                    if (start.node.nodeType != 3) {
                        console.warn("Deletion of characters requested without available context!");
                        return; // No context to delete characters from.
                    }
                    var range = this.doc.createRange();
                    var dnOffset = start.offset - start.node.nodeValue.substr(0, start.offset)._kmwSubstr(-dn).length;
                    range.setStart(start.node, dnOffset);
                    range.setEnd(start.node, start.offset);
                    this.adjustDeadkeys(-dn);
                    range.deleteContents();
                    // No need to reposition the caret - the DOM will auto-move the selection accordingly, since
                    // we didn't use the selection to delete anything.
                };
                DesignIFrame.prototype.insertTextBeforeCaret = function (s) {
                    if (!this.hasSelection()) {
                        return;
                    }
                    var start = this.getCarets().start;
                    var delta = s._kmwLength();
                    var Lsel = this.doc.getSelection();
                    if (delta == 0) {
                        return;
                    }
                    this.adjustDeadkeys(delta);
                    // While Selection.extend() is really nice for this, IE doesn't support it whatsoever.
                    // However, IE (11, at least) DOES support setting selections via ranges, so we can still
                    // manage the caret properly.
                    var finalCaret = this.root.ownerDocument.createRange();
                    if (start.node.nodeType == 3) {
                        var textStart = start.node;
                        textStart.insertData(start.offset, s);
                        finalCaret.setStart(textStart, start.offset + s.length);
                    }
                    else {
                        // Create a new text node - empty control
                        var n = this.doc.createTextNode(s);
                        var range = this.doc.createRange();
                        range.setStart(start.node, start.offset);
                        range.collapse(true);
                        range.insertNode(n);
                        finalCaret.setStart(n, s.length);
                    }
                    finalCaret.collapse(true);
                    Lsel.removeAllRanges();
                    try {
                        Lsel.addRange(finalCaret);
                    }
                    catch (e) {
                        // Chrome (through 4.0 at least) throws an exception because it has not synchronised its content with the selection.
                        // scrollIntoView synchronises the content for selection
                        start.node.parentElement.scrollIntoView();
                        Lsel.addRange(finalCaret);
                    }
                    Lsel.collapseToEnd();
                };
                DesignIFrame.prototype.setTextAfterCaret = function (s) {
                    if (!this.hasSelection()) {
                        return;
                    }
                    var caret = this.getCarets().end;
                    var delta = s._kmwLength();
                    var Lsel = this.doc.getSelection();
                    if (delta == 0) {
                        return;
                    }
                    // This is designed explicitly for use in direct-setting operations; deadkeys
                    // will be handled after this method.
                    if (caret.node.nodeType == 3) {
                        var textStart = caret.node;
                        textStart.replaceData(caret.offset, textStart.length, s);
                    }
                    else {
                        // Create a new text node - empty control
                        var n = caret.node.ownerDocument.createTextNode(s);
                        var range = this.root.ownerDocument.createRange();
                        range.setStart(caret.node, caret.offset);
                        range.collapse(true);
                        range.insertNode(n);
                    }
                };
                /**
                 * Function     saveProperties
                 * Scope        Private
                 * Description  Build and create list of styles that can be applied in iframes
                 */
                DesignIFrame.prototype.saveProperties = function () {
                    // Formerly _CacheCommands.
                    var _CacheableCommands = [
                        new StyleCommand('backcolor', 1), new StyleCommand('fontname', 1), new StyleCommand('fontsize', 1),
                        new StyleCommand('forecolor', 1), new StyleCommand('bold', 0), new StyleCommand('italic', 0),
                        new StyleCommand('strikethrough', 0), new StyleCommand('subscript', 0),
                        new StyleCommand('superscript', 0), new StyleCommand('underline', 0)
                    ];
                    if (this.doc.defaultView) {
                        _CacheableCommands.push(new StyleCommand('hilitecolor', 1));
                    }
                    for (var n = 0; n < _CacheableCommands.length; n++) { // I1511 - array prototype extended
                        var cmd = _CacheableCommands[n];
                        //KeymanWeb._Debug('Command:'+_CacheableCommands[n][0]);
                        if (cmd.stateType == 1) {
                            cmd.cache = this.doc.queryCommandValue(cmd.cmd);
                        }
                        else {
                            cmd.cache = this.doc.queryCommandState(cmd.cmd);
                        }
                    }
                    this.commandCache = _CacheableCommands;
                };
                /**
                 * Function     restoreProperties
                 * Scope        Private
                 * Description  Restore styles in IFRAMEs (??)
                 */
                DesignIFrame.prototype.restoreProperties = function (_func) {
                    // Formerly _CacheCommandsReset.
                    if (!this.commandCache) {
                        console.error("No command cache exists to restore!");
                    }
                    for (var n = 0; n < this.commandCache.length; n++) { // I1511 - array prototype extended
                        var cmd = this.commandCache[n];
                        //KeymanWeb._Debug('ResetCacheCommand:'+_CacheableCommands[n][0]+'='+_CacheableCommands[n][2]);
                        if (cmd.stateType == 1) {
                            if (this.doc.queryCommandValue(cmd.cmd) != cmd.cache) {
                                if (_func) {
                                    _func();
                                }
                                this.doc.execCommand(cmd.cmd, false, cmd.cache);
                            }
                        }
                        else if (this.doc.queryCommandState(cmd.cmd) != cmd.cache) {
                            if (_func) {
                                _func();
                            }
                            //KeymanWeb._Debug('executing command '+_CacheableCommand[n][0]);
                            this.doc.execCommand(cmd.cmd, false, null);
                        }
                    }
                };
                return DesignIFrame;
            }(keyman.text.OutputTarget));
            dom.DesignIFrame = DesignIFrame;
        })(dom = keyman.dom || (keyman.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines the TouchAliasElement merged type.
/// <reference path="touchAliasElement.ts" />
// Defines the OutputTarget interface.
/// <reference path="../text/outputTarget.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var dom;
        (function (dom) {
            var TouchAlias = /** @class */ (function (_super) {
                __extends(TouchAlias, _super);
                function TouchAlias(e) {
                    var _this = _super.call(this) || this;
                    _this.root = e;
                    return _this;
                }
                TouchAlias.prototype.getElement = function () {
                    return this.root;
                };
                TouchAlias.prototype.clearSelection = function () {
                    // Touch-alias elements do not currently support selections.
                    return;
                };
                TouchAlias.prototype.invalidateSelection = function () {
                    // Touch-alias elements do not currently support selections.
                    return;
                };
                TouchAlias.prototype.hasSelection = function () {
                    // Always has an internal caret position.
                    return true;
                };
                TouchAlias.prototype.getDeadkeyCaret = function () {
                    return this.root.getTextCaret();
                };
                TouchAlias.prototype.getTextBeforeCaret = function () {
                    return this.root.getTextBeforeCaret();
                };
                TouchAlias.prototype.getTextAfterCaret = function () {
                    return this.root.getTextAfterCaret();
                };
                TouchAlias.prototype.getText = function () {
                    return this.root.getText();
                };
                TouchAlias.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (dn > 0) {
                        var curText = this.getTextBeforeCaret();
                        if (this.getDeadkeyCaret() < dn) {
                            dn = this.getDeadkeyCaret();
                        }
                        this.adjustDeadkeys(-dn);
                        this.root.setTextBeforeCaret(curText.kmwSubstring(0, this.root.getTextCaret() - dn));
                    }
                };
                TouchAlias.prototype.insertTextBeforeCaret = function (s) {
                    this.adjustDeadkeys(s._kmwLength());
                    this.root.setTextBeforeCaret(this.root.getTextBeforeCaret() + s);
                };
                TouchAlias.prototype.setTextAfterCaret = function (s) {
                    this.root.setText(this.getTextBeforeCaret() + s, this.getTextBeforeCaret()._kmwLength());
                };
                return TouchAlias;
            }(keyman.text.OutputTarget));
            dom.TouchAlias = TouchAlias;
        })(dom = keyman.dom || (keyman.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="../text/outputTarget.ts" />
// Defines a basic HTMLInputElement wrapper.
///<reference path="input.ts" />
// Defines a basic HTMLTextAreaElement wrapper.
///<reference path="textarea.ts" />
// Defines a basic content-editable wrapper.
///<reference path="contentEditable.ts" />
// Defines a basic design-mode IFrame wrapper.
///<reference path="designIFrame.ts" />
// Defines a basic touch-alias element wrapper.
///<reference path="touchAlias.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var dom;
        (function (dom) {
            function wrapElement(e) {
                // Complex type scoping is implemented here so that kmwutils.ts is not a dependency for test compilations.
                // TODO:  Use dom.Utils.instanceof instead of the current mild code replication done here.
                if (dom.Utils.instanceof(e, "HTMLInputElement")) {
                    return new dom.Input(e);
                }
                else if (dom.Utils.instanceof(e, "HTMLTextAreaElement")) {
                    return new dom.TextArea(e);
                }
                else if (dom.Utils.instanceof(e, "TouchAliasElement")) {
                    return new dom.TouchAlias(e);
                }
                else if (dom.Utils.instanceof(e, "HTMLIFrameElement")) {
                    var iframe = e;
                    if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.designMode == "on") {
                        return new dom.DesignIFrame(iframe);
                    }
                    else if (e.isContentEditable) {
                        // Do content-editable <iframe>s make sense?
                        return new dom.ContentEditable(e);
                    }
                    else {
                        return null;
                    }
                }
                else if (e.isContentEditable) {
                    return new dom.ContentEditable(e);
                }
                return null;
            }
            dom.wrapElement = wrapElement;
        })(dom = keyman.dom || (keyman.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Includes KMW-added property declaration extensions for HTML elements.
/// <reference path="kmwexthtml.ts" />
// References the base KMW object.
/// <reference path="kmwbase.ts" />
// References DOM event handling interfaces and classes.
/// <reference path="kmwdomevents.ts" />
// Includes KMW string extension declarations.
/// <reference path="text/kmwstring.ts" />
// Defines the touch-alias element structure used for mobile devices.
/// <reference path="dom/touchAliasElement.ts" />
/// <reference path="dom/wrapElement.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_3) {
        /**
         * This class serves as the intermediary between KeymanWeb and any given web page's elements.
         */
        var DOMManager = /** @class */ (function () {
            function DOMManager(keyman) {
                /**
                 * Tracks a list of event-listening elements.
                 *
                 * In touch mode, this should contain touch-aliasing DIVs, but will contain other elements in non-touch mode.
                 */
                this.inputList = []; // List of simulated input divisions for touch-devices   I3363 (Build 301)
                /**
                 * Tracks a visually-sorted list of elements that are KMW-enabled.
                 */
                this.sortedInputs = []; // List of all INPUT and TEXTAREA elements ordered top to bottom, left to right
                /**
                 * Function     nonKMWTouchHandler
                 * Scope        Private
                 * Description  A handler for KMW-touch-disabled elements when operating on touch devices.
                 */
                this.nonKMWTouchHandler = function (x) {
                    keyman_3.DOMEventHandlers.states.focusing = false;
                    clearTimeout(keyman_3.DOMEventHandlers.states.focusTimer);
                    this.keyman.osk.hideNow();
                }.bind(this);
                this._EnablementMutationObserverCore = function (mutations) {
                    for (var i = 0; i < mutations.length; i++) {
                        var mutation = mutations[i];
                        // ( ? : ) needed as a null check.
                        var disabledBefore = mutation.oldValue ? mutation.oldValue.indexOf('kmw-disabled') >= 0 : false;
                        var disabledAfter = mutation.target.className.indexOf('kmw-disabled') >= 0;
                        if (disabledBefore && !disabledAfter) {
                            this._EnableControl(mutation.target);
                        }
                        else if (!disabledBefore && disabledAfter) {
                            this._DisableControl(mutation.target);
                        }
                        // 'readonly' triggers on whether or not the attribute exists, not its value.
                        if (!disabledAfter && mutation.attributeName == "readonly") {
                            var readonlyBefore = mutation.oldValue ? mutation.oldValue != null : false;
                            var elem = mutation.target;
                            if (elem instanceof elem.ownerDocument.defaultView.HTMLInputElement
                                || elem instanceof elem.ownerDocument.defaultView.HTMLTextAreaElement) {
                                var readonlyAfter = elem.readOnly;
                                if (readonlyBefore && !readonlyAfter) {
                                    this._EnableControl(mutation.target);
                                }
                                else if (!readonlyBefore && readonlyAfter) {
                                    this._DisableControl(mutation.target);
                                }
                            }
                        }
                    }
                }.bind(this);
                this._AutoAttachObserverCore = function (mutations) {
                    var inputElementAdditions = [];
                    var inputElementRemovals = [];
                    for (var i = 0; i < mutations.length; i++) {
                        var mutation = mutations[i];
                        for (var j = 0; j < mutation.addedNodes.length; j++) {
                            inputElementAdditions = inputElementAdditions.concat(this._GetDocumentEditables(mutation.addedNodes[j]));
                        }
                        for (j = 0; j < mutation.removedNodes.length; j++) {
                            inputElementRemovals = inputElementRemovals.concat(this._GetDocumentEditables(mutation.removedNodes[j]));
                        }
                    }
                    for (var k = 0; k < inputElementAdditions.length; k++) {
                        if (this.isKMWInput(inputElementAdditions[k])) { // Apply standard element filtering!
                            this._MutationAdditionObserved(inputElementAdditions[k]);
                        }
                    }
                    for (k = 0; k < inputElementRemovals.length; k++) {
                        if (this.isKMWInput(inputElementRemovals[k])) { // Apply standard element filtering!
                            this._MutationRemovalObserved(inputElementRemovals[k]);
                        }
                    }
                    /* After all mutations have been handled, we need to recompile our .sortedInputs array, but only
                      * if any have actually occurred.
                      */
                    if (inputElementAdditions.length || inputElementRemovals.length) {
                        if (!this.keyman.util.device.touchable) {
                            this.listInputs();
                        }
                        else if (this.keyman.util.device.touchable) { // If something was added or removed, chances are it's gonna mess up our touch-based layout scheme, so let's update the touch elements.
                            var domManager = this;
                            window.setTimeout(function () {
                                domManager.listInputs();
                                for (var k = 0; k < this.sortedInputs.length; k++) {
                                    if (this.sortedInputs[k]['kmw_ip']) {
                                        this.sortedInputs[k]['kmw_ip'].updateInput();
                                    }
                                }
                            }.bind(this), 1);
                        }
                    }
                }.bind(this);
                /**
                 * Function     _MutationAdditionObserved
                 * Scope        Private
                 * @param       {Element}  Pelem     A page input, textarea, or iframe element.
                 * Description  Used by the MutationObserver event handler to properly setup any elements dynamically added to the document post-initialization.
                 *
                 */
                this._MutationAdditionObserved = function (Pelem) {
                    if (Pelem instanceof Pelem.ownerDocument.defaultView.HTMLIFrameElement && !this.keyman.util.device.touchable) {
                        //Problem:  the iframe is loaded asynchronously, and we must wait for it to load fully before hooking in.
                        var domManager = this;
                        var attachFunctor = function () {
                            // Provide a minor delay to allow 'load' event handlers to set the design-mode property.
                            window.setTimeout(function () {
                                domManager.attachToControl(Pelem);
                            }, 1);
                        };
                        Pelem.addEventListener('load', attachFunctor);
                        // The following block breaks for design-mode iframes, at least in Chrome; a blank document may exist
                        // before the load of the desired actual document. 
                        //
                        // /* If the iframe has somehow already loaded, we can't expect the onload event to be raised.  We ought just
                        // * go ahead and perform our callback's contents.
                        // * 
                        // * keymanweb.domManager.attachToControl() is now idempotent, so even if our call 'whiffs', it won't cause long-lasting
                        // * problems.
                        // */
                        // if(Pelem.contentDocument.readyState == 'complete') {
                        //   window.setTimeout(attachFunctor, 1);
                        // }
                    }
                    else {
                        this.attachToControl(Pelem);
                    }
                };
                // Used by the mutation event handler to properly decouple any elements dynamically removed from the document.
                this._MutationRemovalObserved = function (Pelem) {
                    var element = Pelem;
                    if (this.keyman.util.device.touchable) {
                        this.disableTouchElement(Pelem);
                    }
                    this.disableInputElement(Pelem); // Remove all KMW event hooks, styling.
                    this.clearElementAttachment(element); // Memory management & auto de-attachment upon removal.
                };
                /**
                 * Function     enableControl
                 * Scope        Public
                 * @param       {Element}      Pelem       Element to be disabled
                 * Description  Disables a KMW control element
                 */
                this.enableControl = function (Pelem) {
                    if (!this.isAttached(Pelem)) {
                        console.warn("KeymanWeb is not attached to element " + Pelem);
                    }
                    var cn = Pelem.className;
                    var tagIndex = cn.indexOf('kmw-disabled');
                    if (tagIndex >= 0) { // if already explicitly disabled...
                        Pelem.className = cn.replace('kmw-disabled', '').trim();
                    }
                    // The rest is triggered within MutationObserver code.
                    // See _EnablementMutationObserverCore.
                };
                /* ------------- Page and document-level management events ------------------ */
                this._WindowLoad = function (e) {
                    //keymanweb.completeInitialization();
                    // Always return to top of page after a page reload
                    document.body.scrollTop = 0;
                    if (typeof document.documentElement != 'undefined') {
                        document.documentElement.scrollTop = 0;
                    }
                }.bind(this);
                /**
                 * Function     _WindowUnload
                 * Scope        Private
                 * Description  Remove handlers before detaching KMW window
                 */
                this._WindowUnload = function () {
                    // Allow the UI to release its own resources
                    this.keyman.uiManager.doUnload();
                    // Allow the OSK to release its own resources
                    if (this.keyman.osk.ready) {
                        this.keyman.osk.shutdown();
                        this.keyman.osk._Unload(); // I3363 (Build 301)
                    }
                    this.clearLastActiveElement();
                }.bind(this);
                /**
                 * Function     Initialization
                 * Scope        Public
                 * @param       {Object}  arg     object array of user-defined properties
                 * Description  KMW window initialization
                 */
                this.init = function (arg) {
                    var i, j, c, e, p, eTextArea, eInput, opt, dTrailer, ds;
                    var osk = this.keyman.osk;
                    var util = this.keyman.util;
                    var device = util.device;
                    // Local function to convert relative to absolute URLs
                    // with respect to the source path, server root and protocol 
                    var fixPath = function (p) {
                        if (p.length == 0)
                            return p;
                        // Add delimiter if missing
                        if (p.substr(p.length - 1, 1) != '/')
                            p = p + '/';
                        // Absolute
                        if ((p.replace(/^(http)s?:.*/, '$1') == 'http')
                            || (p.replace(/^(file):.*/, '$1') == 'file'))
                            return p;
                        // Absolute (except for protocol)
                        if (p.substr(0, 2) == '//')
                            return this.keyman.protocol + p;
                        // Relative to server root
                        if (p.substr(0, 1) == '/')
                            return this.keyman.rootPath + p.substr(1);
                        // Otherwise, assume relative to source path
                        return this.keyman.srcPath + p;
                    }.bind(this);
                    // Explicit (user-defined) parameter initialization       
                    opt = this.keyman.options;
                    if (typeof (arg) == 'object' && arg !== null) {
                        for (p in opt) {
                            if (arg.hasOwnProperty(p))
                                opt[p] = arg[p];
                        }
                    }
                    // Get default paths and device options
                    if (opt['root'] != '') {
                        this.keyman.rootPath = fixPath(opt['root']);
                    }
                    // Keyboards and fonts are located with respect to the server root by default          
                    //if(opt['keyboards'] == '') opt['keyboards'] = keymanweb.rootPath+'keyboard/';
                    //if(opt['fonts'] == '') opt['fonts'] = keymanweb.rootPath+'font/';
                    // Resources are located with respect to the engine by default 
                    if (opt['resources'] == '') {
                        opt['resources'] = this.keyman.srcPath;
                    }
                    // Convert resource, keyboard and font paths to absolute URLs
                    opt['resources'] = fixPath(opt['resources']);
                    opt['keyboards'] = fixPath(opt['keyboards']);
                    opt['fonts'] = fixPath(opt['fonts']);
                    // Set element attachment type    
                    if (opt['attachType'] == '') {
                        opt['attachType'] = 'auto';
                    }
                    // Set default device options
                    this.keyman.setDefaultDeviceOptions(opt);
                    // Only do remainder of initialization once!  
                    if (this.keyman.initialized) {
                        return Promise.resolve();
                    }
                    var keyman = this.keyman;
                    var domManager = this;
                    // Do not initialize until the document has been fully loaded
                    if (document.readyState !== 'complete') {
                        return new Promise(function (resolve) {
                            window.setTimeout(function () {
                                domManager.init(arg).then(function () {
                                    resolve();
                                });
                            }, 50);
                        });
                    }
                    keyman.modelManager.init();
                    this.keyman._MasterDocument = window.document;
                    /**
                     * Initialization of touch devices and browser interfaces must be done
                     * after all resources are loaded, during final stage of initialization
                     *
                     */
                    // Treat Android devices as phones if either (reported) screen dimension is less than 4" 
                    if (device.OS == 'Android') {
                        // Determine actual device characteristics  I3363 (Build 301)
                        // TODO: device.dpi may no longer be needed - if so, get rid of it.
                        var dpi = device.getDPI(); //TODO: this will not work when called from HEAD!!
                        device.formFactor = ((screen.height < 4.0 * dpi) || (screen.width < 4.0 * dpi)) ? 'phone' : 'tablet';
                    }
                    // Set exposed initialization flag member for UI (and other) code to use 
                    this.keyman.setInitialized(1);
                    // Finish keymanweb and OSK initialization once all necessary resources are available
                    osk.prepare();
                    // Create and save the remote keyboard loading delay indicator
                    util.prepareWait();
                    // Register deferred keyboard stubs (addKeyboards() format)
                    this.keyman.keyboardManager.registerDeferredStubs();
                    // Initialize the desktop UI
                    this.initializeUI();
                    // Register deferred keyboards 
                    this.keyman.keyboardManager.registerDeferredKeyboards();
                    // Exit initialization here if we're using an embedded code path.
                    if (this.keyman.isEmbedded) {
                        if (!this.keyman.keyboardManager.setDefaultKeyboard()) {
                            console.error("No keyboard stubs exist - cannot initialize keyboard!");
                        }
                        return Promise.resolve();
                    }
                    // Determine the default font for mapped elements
                    this.keyman.appliedFont = this.keyman.baseFont = this.getBaseFont();
                    // Add orientationchange event handler to manage orientation changes on mobile devices
                    // Initialize touch-screen device interface  I3363 (Build 301)
                    if (device.touchable) {
                        this.keyman.handleRotationEvents();
                    }
                    // Initialize browser interface
                    if (this.keyman.options['attachType'] != 'manual') {
                        this._SetupDocument(document.documentElement);
                    }
                    // Create an ordered list of all input and textarea fields
                    this.listInputs();
                    // Initialize the OSK and set default OSK styles
                    // Note that this should *never* be called before the OSK has been initialized.
                    // However, it possibly may be called before the OSK has been fully defined with the current keyboard, need to check.    
                    //osk._Load(); 
                    //document.body.appendChild(osk._Box); 
                    //osk._Load(false);
                    // I3363 (Build 301)
                    if (device.touchable) {
                        // Handle OSK touchend events (prevent propagation)
                        osk._Box.addEventListener('touchend', function (e) {
                            e.stopPropagation();
                        }, false);
                        // Add a blank DIV to the bottom of the page to allow the bottom of the page to be shown
                        dTrailer = document.createElement('DIV');
                        ds = dTrailer.style;
                        ds.width = '100%';
                        ds.height = (screen.width / 2) + 'px';
                        document.body.appendChild(dTrailer);
                        // On Chrome, scrolling up or down causes the URL bar to be shown or hidden 
                        // according to whether or not the document is at the top of the screen.
                        // But when doing that, each OSK row top and height gets modified by Chrome
                        // looking very ugly.  Itwould be best to hide the OSK then show it again 
                        // when the user scroll finishes, but Chrome has no way to reliably report
                        // the touch end event after a move. c.f. http://code.google.com/p/chromium/issues/detail?id=152913
                        // The best compromise behaviour is simply to hide the OSK whenever any 
                        // non-input and non-OSK element is touched.
                        if (device.OS == 'Android' && navigator.userAgent.indexOf('Chrome') > 0) {
                            this.keyman.hideOskWhileScrolling = function (e) {
                                if (typeof (osk._Box) == 'undefined')
                                    return;
                                if (typeof (osk._Box.style) == 'undefined')
                                    return;
                                // The following tests are needed to prevent the OSK from being hidden during normal input!
                                p = e.target.parentNode;
                                if (typeof (p) != 'undefined' && p != null) {
                                    if (p.className.indexOf('keymanweb-input') >= 0)
                                        return;
                                    if (p.className.indexOf('kmw-key-') >= 0)
                                        return;
                                    if (typeof (p.parentNode) != 'undefined') {
                                        p = p.parentNode;
                                        if (p.className.indexOf('keymanweb-input') >= 0)
                                            return;
                                        if (p.className.indexOf('kmw-key-') >= 0)
                                            return;
                                    }
                                }
                                osk.hideNow();
                            };
                            this.keyman.util.attachDOMEvent(document.body, 'touchstart', this.keyman.hideOskWhileScrolling, false);
                        }
                        else {
                            this.keyman.conditionallyHideOsk = function () {
                                // Should not hide OSK if simply closing the language menu (30/4/15)
                                if (keyman.hideOnRelease && !osk.lgList)
                                    osk.hideNow();
                                keyman.hideOnRelease = false;
                            };
                            this.keyman.hideOskIfOnBody = function (e) {
                                keyman.touchY = e.touches[0].screenY;
                                keyman.hideOnRelease = true;
                            };
                            this.keyman.cancelHideIfScrolling = function (e) {
                                var y = e.touches[0].screenY, y0 = keyman.touchY;
                                if (y - y0 > 5 || y0 - y < 5)
                                    keyman.hideOnRelease = false;
                            };
                            this.keyman.util.attachDOMEvent(document.body, 'touchstart', this.keyman.hideOskIfOnBody, false);
                            this.keyman.util.attachDOMEvent(document.body, 'touchmove', this.keyman.cancelHideIfScrolling, false);
                            this.keyman.util.attachDOMEvent(document.body, 'touchend', this.keyman.conditionallyHideOsk, false);
                        }
                    }
                    //document.body.appendChild(keymanweb._StyleBlock);
                    // Restore and reload the currently selected keyboard, selecting a default keyboard if necessary.
                    this.keyman.keyboardManager.restoreCurrentKeyboard();
                    /* Setup of handlers for dynamically-added and (eventually) dynamically-removed elements.
                      * Reference: https://developer.mozilla.org/en/docs/Web/API/MutationObserver
                      *
                      * We place it here so that it loads after most of the other UI loads, reducing the MutationObserver's overhead.
                      * Of course, we only want to dynamically add elements if the user hasn't enabled the manual attachment option.
                      */
                    if (MutationObserver) {
                        var observationTarget = document.querySelector('body'), observationConfig;
                        if (this.keyman.options['attachType'] != 'manual') { //I1961
                            observationConfig = { childList: true, subtree: true };
                            this.attachmentObserver = new MutationObserver(this._AutoAttachObserverCore);
                            this.attachmentObserver.observe(observationTarget, observationConfig);
                        }
                        /**
                         * Setup of handlers for dynamic detection of the kmw-disabled class tag that controls enablement.
                         */
                        observationConfig = { subtree: true, attributes: true, attributeOldValue: true, attributeFilter: ['class', 'readonly'] };
                        this.enablementObserver = new MutationObserver(this._EnablementMutationObserverCore);
                        this.enablementObserver.observe(observationTarget, observationConfig);
                    }
                    else {
                        console.warn("Your browser is outdated and does not support MutationObservers, a web feature " +
                            "needed by KeymanWeb to support dynamically-added elements.");
                    }
                    // Set exposed initialization flag to 2 to indicate deferred initialization also complete
                    /* To prevent propagation of focus & blur events from the input-scroll workaround,
                     * we attach top-level capturing listeners to the focus & blur events.  They prevent propagation
                     * but NOT default behavior, allowing the scroll to complete while preventing nearly all
                     * possible event 'noise' that could result from the workaround.
                     */
                    this.keyman.util.attachDOMEvent(document.body, 'focus', DOMManager.suppressFocusCheck, true);
                    this.keyman.util.attachDOMEvent(document.body, 'blur', DOMManager.suppressFocusCheck, true);
                    this.keyman.setInitialized(2);
                    return Promise.resolve();
                }.bind(this);
                this.keyman = keyman;
                if (keyman.util.device.touchable) {
                    this.touchHandlers = new keyman_3.DOMTouchHandlers(keyman);
                }
                this.nonTouchHandlers = new keyman_3.DOMEventHandlers(keyman);
            }
            DOMManager.prototype.shutdown = function () {
                // Catch and notify of any shutdown errors, but don't let errors fail unit tests.
                try {
                    if (this.enablementObserver) {
                        this.enablementObserver.disconnect();
                    }
                    if (this.attachmentObserver) {
                        this.attachmentObserver.disconnect();
                    }
                    for (var _i = 0, _a = this.inputList; _i < _a.length; _i++) {
                        var input = _a[_i];
                        this.disableInputElement(input);
                    }
                    // On shutdown, we remove our general focus-suppression handlers as well.
                    this.keyman.util.detachDOMEvent(document.body, 'focus', DOMManager.suppressFocusCheck, true);
                    this.keyman.util.detachDOMEvent(document.body, 'blur', DOMManager.suppressFocusCheck, true);
                }
                catch (e) {
                    console.error("Error occurred during shutdown");
                    console.error(e);
                }
            };
            /**
             * Function     getHandlers
             * Scope        Private
             * @param       {Element}   Pelem  An input, textarea, or touch-alias element from the page.
             * @returns     {Object}
             */
            DOMManager.prototype.getHandlers = function (Pelem) {
                var _attachObj = Pelem.base ? Pelem.base._kmwAttachment : Pelem._kmwAttachment;
                if (_attachObj) {
                    return _attachObj.touchEnabled ? this.touchHandlers : this.nonTouchHandlers;
                }
                else {
                    // Best guess solution.
                    return this.keyman.touchAliasing;
                }
            };
            /**
             * Function     enableTouchElement
             * Scope        Private
             * @param       {Element}  Pelem   An input or textarea element from the page.
             * @return      {boolean}  Returns true if it creates a simulated input element for Pelem; false if not.
             * Description  Creates a simulated input element for the specified INPUT or TEXTAREA, comprising:
             *              an outer DIV, matching the position, size and style of the base element
             *              a scrollable DIV within that outer element
             *              two SPAN elements within the scrollable DIV, to hold the text before and after the caret
             *
             *              The left border of the second SPAN is flashed on and off as a visible caret
             *
             *              Also ensures the element is registered on keymanweb's internal input list.
             */
            DOMManager.prototype.enableTouchElement = function (Pelem) {
                // Touch doesn't worry about iframes.
                if (Pelem.tagName.toLowerCase() == 'iframe') {
                    return false;
                }
                if (this.isKMWDisabled(Pelem)) {
                    this.setupNonKMWTouchElement(Pelem);
                    return false;
                }
                else {
                    // Initialize and protect input elements for touch-screen devices (but never for apps)
                    // NB: now set disabled=true rather than readonly, since readonly does not always 
                    // prevent element from getting focus, e.g. within a LABEL element.
                    // c.f. http://kreotekdev.wordpress.com/2007/11/08/disabled-vs-readonly-form-fields/ 
                    Pelem.kmwInput = true;
                }
                // Remove any handlers for "NonKMWTouch" elements, since we're enabling it here.
                Pelem.removeEventListener('touchstart', this.nonKMWTouchHandler);
                /*
                *  Does this element already have a simulated touch element established?  If so,
                *  just reuse it - if it isn't still in the input list!
                */
                if (Pelem['kmw_ip']) {
                    if (this.inputList.indexOf(Pelem['kmw_ip']) != -1) {
                        return false;
                    }
                    this.inputList.push(Pelem['kmw_ip']);
                    console.log("Unexpected state - this element's simulated input DIV should have been removed from the page!");
                    return true; // May need setup elsewhere since it's just been re-added!
                }
                // The simulated touch element doesn't already exist?  Time to initialize it.
                var x = keyman_3.dom.constructTouchAlias(Pelem);
                if (this.isAttached(x)) {
                    x._kmwAttachment.interface = keyman_3.dom.wrapElement(x);
                }
                else {
                    this.setupElementAttachment(x); // The touch-alias should have its own wrapper.
                }
                Pelem._kmwAttachment = x._kmwAttachment; // It's an object reference we need to alias.
                // Set font for base element
                this.enableInputElement(x, true);
                // Superimpose custom input fields for each input or textarea, unless readonly or disabled 
                // On touch event, reposition the text caret and prepare for OSK input
                // Removed 'onfocus=' as that resulted in handling the event twice (on iOS, anyway) 
                // We know this to be the correct set of handlers because we're setting up a touch element.
                var touchHandlers = this.touchHandlers;
                x.addEventListener('touchstart', touchHandlers.setFocus);
                x.onmspointerdown = function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return touchHandlers.setFocus(e);
                };
                x.addEventListener('touchend', function (e) {
                    e.stopPropagation();
                });
                x.onmspointerup = function (e) {
                    e.stopPropagation();
                };
                // Disable internal scroll when input element in focus 
                x.addEventListener('touchmove', touchHandlers.dragInput, false);
                x.onmspointermove = touchHandlers.dragInput;
                // Hide keyboard and caret when losing focus from simulated input field
                x.onblur = touchHandlers.setBlur;
                // Note that touchend event propagates and is processed by body touchend handler
                // re-setting the first touch point for a drag
                return true;
            };
            /**
             * Function     disableTouchElement
             * Scope        Private
             * @param       {Element}  Pelem   An input or textarea element from the page.
             * Description  Destroys the simulated input element for the specified INPUT or TEXTAREA and reverts
             *              back to desktop-style 'enablement' for the base control.
             */
            DOMManager.prototype.disableTouchElement = function (Pelem) {
                // Do not check for the element being officially disabled - it's also used for detachment.
                // Touch doesn't worry about iframes.
                if (Pelem.tagName.toLowerCase() == 'iframe') {
                    return; // If/when we do support this, we'll need an iframe-level manager for it.
                }
                if (Pelem['kmw_ip']) {
                    var index = this.inputList.indexOf(Pelem['kmw_ip']);
                    if (index != -1) {
                        this.inputList.splice(index, 1);
                    }
                    Pelem.style.visibility = 'visible'; // hide by default: KMW-3
                    Pelem.disabled = false;
                    Pelem.removeEventListener('resize', Pelem['kmw_ip']._kmwResizeHandler);
                    // Disable touch-related handling code.
                    this.disableInputElement(Pelem['kmw_ip']);
                    Pelem._kmwAttachment.interface = keyman_3.dom.wrapElement(Pelem);
                    // We get weird repositioning errors if we don't remove our simulated input element - and permanently.
                    if (Pelem.parentNode) {
                        Pelem.parentNode.removeChild(Pelem['kmw_ip']);
                    }
                    delete Pelem['kmw_ip'];
                }
                this.setupNonKMWTouchElement(Pelem);
            };
            /**
             * Function     setupNonKMWTouchElement
             * Scope        Private
             * @param       {Element}    x  A child element of document.
             * Description  Performs handling for the specified disabled input element on touch-based systems.
             */
            DOMManager.prototype.setupNonKMWTouchElement = function (x) {
                this.keyman.util.attachDOMEvent(x, 'touchstart', this.nonKMWTouchHandler, false);
                // Signify that touch isn't enabled on the control.
                if (this.isAttached(x)) {
                    x._kmwAttachment.touchEnabled = false;
                }
            };
            /**
             * Function     enableInputElement
             * Scope        Private
             * @param       {Element}   Pelem   An element from the document to be enabled with full KMW handling.
             * @param       {boolean=}   isAlias A flag that indicates if the element is a simulated input element for touch.
             * Description  Performs the basic enabling setup for one element and adds it to the inputList if it is an input element.
             *              Note that this method is called for both desktop and touch control routes; the touch route calls it from within
             *              enableTouchElement as it must first establish the simulated touch element to serve as the alias "input element" here.
             *              Note that the 'kmw-disabled' property is managed by the MutationObserver and by the surface API calls.
             */
            DOMManager.prototype.enableInputElement = function (Pelem, isAlias) {
                var baseElement = isAlias ? Pelem['base'] : Pelem;
                if (!this.isKMWDisabled(baseElement)) {
                    if (Pelem instanceof Pelem.ownerDocument.defaultView.HTMLIFrameElement) {
                        this._AttachToIframe(Pelem);
                    }
                    else {
                        if (!isAlias) {
                            this.setupElementAttachment(Pelem);
                        }
                        baseElement.className = baseElement.className ? baseElement.className + ' keymanweb-font' : 'keymanweb-font';
                        this.inputList.push(Pelem);
                        this.keyman.util.attachDOMEvent(baseElement, 'focus', this.getHandlers(Pelem)._ControlFocus);
                        this.keyman.util.attachDOMEvent(baseElement, 'blur', this.getHandlers(Pelem)._ControlBlur);
                        // These need to be on the actual input element, as otherwise the keyboard will disappear on touch.
                        Pelem.onkeypress = this.getHandlers(Pelem)._KeyPress;
                        Pelem.onkeydown = this.getHandlers(Pelem)._KeyDown;
                        Pelem.onkeyup = this.getHandlers(Pelem)._KeyUp;
                    }
                }
            };
            ;
            /**
             * Function     disableInputElement
             * Scope        Private
             * @param       {Element}   Pelem   An element from the document to be enabled with full KMW handling.
             * @param       {boolean=}   isAlias A flag that indicates if the element is a simulated input element for touch.
             * Description  Inverts the process of enableInputElement, removing all event-handling from the element.
             *              Note that the 'kmw-disabled' property is managed by the MutationObserver and by the surface API calls.
             */
            DOMManager.prototype.disableInputElement = function (Pelem, isAlias) {
                if (!Pelem) {
                    return;
                }
                var baseElement = isAlias ? Pelem['base'] : Pelem;
                // Do NOT test for pre-disabledness - we also use this to fully detach without officially 'disabling' via kmw-disabled.
                if ((Pelem.ownerDocument.defaultView && Pelem instanceof Pelem.ownerDocument.defaultView.HTMLIFrameElement) ||
                    Pelem instanceof HTMLIFrameElement) {
                    this._DetachFromIframe(Pelem);
                }
                else {
                    var cnIndex = baseElement.className.indexOf('keymanweb-font');
                    if (cnIndex > 0 && !isAlias) { // See note about the alias below.
                        baseElement.className = baseElement.className.replace('keymanweb-font', '').trim();
                    }
                    // Remove the element from our internal input tracking.
                    var index = this.inputList.indexOf(Pelem);
                    if (index > -1) {
                        this.inputList.splice(index, 1);
                    }
                    if (!isAlias) { // See note about the alias below.
                        this.keyman.util.detachDOMEvent(baseElement, 'focus', this.getHandlers(Pelem)._ControlFocus);
                        this.keyman.util.detachDOMEvent(baseElement, 'blur', this.getHandlers(Pelem)._ControlBlur);
                    }
                    // These need to be on the actual input element, as otherwise the keyboard will disappear on touch.
                    Pelem.onkeypress = null;
                    Pelem.onkeydown = null;
                    Pelem.onkeyup = null;
                }
                // If we're disabling an alias, we should fully enable the base version.  (Thinking ahead to toggleable-touch mode.)
                if (isAlias) {
                    this.inputList.push(baseElement);
                    baseElement.onkeypress = this.getHandlers(Pelem)._KeyPress;
                    baseElement.onkeydown = this.getHandlers(Pelem)._KeyDown;
                    baseElement.onkeyup = this.getHandlers(Pelem)._KeyUp;
                }
                var lastElem = this.getLastActiveElement();
                if (lastElem == Pelem || lastElem == Pelem['kmw_ip']) {
                    this.clearLastActiveElement();
                    this.keyman.osk._Hide(false);
                }
                return;
            };
            ;
            /**
         * Function     isKMWDisabled
         * Scope        Private
         * @param       {Element}   x   An element from the page.
         * @return      {boolean}      true if the element's properties indicate a 'disabled' state.
         * Description  Examines attachable elements to determine their default enablement state.
         */
            DOMManager.prototype.isKMWDisabled = function (x) {
                var c = x.className;
                // Exists for some HTMLElements.
                if (x['readOnly']) {
                    return true;
                }
                else if (c && c.indexOf('kmw-disabled') >= 0) {
                    return true;
                }
                return false;
            };
            /**
             * Function     attachToControl
             * Scope        Public
             * @param       {Element}    Pelem       Element to which KMW will be attached
             * Description  Attaches KMW to control (or IFrame)
             */
            DOMManager.prototype.attachToControl = function (Pelem) {
                var touchable = this.keyman.util.device.touchable;
                // Exception for IFrame elements, in case of async loading issues.  (Fixes fun iframe loading bug with Chrome.)
                if (this.isAttached(Pelem) && !(Pelem instanceof Pelem.ownerDocument.defaultView.HTMLIFrameElement)) {
                    return; // We're already attached.
                }
                if (this.isKMWInput(Pelem)) {
                    if (!this.isKMWDisabled(Pelem)) {
                        if (touchable && !this.keyman.isEmbedded) {
                            this.enableTouchElement(Pelem);
                        }
                        else {
                            this.enableInputElement(Pelem);
                        }
                    }
                    else {
                        if (touchable) {
                            this.setupNonKMWTouchElement(Pelem);
                        }
                    }
                }
                else if (touchable) {
                    this.setupNonKMWTouchElement(Pelem);
                }
            };
            /**
             * Function     detachFromControl
             * Scope        Public
             * @param       {Element}    Pelem       Element from which KMW will detach
             * Description  Detaches KMW from a control (or IFrame)
             */
            DOMManager.prototype.detachFromControl = function (Pelem) {
                if (!(this.isAttached(Pelem) || Pelem instanceof Pelem.ownerDocument.defaultView.HTMLIFrameElement)) {
                    return; // We never were attached.
                }
                // #1 - if element is enabled, disable it.  But don't manipulate the 'kmw-disabled' tag.
                if (this.isKMWInput(Pelem)) {
                    // Is it already disabled?
                    if (!this.isKMWDisabled(Pelem)) {
                        this._DisableControl(Pelem);
                    }
                }
                // #2 - clear attachment data.      
                this.clearElementAttachment(Pelem);
            };
            /**
             * Function     isAttached
             * Scope        Private
             * @param       {Element}   x   An element from the page.
             * @return      {boolean}       true if KMW is attached to the element, otherwise false.
             */
            DOMManager.prototype.isAttached = function (x) {
                return x._kmwAttachment ? true : false;
            };
            /**
             * Function     isKMWInput
             * Scope        Private
             * @param       {Element}   x   An element from the page.
             * @return      {boolean}      true if the element is viable for KMW attachment.
             * Description  Examines potential input elements to determine whether or not they are viable for KMW attachment.
             *              Also filters elements not supported for touch devices when device.touchable == true.
             */
            DOMManager.prototype.isKMWInput = function (x) {
                var touchable = this.keyman.util.device.touchable;
                if (x instanceof x.ownerDocument.defaultView.HTMLTextAreaElement) {
                    return true;
                }
                else if (x instanceof x.ownerDocument.defaultView.HTMLInputElement) {
                    if (x.type == 'text' || x.type == 'search') {
                        return true;
                    }
                }
                else if (x instanceof x.ownerDocument.defaultView.HTMLIFrameElement && !touchable) { // Do not allow iframe attachment if in 'touch' mode.
                    try {
                        if (x.contentWindow) {
                            if (x.contentWindow.document) { // Only allow attachment if the iframe's internal document is valid.
                                return true;
                            }
                        } // else nothing?
                    }
                    catch (err) {
                        /* Do not attempt to access iframes outside this site */
                        console.warn("Error during attachment to / detachment from iframe: ");
                        console.warn(err);
                    }
                }
                else if (x.isContentEditable && !touchable) { // Only allow contentEditable attachment outside of 'touch' mode.
                    return true;
                }
                return false;
            };
            /**
             * Function     setupElementAttachment
             * Scope        Private
             * @param       {Element}   x   An element from the page valid for KMW attachment
             * Description  Establishes the base KeymanWeb data for newly-attached elements.
             *              Does not establish input hooks, which are instead handled during enablement.
             */
            DOMManager.prototype.setupElementAttachment = function (x) {
                // The `_kmwAttachment` property tag maintains all relevant KMW-maintained data regarding the element.
                // It is disgarded upon de-attachment.
                if (x._kmwAttachment) {
                    return;
                }
                else {
                    // Problem:  tries to wrap IFrames that aren't design-mode.
                    // The elements in the contained document get separately wrapped, so this doesn't need a proper wrapper.
                    //
                    // Its attachment process might need some work.
                    var eleInterface = keyman_3.dom.wrapElement(x);
                    // May should filter better for IFrames.
                    if (!(eleInterface || keyman_3.dom.Utils.instanceof(x, "HTMLIFrameElement"))) {
                        console.warn("Could not create processing interface for newly-attached element!");
                    }
                    x._kmwAttachment = new keyman_3.AttachmentInfo(eleInterface, null, this.keyman.util.device.touchable);
                }
            };
            /**
             * Function     clearElementAttachment
             * Scope        Private
             * @param       {Element}   x   An element from the page valid for KMW attachment
             * Description  Establishes the base KeymanWeb data for newly-attached elements.
             *              Does not establish input hooks, which are instead handled during enablement.
             */
            DOMManager.prototype.clearElementAttachment = function (x) {
                // We need to clear the object when de-attaching; helps prevent memory leaks.
                x._kmwAttachment = null;
            };
            /**
             * Function     _AttachToIframe
             * Scope        Private
             * @param       {Element}      Pelem       IFrame to which KMW will be attached
             * Description  Attaches KeymanWeb to IFrame
             */
            DOMManager.prototype._AttachToIframe = function (Pelem) {
                var util = this.keyman.util;
                try {
                    var Lelem = Pelem.contentWindow.document;
                    /* editable Iframe */
                    if (Lelem) {
                        if (Lelem.designMode.toLowerCase() == 'on') {
                            // I2404 - Attach to IFRAMEs child objects, only editable IFRAMEs here
                            if (util.device.browser == 'firefox') {
                                util.attachDOMEvent(Lelem, 'focus', this.getHandlers(Pelem)._ControlFocus);
                                util.attachDOMEvent(Lelem, 'blur', this.getHandlers(Pelem)._ControlBlur);
                            }
                            else { // Chrome, Safari
                                util.attachDOMEvent(Lelem.body, 'focus', this.getHandlers(Pelem)._ControlFocus);
                                util.attachDOMEvent(Lelem.body, 'blur', this.getHandlers(Pelem)._ControlBlur);
                            }
                            util.attachDOMEvent(Lelem.body, 'keydown', this.getHandlers(Pelem)._KeyDown);
                            util.attachDOMEvent(Lelem.body, 'keypress', this.getHandlers(Pelem)._KeyPress);
                            util.attachDOMEvent(Lelem.body, 'keyup', this.getHandlers(Pelem)._KeyUp);
                            // Set up a reference alias; the internal document will need the same attachment info!
                            this.setupElementAttachment(Pelem);
                            Lelem.body._kmwAttachment = Pelem._kmwAttachment;
                        }
                        else {
                            // Lelem is the IFrame's internal document; set 'er up!
                            this._SetupDocument(Lelem.body); // I2404 - Manage IE events in IFRAMEs
                        }
                    }
                }
                catch (err) {
                    // do not attempt to attach to the iframe as it is from another domain - XSS denied!
                }
            };
            /**
         * Function     _DetachFromIframe
         * Scope        Private
         * @param       {Element}      Pelem       IFrame to which KMW will be attached
         * Description  Detaches KeymanWeb from an IFrame
         */
            DOMManager.prototype._DetachFromIframe = function (Pelem) {
                var util = this.keyman.util;
                try {
                    var Lelem = Pelem.contentWindow.document;
                    /* editable Iframe */
                    if (Lelem) {
                        if (Lelem.designMode.toLowerCase() == 'on') {
                            // Mozilla      // I2404 - Attach to  IFRAMEs child objects, only editable IFRAMEs here
                            if (util.device.browser == 'firefox') {
                                // Firefox won't handle these events on Lelem.body - only directly on Lelem (the doc) instead.
                                util.detachDOMEvent(Lelem, 'focus', this.getHandlers(Pelem)._ControlFocus);
                                util.detachDOMEvent(Lelem, 'blur', this.getHandlers(Pelem)._ControlBlur);
                            }
                            else { // Chrome, Safari
                                util.detachDOMEvent(Lelem.body, 'focus', this.getHandlers(Pelem)._ControlFocus);
                                util.detachDOMEvent(Lelem.body, 'blur', this.getHandlers(Pelem)._ControlBlur);
                            }
                            util.detachDOMEvent(Lelem.body, 'keydown', this.getHandlers(Pelem)._KeyDown);
                            util.detachDOMEvent(Lelem.body, 'keypress', this.getHandlers(Pelem)._KeyPress);
                            util.detachDOMEvent(Lelem.body, 'keyup', this.getHandlers(Pelem)._KeyUp);
                            // Remove the reference to our prior attachment data!
                            Lelem.body._kmwAttachment = null;
                        }
                        else {
                            // Lelem is the IFrame's internal document; set 'er up!
                            this._ClearDocument(Lelem.body); // I2404 - Manage IE events in IFRAMEs
                        }
                    }
                }
                catch (err) {
                    // do not attempt to attach to the iframe as it is from another domain - XSS denied!
                }
            };
            /**
             * Function     _GetDocumentEditables
             * Scope        Private
             * @param       {Element}     Pelem     HTML element
             * @return      {Array<Element>}        A list of potentially-editable controls.  Further filtering [as with isKMWInput() and
             *                                      isKMWDisabled()] is required.
             */
            DOMManager.prototype._GetDocumentEditables = function (Pelem) {
                var util = this.keyman.util;
                var possibleInputs = [];
                // Document.ownerDocument === null, so we better check that it's not null before proceeding.
                if (Pelem.ownerDocument && Pelem instanceof Pelem.ownerDocument.defaultView.HTMLElement) {
                    var dv = Pelem.ownerDocument.defaultView;
                    if (Pelem instanceof dv.HTMLInputElement || Pelem instanceof dv.HTMLTextAreaElement) {
                        possibleInputs.push(Pelem);
                    }
                    else if (Pelem instanceof dv.HTMLIFrameElement) {
                        possibleInputs.push(Pelem);
                    }
                }
                // Constructing it like this also allows for individual element filtering for the auto-attach MutationObserver without errors.
                if (Pelem.getElementsByTagName) {
                    /**
                     * Function     LiTmp
                     * Scope        Private
                     * @param       {string}    _colon    type of element
                     * @return      {Array<Element>}  array of elements of specified type
                     * Description  Local function to get list of editable controls
                     */
                    var LiTmp = function (_colon) {
                        return util.arrayFromNodeList(Pelem.getElementsByTagName(_colon));
                    };
                    // Note that isKMWInput() will block IFRAME elements as necessary for touch-based devices.
                    possibleInputs = possibleInputs.concat(LiTmp('INPUT'), LiTmp('TEXTAREA'), LiTmp('IFRAME'));
                }
                // Not all active browsers may support the method, but only those that do would work with contenteditables anyway.
                if (Pelem.querySelectorAll) {
                    possibleInputs = possibleInputs.concat(util.arrayFromNodeList(Pelem.querySelectorAll('[contenteditable]')));
                }
                if (Pelem.ownerDocument && Pelem instanceof Pelem.ownerDocument.defaultView.HTMLElement && Pelem.isContentEditable) {
                    possibleInputs.push(Pelem);
                }
                return possibleInputs;
            };
            /**
             * Function     _SetupDocument
             * Scope        Private
             * @param       {Element}     Pelem - the root element of a document, including IFrame documents.
             * Description  Used to automatically attach KMW to editable controls, regardless of control path.
             */
            DOMManager.prototype._SetupDocument = function (Pelem) {
                var possibleInputs = this._GetDocumentEditables(Pelem);
                for (var Li = 0; Li < possibleInputs.length; Li++) {
                    var input = possibleInputs[Li];
                    // It knows how to handle pre-loaded iframes appropriately.
                    this.attachToControl(possibleInputs[Li]);
                }
            };
            /**
             * Function     _ClearDocument
             * Scope        Private
             * @param       {Element}     Pelem - the root element of a document, including IFrame documents.
             * Description  Used to automatically detach KMW from editable controls, regardless of control path.
             *              Mostly used to clear out all controls of a detached IFrame.
             */
            DOMManager.prototype._ClearDocument = function (Pelem) {
                var possibleInputs = this._GetDocumentEditables(Pelem);
                for (var Li = 0; Li < possibleInputs.length; Li++) {
                    var input = possibleInputs[Li];
                    // It knows how to handle pre-loaded iframes appropriately.
                    this.detachFromControl(possibleInputs[Li]);
                }
            };
            /**
             * Set target element text direction (LTR or RTL), but only if the element is empty
             *
             * If the element base directionality is changed after it contains content, unless all the text
             * has the same directionality, text runs will be re-ordered which is confusing and causes
             * incorrect caret positioning
             *
             * @param       {Object}      Ptarg      Target element
             */
            DOMManager.prototype._SetTargDir = function (Ptarg) {
                var elDir = (this.keyman.keyboardManager.isRTL()) ? 'rtl' : 'ltr';
                if (Ptarg) {
                    if (this.keyman.util.device.touchable) {
                        var alias = Ptarg;
                        if (Ptarg.textContent.length == 0) {
                            alias.base.dir = alias.dir = elDir;
                            alias.setTextCaret(10000);
                        }
                    }
                    else {
                        if (Ptarg instanceof Ptarg.ownerDocument.defaultView.HTMLInputElement
                            || Ptarg instanceof Ptarg.ownerDocument.defaultView.HTMLTextAreaElement) {
                            if (Ptarg.value.length == 0) {
                                Ptarg.dir = elDir;
                            }
                        }
                        else if (typeof Ptarg.textContent == "string" && Ptarg.textContent.length == 0) { // As with contenteditable DIVs, for example.
                            Ptarg.dir = elDir;
                        }
                    }
                }
            };
            /**
             * Function     _DisableControl
             * Scope        Private
             * @param       {Element}      Pelem       Element to be disabled
             * Description  Disable KMW control element
             */
            DOMManager.prototype._DisableControl = function (Pelem) {
                // Only operate on attached elements!  Non-design-mode IFrames don't get attachment markers, so we check them specifically instead.
                if (this.isAttached(Pelem) || Pelem instanceof Pelem.ownerDocument.defaultView.HTMLIFrameElement) {
                    if (this.keyman.util.device.touchable) {
                        this.disableTouchElement(Pelem);
                        this.setupNonKMWTouchElement(Pelem);
                        var keyman = this.keyman;
                        // If a touch alias was removed, chances are it's gonna mess up our touch-based layout scheme, so let's update the touch elements.
                        window.setTimeout(function () {
                            this.listInputs();
                            for (var k = 0; k < this.sortedInputs.length; k++) {
                                if (this.sortedInputs[k]['kmw_ip']) {
                                    this.sortedInputs[k]['kmw_ip'].updateInput(this.sortedInputs[k]['kmw_ip']);
                                }
                            }
                        }.bind(this), 1);
                    }
                    else {
                        this.listInputs(); // Fix up our internal input ordering scheme.
                    }
                    this.disableInputElement(Pelem);
                }
            };
            /**
             * Function     _EnableControl
             * Scope        Private
             * @param       {Element}    Pelem   Element to be enabled
             * Description  Enable KMW control element
             */
            DOMManager.prototype._EnableControl = function (Pelem) {
                if (this.isAttached(Pelem)) { // Only operate on attached elements!
                    if (this.keyman.util.device.touchable) {
                        this.enableTouchElement(Pelem);
                        var keyman = this.keyman;
                        // If we just added a new input alias, some languages will mess up our touch-based layout scheme
                        // if we don't update the touch elements.
                        window.setTimeout(function () {
                            keyman.domManager.listInputs();
                            for (var k = 0; k < this.sortedInputs.length; k++) {
                                if (this.sortedInputs[k]['kmw_ip']) {
                                    this.sortedInputs[k]['kmw_ip'].updateInput(this.sortedInputs[k]['kmw_ip']);
                                }
                            }
                        }.bind(this), 1);
                    }
                    else {
                        this.enableInputElement(Pelem);
                    }
                }
            };
            // Create an ordered list of all text and search input elements and textarea elements
            // except any tagged with class 'kmw-disabled'
            // TODO: email and url types should perhaps use default keyboard only
            DOMManager.prototype.listInputs = function () {
                var i, eList = [], t1 = document.getElementsByTagName('input'), t2 = document.getElementsByTagName('textarea');
                var util = this.keyman.util;
                for (i = 0; i < t1.length; i++) {
                    switch (t1[i].type) {
                        case 'text':
                        case 'search':
                        case 'email':
                        case 'url':
                            if (t1[i].className.indexOf('kmw-disabled') < 0) {
                                eList.push({ ip: t1[i], x: keyman_3.dom.Utils.getAbsoluteX(t1[i]), y: keyman_3.dom.Utils.getAbsoluteY(t1[i]) });
                            }
                            break;
                    }
                }
                for (i = 0; i < t2.length; i++) {
                    if (t2[i].className.indexOf('kmw-disabled') < 0)
                        eList.push({ ip: t2[i], x: keyman_3.dom.Utils.getAbsoluteX(t2[i]), y: keyman_3.dom.Utils.getAbsoluteY(t2[i]) });
                }
                /**
                 * Local function to sort by screen position
                 *
                 * @param       {Object}     e1     first object
                 * @param       {Object}     e2     second object
                 * @return      {number}            y-difference between object positions, or x-difference if y values the same
                 */
                var xySort = function (e1, e2) {
                    if (e1.y != e2.y)
                        return e1.y - e2.y;
                    return e1.x - e2.x;
                };
                // Sort elements by Y then X
                eList.sort(xySort);
                // Create a new list of sorted elements
                var tList = [];
                for (i = 0; i < eList.length; i++)
                    tList.push(eList[i].ip);
                // Return the sorted element list
                this.sortedInputs = tList;
            };
            /**
             * Function     disableControl
             * Scope        Public
             * @param       {Element}      Pelem       Element to be disabled
             * Description  Disables a KMW control element
             */
            DOMManager.prototype.disableControl = function (Pelem) {
                if (!this.isAttached(Pelem)) {
                    console.warn("KeymanWeb is not attached to element " + Pelem);
                }
                var cn = Pelem.className;
                if (cn.indexOf('kmw-disabled') < 0) { // if not already explicitly disabled...
                    Pelem.className = cn ? cn + ' kmw-disabled' : 'kmw-disabled';
                }
                // The rest is triggered within MutationObserver code.
                // See _EnablementMutationObserverCore.
            };
            /* ------ Defines independent, per-control keyboard setting behavior for the API. ------ */
            /**
             * Function     setKeyboardForControl
             * Scope        Public
             * @param       {Element}    Pelem    Control element
             * @param       {string|null=}    Pkbd     Keyboard (Clears the set keyboard if set to null.)
             * @param       {string|null=}     Plc      Language Code
             * Description  Set default keyboard for the control
             */
            DOMManager.prototype.setKeyboardForControl = function (Pelem, Pkbd, Plc) {
                /* pass null for kbd to specify no default, or '' to specify the default system keyboard. */
                if (Pkbd !== null && Pkbd !== undefined) {
                    var index = Pkbd.indexOf("Keyboard_");
                    if (index < 0 && Pkbd != '') {
                        Pkbd = "Keyboard_" + Pkbd;
                    }
                }
                else {
                    Plc = null;
                }
                if (Pelem instanceof Pelem.ownerDocument.defaultView.HTMLIFrameElement) {
                    console.warn("'keymanweb.setKeyboardForControl' cannot set keyboard on iframes.");
                    return;
                }
                if (!this.isAttached(Pelem)) {
                    console.error("KeymanWeb is not attached to element " + Pelem);
                    return;
                }
                else {
                    Pelem._kmwAttachment.keyboard = Pkbd;
                    Pelem._kmwAttachment.languageCode = Plc;
                    // If Pelem is the focused element/active control, we should set the keyboard in place now.
                    // 'kmw_ip' is the touch-alias for the original page's control.
                    var lastElem = this.getLastActiveElement();
                    if (lastElem && (lastElem == Pelem || lastElem == Pelem['kmw_ip'])) {
                        if (Pkbd != null && Plc != null) { // Second part necessary for Closure.
                            this.keyman.keyboardManager.setActiveKeyboard(Pkbd, Plc);
                        }
                        else {
                            this.keyman.keyboardManager.setActiveKeyboard(this.keyman.globalKeyboard, this.keyman.globalLanguageCode);
                        }
                    }
                }
            };
            /**
             * Function     getKeyboardForControl
             * Scope        Public
             * @param       {Element}    Pelem    Control element
             * @return      {string|null}         The independently-managed keyboard for the control.
             * Description  Returns the keyboard ID of the current independently-managed keyboard for this control.
             *              If it is currently following the global keyboard setting, returns null instead.
             */
            DOMManager.prototype.getKeyboardForControl = function (Pelem) {
                if (!this.isAttached(Pelem)) {
                    console.error("KeymanWeb is not attached to element " + Pelem);
                    return null;
                }
                else {
                    return Pelem._kmwAttachment.keyboard;
                }
            };
            /**
             * Function     getLanguageForControl
             * Scope        Public
             * @param       {Element}    Pelem    Control element
             * @return      {string|null}         The independently-managed keyboard for the control.
             * Description  Returns the language code used with the current independently-managed keyboard for this control.
             *              If it is currently following the global keyboard setting, returns null instead.
             */
            DOMManager.prototype.getLanguageForControl = function (Pelem) {
                if (!this.isAttached(Pelem)) {
                    console.error("KeymanWeb is not attached to element " + Pelem);
                    return null;
                }
                else {
                    return Pelem._kmwAttachment.languageCode; // Should we have a version for the language code, too?
                }
            };
            /* ------ End independent, per-control keyboard setting behavior definitions. ------ */
            /**
             * Set focus to last active target element (browser-dependent)
             */
            DOMManager.prototype.focusLastActiveElement = function () {
                var lastElem = this.getLastActiveElement();
                if (!lastElem) {
                    return;
                }
                this.keyman.uiManager.justActivated = true;
                if (lastElem.ownerDocument && lastElem instanceof lastElem.ownerDocument.defaultView.HTMLIFrameElement &&
                    this.keyman.domManager._IsMozillaEditableIframe(lastElem, 0)) {
                    lastElem.ownerDocument.defaultView.focus(); // I3363 (Build 301)
                }
                else if (lastElem.focus) {
                    lastElem.focus();
                }
            };
            /**
             * Get the last active target element *before* KMW activated (I1297)
             *
             * @return      {Element}
             */
            DOMManager.prototype.getLastActiveElement = function () {
                return keyman_3.DOMEventHandlers.states.lastActiveElement;
            };
            DOMManager.prototype.clearLastActiveElement = function () {
                keyman_3.DOMEventHandlers.states.lastActiveElement = null;
            };
            DOMManager.prototype.getActiveElement = function () {
                return keyman_3.DOMEventHandlers.states.activeElement;
            };
            DOMManager.prototype._setActiveElement = function (Pelem) {
                keyman_3.DOMEventHandlers.states.activeElement = Pelem;
            };
            /**
             *  Set the active input element directly optionally setting focus
             *
             *  @param  {Object|string} e         element id or element
             *  @param  {boolean=}      setFocus  optionally set focus  (KMEW-123)
             **/
            DOMManager.prototype.setActiveElement = function (e, setFocus) {
                if (typeof (e) == "string") { // Can't instanceof string, and String is a different type.
                    e = document.getElementById(e);
                }
                if (this.keyman.isEmbedded) {
                    // If we're in embedded mode, auto-attach to the element specified by the page.
                    if (!this.isAttached(e)) {
                        this.attachToControl(e);
                    }
                    // Non-attached elements cannot be set as active.
                }
                else if (!this.isAttached(e)) {
                    console.warn("Cannot set an element KMW is not attached to as the active element.");
                    return;
                }
                // As this is an API function, someone may pass in the base of a touch element.
                // We need to respond appropriately.
                e = e['kmw_ip'] ? e['kmw_ip'] : e;
                // If we're changing controls, don't forget to properly manage the keyboard settings!
                // It's only an issue on 'native' (non-embedded) code paths.
                if (!this.keyman.isEmbedded) {
                    this.keyman.touchAliasing._BlurKeyboardSettings();
                }
                // No need to reset context if we stay within the same element.
                if (keyman_3.DOMEventHandlers.states.activeElement != e) {
                    this.keyman.interface.resetContext();
                }
                keyman_3.DOMEventHandlers.states.activeElement = keyman_3.DOMEventHandlers.states.lastActiveElement = e;
                if (!this.keyman.isEmbedded) {
                    this.keyman.touchAliasing._FocusKeyboardSettings(false);
                }
                // Allow external focusing KMEW-123
                if (arguments.length > 1 && setFocus) {
                    if (this.keyman.util.device.touchable) {
                        var tEvent = {
                            clientX: 0,
                            clientY: 0,
                            target: e
                        };
                        // Kinda hacky, but gets the job done.
                        this.keyman.touchAliasing.setFocusWithTouch(tEvent);
                    }
                    else {
                        this.focusLastActiveElement();
                    }
                }
            };
            /** Sets the active input element only if it is presently null.
             *
             * @param  {Element}
             */
            DOMManager.prototype.initActiveElement = function (Lelem) {
                if (keyman_3.DOMEventHandlers.states.activeElement == null) {
                    keyman_3.DOMEventHandlers.states.activeElement = Lelem;
                }
            };
            /**
             * Move focus to next (or previous) input or text area element on TAB
             *   Uses list of actual input elements
             *
             *   Note that activeElement() on touch devices returns the DIV that overlays
             *   the input element, not the element itself.
             *
             * @param      {number|boolean}  bBack     Direction to move (0 or 1)
             */
            DOMManager.prototype.moveToNext = function (bBack) {
                var i, t = this.sortedInputs, activeBase = this.getActiveElement();
                var touchable = this.keyman.util.device.touchable;
                if (t.length == 0) {
                    return;
                }
                // For touchable devices, get the base element of the DIV
                if (touchable) {
                    activeBase = activeBase.base;
                }
                // Identify the active element in the list of inputs ordered by position
                for (i = 0; i < t.length; i++) {
                    if (t[i] == activeBase)
                        break;
                }
                // Find the next (or previous) element in the list
                i = bBack ? i - 1 : i + 1;
                // Treat the list as circular, wrapping the index if necessary.
                i = i >= t.length ? i - t.length : i;
                i = i < 0 ? i + t.length : i;
                // Move to the selected element
                if (touchable) {
                    // Set focusing flag to prevent OSK disappearing 
                    keyman_3.DOMEventHandlers.states.focusing = true;
                    var target = t[i]['kmw_ip'];
                    // Focus if next element is non-mapped
                    if (typeof (target) == 'undefined') {
                        t[i].focus();
                    }
                    else { // Or reposition the caret on the input DIV if mapped
                        var alias = target;
                        this.keyman.domManager.setActiveElement(target); // Handles both `lastActive` + `active`.
                        alias.setTextCaret(10000); // Safe b/c touchable == true.
                        alias.scrollInput(); // mousedown check
                        target.focus();
                    }
                }
                else { // Behaviour for desktop browsers
                    t[i].focus();
                }
            };
            /**
             * Move focus to user-specified element
             *
             *  @param  {string|Object}   e   element or element id
             *
             **/
            DOMManager.prototype.moveToElement = function (e) {
                var i;
                if (typeof (e) == "string") { // Can't instanceof string, and String is a different type.
                    e = document.getElementById(e);
                }
                if (this.keyman.util.device.touchable && e['kmw_ip']) {
                    e['kmw_ip'].focus();
                }
                else {
                    e.focus();
                }
            };
            /* ----------------------- Editable IFrame methods ------------------- */
            /**
             * Function     _IsIEEditableIframe
             * Scope        Private
             * @param       {Object}          Pelem         Iframe element
             *              {boolean|number}  PtestOn       1 to test if frame content is editable (TODO: unclear exactly what this is doing!)
             * @return      {boolean}
             * Description  Test if element is an IE editable IFrame
             */
            DOMManager.prototype._IsIEEditableIframe = function (Pelem, PtestOn) {
                var Ldv, Lvalid = Pelem && (Ldv = Pelem.tagName) && Ldv.toLowerCase() == 'body' && (Ldv = Pelem.ownerDocument) && Ldv.parentWindow;
                return (!PtestOn && Lvalid) || (PtestOn && (!Lvalid || Pelem.isContentEditable));
            };
            /**
             * Function     _IsMozillaEditableIframe
             * Scope        Private
             * @param       {Object}           Pelem    Iframe element
             * @param       {boolean|number}   PtestOn  1 to test if 'designMode' is 'ON'
             * @return      {boolean}
             * Description  Test if element is a Mozilla editable IFrame
             */
            DOMManager.prototype._IsMozillaEditableIframe = function (Pelem, PtestOn) {
                var Ldv, Lvalid = Pelem && (Ldv = Pelem.defaultView) && Ldv.frameElement; // Probable bug!
                return (!PtestOn && Lvalid) || (PtestOn && (!Lvalid || Ldv.document.designMode.toLowerCase() == 'on'));
            };
            /* ----------------------- Initialization methods ------------------ */
            /**
             * Get the user-specified (or default) font for the first mapped input or textarea element
             * before applying any keymanweb styles or classes
             *
             *  @return   {string}
             **/
            DOMManager.prototype.getBaseFont = function () {
                var util = this.keyman.util;
                var ipInput = document.getElementsByTagName('input'), ipTextArea = document.getElementsByTagName('textarea'), n = 0, fs, fsDefault = 'Arial,sans-serif';
                // Find the first input element (if it exists)
                if (ipInput.length == 0 && ipTextArea.length == 0) {
                    n = 0;
                }
                else if (ipInput.length > 0 && ipTextArea.length == 0) {
                    n = 1;
                }
                else if (ipInput.length == 0 && ipTextArea.length > 0) {
                    n = 2;
                }
                else {
                    var firstInput = ipInput[0];
                    var firstTextArea = ipTextArea[0];
                    if (firstInput.offsetTop < firstTextArea.offsetTop) {
                        n = 1;
                    }
                    else if (firstInput.offsetTop > firstTextArea.offsetTop) {
                        n = 2;
                    }
                    else if (firstInput.offsetLeft < firstTextArea.offsetLeft) {
                        n = 1;
                    }
                    else if (firstInput.offsetLeft > firstTextArea.offsetLeft) {
                        n = 2;
                    }
                }
                // Grab that font!
                switch (n) {
                    case 0:
                        fs = fsDefault;
                    case 1:
                        fs = util.getStyleValue(ipInput[0], 'font-family');
                    case 2:
                        fs = util.getStyleValue(ipTextArea[0], 'font-family');
                }
                if (typeof (fs) == 'undefined' || fs == 'monospace') {
                    fs = fsDefault;
                }
                return fs;
            };
            /**
             * Initialize the desktop user interface as soon as it is ready
            **/
            DOMManager.prototype.initializeUI = function () {
                if (this.keyman.ui && this.keyman.ui['initialize'] instanceof Function) {
                    this.keyman.ui['initialize']();
                    // Display the OSK (again) if enabled, in order to set its position correctly after
                    // adding the UI to the page 
                    this.keyman.osk._Show();
                }
                else if (this.keyman.isEmbedded) {
                    // UI modules aren't utilized in embedded mode.  There's nothing to init, so we simply
                    // return instead of waiting for a UI module that will never come.
                    return;
                }
                else {
                    window.setTimeout(this.initializeUI.bind(this), 1000);
                }
            };
            DOMManager.suppressFocusCheck = function (e) {
                if (keyman_3.DOMEventHandlers.states._IgnoreBlurFocus) {
                    // Prevent triggering other blur-handling events (as possible)
                    e.stopPropagation();
                    e.cancelBubble = true;
                }
                // But DO perform default event behavior (actually blurring & focusing the affected element)
                return true;
            };
            return DOMManager;
        }());
        keyman_3.DOMManager = DOMManager;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Includes KMW-added property declaration extensions for HTML elements.
/// <reference path="kmwexthtml.ts" />
// Includes the Device definition set.
/// <reference path="kmwdevice.ts" />
// Includes the DOM utils, since our UI modules need access to certain methods here.
/// <reference path="dom/utils.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_4) {
        var DOMEventTracking = /** @class */ (function () {
            function DOMEventTracking(Pelem, Peventname, Phandler, PuseCapture) {
                this.Pelem = Pelem;
                this.Peventname = Peventname.toLowerCase();
                this.Phandler = Phandler;
                this.PuseCapture = PuseCapture;
            }
            DOMEventTracking.prototype.equals = function (other) {
                return this.Pelem == other.Pelem && this.Peventname == other.Peventname &&
                    this.Phandler == other.Phandler && this.PuseCapture == other.PuseCapture;
            };
            return DOMEventTracking;
        }());
        ;
        var Util = /** @class */ (function () {
            function Util(keyman) {
                this.linkedStylesheets = [];
                // An object mapping event names to individual event lists.  Maps strings to arrays.
                this.events = {};
                this.currentEvents = []; // The event messaging call stack.
                this.domEvents = [];
                this.embeddedFonts = []; // Array of currently embedded font descriptor entries.  (Is it just a string?)
                //  Unofficial API used by our desktop UIs.
                this._GetAbsolute = this.getAbsolute;
                /**
                 * Select start handler (to replace multiple inline handlers) (Build 360)
                 */
                this.selectStartHandler = function () {
                    return false;
                };
                /**
             * Function     _CancelMouse
             * Scope        Private
             * @param       {Object}      e     event
             * @return      {boolean}           always false
             * Description  Closes mouse click event
             */
                this._CancelMouse = function (e) {
                    e = com.keyman.singleton._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                    if (e && e.preventDefault) {
                        e.preventDefault();
                    }
                    if (e) {
                        e.cancelBubble = true;
                        e.returnValue = false;
                    } // I2409 - Avoid focus loss for visual keyboard events
                    return false;
                };
                this.createElement = this._CreateElement;
                this.initDevices();
                this.keyman = keyman;
            }
            // Possible alternative:  https://www.npmjs.com/package/language-tags
            // This would necessitate linking in a npm module into compiled KeymanWeb, though.
            Util.prototype['getLanguageCodes'] = function (lgCode) {
                if (lgCode.indexOf('-') == -1) {
                    return [lgCode];
                }
                else {
                    return lgCode.split('-');
                }
            };
            Util.prototype.initDevices = function () {
                this.device = new keyman_4.Device();
                this.physicalDevice = new keyman_4.Device();
                this.activeDevice = this.device;
                // Initialize the true device values.
                this.device.detect();
                /* DEBUG: Force touch device   (Build 360)
          
                device.touchable = true;
                device.browser = 'safari';
                device.formFactor = 'tablet';
                device.OS = 'iOS';
          
                END DEBUG */
                /* If we've made it to this point of initialization and aren't anything else, KeymanWeb assumes
                * we're a desktop.  Since we don't yet support desktops with touch-based input, we disable it here.
                */
                if (this.device.formFactor == 'desktop') {
                    this.device.touchable = false;
                }
                /**
                 * Represents hardware-based keystrokes regardless of the 'true' device, facilitating hardware keyboard input
                 * whenever touch-based input is available.
                 */
                this.physicalDevice = new keyman_4.Device();
                this.physicalDevice.touchable = false;
                this.physicalDevice.browser = this.device.browser;
                this.physicalDevice.formFactor = 'desktop';
                this.physicalDevice.OS = this.device.OS;
            };
            /**
             * Function     arrayFromNodeList
             * Scope        Public
             * @param       {Object}    nl a node list, as returned from getElementsBy_____ methods.
             * Description  Transforms a node list into an array.   *
             * @return      {Array<Element>}
             */
            Util.prototype.arrayFromNodeList = function (nl) {
                var res = [];
                for (var i = 0; i < nl.length; i++) {
                    res.push(nl[i]);
                }
                return res;
            };
            /**
             * Function    addEventListener
             * Scope       Private
             * @param      {string}     event     name of event prefixed by module, e.g. osk.touchmove
             * @param      {function(Object)}   func      event handler
             * @return     {boolean}
             * Description Add (or replace) an event listener for this component
             */
            Util.prototype.addEventListener = function (event, func) {
                this.removeEventListener(event, func);
                this.events[event].push(func);
                return true;
            };
            /**
             * Function    removeEventListener
             * Scope       Private
             * @param      {string}     event     name of event prefixed by module, e.g. osk.touchmove
             * @param      {function(Object)}   func      event handler
             * @return     {boolean}
             * Description Remove the specified function from the listeners for this event
             */
            Util.prototype.removeEventListener = function (event, func) {
                if (typeof this.events[event] == 'undefined') {
                    this.events[event] = [];
                }
                for (var i = 0; i < this.events[event].length; i++) {
                    if (this.events[event][i] == func) {
                        this.events[event].splice(i, 1);
                        return true;
                    }
                }
                return false;
            };
            /**
             * Function    callEvent
             * Scope       Private
             * @param      {string}     event     name of event prefixed by module, e.g. osk.touchmove
             * @param      {Array}      params    parameter array for function
             * @return     {boolean}
             * Description Invoke an event using any function with up to four arguments
             */
            Util.prototype.callEvent = function (event, params) {
                if (typeof this.events[event] == 'undefined') {
                    return true;
                }
                if (this.currentEvents.indexOf(event) != -1) {
                    return false; // Avoid event messaging recursion!
                }
                this.currentEvents.push(event);
                for (var i = 0; i < this.events[event].length; i++) {
                    var func = this.events[event][i], result = false;
                    try {
                        result = func(params);
                    }
                    catch (strExcept) {
                        console.error(strExcept);
                        result = false;
                    } //don't know whether to use true or false here
                    if (result === false) {
                        this.currentEvents.pop();
                        return false;
                    }
                }
                this.currentEvents.pop();
                return true;
            };
            /**
             * Function     attachDOMEvent: Note for most browsers, adds an event to a chain, doesn't stop existing events
             * Scope        Public
             * @param       {Object}    Pelem       Element (or IFrame-internal Document) to which event is being attached
             * @param       {string}    Peventname  Name of event without 'on' prefix
             * @param       {function(Object)}  Phandler    Event handler for event
             * @param       {boolean=}  PuseCapture True only if event to be handled on way to target element
             * Description  Attaches event handler to element DOM event
             */
            Util.prototype.attachDOMEvent = function (Pelem, Peventname, Phandler, PuseCapture) {
                this.detachDOMEvent(Pelem, Peventname, Phandler, PuseCapture);
                Pelem.addEventListener(Peventname, Phandler, PuseCapture ? true : false);
                // Since we're attaching to the DOM, these events should be tracked for detachment during shutdown.
                var event = new DOMEventTracking(Pelem, Peventname, Phandler, PuseCapture);
                this.domEvents.push(event);
            };
            /**
             * Function     detachDOMEvent
             * Scope        Public
             * @param       {Object}    Pelem       Element from which event is being detached
             * @param       {string}    Peventname  Name of event without 'on' prefix
             * @param       {function(Object)}  Phandler    Event handler for event
             * @param       {boolean=}  PuseCapture True if event was being handled on way to target element
             * Description Detaches event handler from element [to prevent memory leaks]
             */
            Util.prototype.detachDOMEvent = function (Pelem, Peventname, Phandler, PuseCapture) {
                Pelem.removeEventListener(Peventname, Phandler, PuseCapture);
                // Since we're detaching, we should drop the tracking data from the old event.
                var event = new DOMEventTracking(Pelem, Peventname, Phandler, PuseCapture);
                for (var i = 0; i < this.domEvents.length; i++) {
                    if (this.domEvents[i].equals(event)) {
                        this.domEvents.splice(i, 1);
                        break;
                    }
                }
            };
            /**
             * Function     getOption
             * Scope        Public
             * @param       {string}    optionName  Name of option
             * @param       {*=}        dflt        Default value of option
             * @return      {*}
             * Description  Returns value of named option
             */
            Util.prototype.getOption = function (optionName, dflt) {
                if (optionName in this.keyman.options) {
                    return this.keyman.options[optionName];
                }
                else if (arguments.length > 1) {
                    return dflt;
                }
                else {
                    return '';
                }
            };
            /**
             * More reliable way of identifying  element class
             * @param   {Object}  e HTML element
             * @param   {string}  name  class name
             * @return  {boolean}
             */
            Util.prototype.hasClass = function (e, name) {
                var className = " " + name + " ";
                return (" " + e.className + " ").replace(/[\n\t\r\f]/g, " ").indexOf(className) >= 0;
            };
            /**
             * Function     setOption
             * Scope        Public
             * @param       {string}    optionName  Name of option
             * @param       {*=}        value       Value of option
             * Description  Sets value of named option
             */
            Util.prototype.setOption = function (optionName, value) {
                this.keyman.options[optionName] = value;
            };
            //  Unofficial API used by our desktop UIs.
            Util.prototype.getAbsoluteX = function (Pobj) {
                return keyman_4.dom.Utils.getAbsoluteX(Pobj);
            };
            //  Unofficial API used by our desktop UIs.
            Util.prototype.getAbsoluteY = function (Pobj) {
                return keyman_4.dom.Utils.getAbsoluteY(Pobj);
            };
            /**
             * Function     getAbsolute
             * Scope        Public
             * @param       {Object}    Pobj        HTML element
             * @return      {Object.<string,number>}
             * Description  Returns absolute position of Pobj element with respect to page
             */
            Util.prototype.getAbsolute = function (Pobj) {
                var p = {
                    /* @ export */
                    x: this.getAbsoluteX(Pobj),
                    /* @ export */
                    y: this.getAbsoluteY(Pobj)
                };
                return p;
            };
            /**
             * Default mouse down event handler (to replace multiple inline handlers) (Build 360)
             */
            Util.prototype.mouseDownPreventDefaultHandler = function (e) {
                if (e) {
                    e.preventDefault();
                }
            };
            // Found a bit of magic formatting that allows dynamic return typing for a specified element tag!
            Util.prototype._CreateElement = function (nodeName) {
                var e = document.createElement(nodeName);
                // Make element unselectable (Internet Explorer)
                if (typeof e.onselectstart != 'undefined') { //IE route
                    e.onselectstart = this.selectStartHandler; // Build 360
                }
                else { // And for well-behaved browsers (may also work for IE9+, but not necessary)
                    e.style.MozUserSelect = "none";
                    e.style.KhtmlUserSelect = "none";
                    e.style.UserSelect = "none";
                    e.style.WebkitUserSelect = "none";
                }
                return e;
            };
            /**
             * Function     getIEVersion
             * Scope        Public
             * @return      {number}
             * Description  Return IE version number (or 999 if browser not IE)
             */
            Util.prototype.getIEVersion = function () {
                return keyman_4.Device._GetIEVersion();
            };
            Util.prototype.getFontSizeStyle = function (e) {
                var val;
                var fs;
                if (typeof e == 'string') {
                    fs = e;
                }
                else {
                    fs = e.style.fontSize;
                }
                if (fs.indexOf('em') != -1) {
                    val = parseFloat(fs.substr(0, fs.indexOf('em')));
                    return { val: val, absolute: false };
                }
                else if (fs.indexOf('px') != -1) {
                    val = parseFloat(fs.substr(0, fs.indexOf('px')));
                    return { val: val, absolute: true };
                }
                else if (fs.indexOf('pt') != -1) {
                    // 16 px ~= 12 pt.
                    // Reference: https://kyleschaeffer.com/css-font-size-em-vs-px-vs-pt-vs-percent
                    val = parseFloat(fs.substr(0, fs.indexOf('pt')));
                    return { val: (4 * val / 3), absolute: true };
                }
                else if (fs.indexOf('%') != -1) {
                    val = parseFloat(fs.substr(0, fs.indexOf('%')));
                    return { val: val / 100, absolute: false };
                }
                else if (!isNaN(val = Number(fs))) {
                    // Note:  this one is NOT natively handled by browsers!
                    //        We'll treat it as if it were 'pt', since that's likely the user's
                    //        most familiar font size unit.
                    return { val: (4 * val / 3), absolute: true };
                }
                else {
                    // Cannot parse.
                    console.error("Could not properly parse specified fontsize info: '" + fs + "'.");
                    return null;
                }
            };
            /**
             * Get browser-independent computed style value for element
             *
             * @param       {Element}     e             HTML element
             * @param       {string}      s             CSS style name
             * @return      {*}
             */
            Util.prototype.getStyleValue = function (e, s) {
                // Build 349: error trap added, since on iOS, getPropertyValue may fail
                // and crash in some cases, possibly if passed a text node
                try {
                    if (e && (typeof (window.getComputedStyle) != 'undefined')) {
                        return window.getComputedStyle(e, '').getPropertyValue(s);
                    }
                }
                catch (ex) { }
                // Return empty string if unable to get style value
                return '';
            };
            /**
             * Get browser-independent computed style integer value for element  (Build 349)
             *
             * @param       {Element}     e             HTML element
             * @param       {string}      s             CSS style name
             * @param       {number=}     d             default value if NaN
             * @return      {number}                    integer value of style
             */
            Util.prototype.getStyleInt = function (e, s, d) {
                var x = parseInt(this.getStyleValue(e, s), 10);
                if (!isNaN(x)) {
                    return x;
                }
                // Return the default value if numeric, else 0
                if (typeof (d) == 'number') {
                    return d;
                }
                else {
                    return 0;
                }
            };
            /**
             * Expose the touchable state for UIs - will disable external UIs entirely
             **/
            Util.prototype.isTouchDevice = function () {
                return this.device.touchable;
            };
            /**
             * Get orientation of tablet or phone  display
             *
             * @return      {boolean}
             */
            Util.prototype.portraitView = function () {
                return !this.landscapeView();
            };
            /**
             * Get orientation of tablet or phone  display
             *
             * @return      {boolean}
             */
            Util.prototype.landscapeView = function () {
                var orientation;
                // Assume portrait mode if orientation undefined
                if (typeof window.orientation != 'undefined') { // Used by iOS Safari
                    // Else landscape for +/-90, portrait for 0, +/-180
                    orientation = window.orientation;
                }
                else if (typeof window.screen.orientation != 'undefined') { // Used by Firefox, Chrome
                    orientation = window.screen.orientation.angle;
                }
                if (orientation !== undefined) {
                    return (Math.abs(orientation / 90) == 1);
                }
                else {
                    return false;
                }
            };
            /**
             * Get viewport scale factor for this document
             *
             * @return      {number}
             */
            Util.prototype.getViewportScale = function () {
                // This can sometimes fail with some browsers if called before document defined,
                // so catch the exception
                try {
                    // Get viewport width
                    var viewportWidth = document.documentElement.clientWidth;
                    // Return a default value if screen width is greater than the viewport width (not fullscreen).
                    if (screen.width > viewportWidth) {
                        return 1;
                    }
                    // Get the orientation corrected screen width
                    var screenWidth = screen.width;
                    if (this.landscapeView()) {
                        // Take larger of the two dimensions
                        if (screen.width < screen.height) {
                            screenWidth = screen.height;
                        }
                    }
                    else {
                        // Take smaller of the two dimensions
                        if (screen.width > screen.height) {
                            screenWidth = screen.height;
                        }
                    }
                    // Calculate viewport scale
                    return Math.round(100 * screenWidth / window.innerWidth) / 100;
                }
                catch (ex) {
                    return 1;
                }
            };
            /**
             * Return height of URL bar on mobile devices, if visible
             * TODO: This does not seem to be right, so is not currently used
             *
             * @return      {number}
             */
            Util.prototype.barHeight = function () {
                var dy = 0;
                if (this.device.formFactor == 'phone') {
                    dy = screen.height / 2 - window.innerHeight - (this.landscapeView() ? this.device.dyLandscape : this.device.dyPortrait);
                }
                return dy;
            };
            /**
             * Function     _EncodeEntities
             * Scope        Private
             * @param       {string}      P_txt         string to be encoded
             * @return      {string}                    encoded (html-safe) string
             * Description Encode angle brackets and ampersand in text string
             */
            Util.prototype._EncodeEntities = function (P_txt) {
                return P_txt.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;'); // I1452 part 2
            };
            /**
             * Function     createShim
             * Scope        Public
             * Description  [Deprecated] Create an IFRAME element to go between KMW and drop down (to fix IE6 bug)
             * @deprecated
             */
            Util.prototype.createShim = function () {
                console.warn("The util.createShim function is deprecated, as its old functionality is no longer needed.  " +
                    "It and references to its previously-produced shims may be safely removed.");
                return;
            };
            // I1476 - Handle SELECT overlapping BEGIN
            /**
             * Function     showShim
             * Scope        Public
             * @param       {Object}      Pvkbd         Visual keyboard DIV element
             * @param       {Object}      Pframe        IFRAME shim element
             * @param       {Object}      Phelp         OSK Help DIV element
             * Description  [Deprecated] Display iFrame under OSK at its currently defined position, to allow OSK to overlap SELECT elements (IE6 fix)
             * @deprecated
             */
            Util.prototype.showShim = function (Pvkbd, Pframe, Phelp) {
                console.warn("The util.showShim function is deprecated, as its old functionality is no longer needed.  It may be safely removed.");
            };
            /**
             * Function     hideShim
             * Scope        Public
             * @param       {Object}      Pframe        IFRAME shim element
             * Description  [Deprecated] Hide iFrame shim containing OSK
             * @deprecated
             */
            Util.prototype.hideShim = function (Pframe) {
                console.warn("The util.hideShim function is deprecated, as its old functionality is no longer needed.  It may be safely removed.");
            };
            /**
             * Function     rgba
             * Scope        Public
             * @param       {Object}      s           element style object
             * @param       {number}      r           red value, 0-255
             * @param       {number}      g           green value, 0-255
             * @param       {number}      b           blue value, 0-255
             * @param       {number}      a           opacity value, 0-1.0
             * @return      {string}                  background colour style string
             * Description  Browser-independent alpha-channel management
             */
            Util.prototype.rgba = function (s, r, g, b, a) {
                var bgColor = 'transparent';
                try {
                    bgColor = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
                }
                catch (ex) {
                    bgColor = 'rgb(' + r + ',' + g + ',' + b + ')';
                }
                return bgColor;
            };
            /**
             * Add a stylesheet to a page programmatically, for use by the OSK, the UI or the page creator
             *
             * @param       {string}        s             style string
             * @return      {Object}                      returns the object reference
             **/
            Util.prototype.addStyleSheet = function (s) {
                var _ElemStyle = document.createElement('style');
                _ElemStyle.type = 'text/css';
                _ElemStyle.appendChild(document.createTextNode(s));
                var _ElemHead = document.getElementsByTagName('HEAD');
                if (_ElemHead.length > 0) {
                    _ElemHead[0].appendChild(_ElemStyle);
                }
                else {
                    document.body.appendChild(_ElemStyle); // Won't work on Chrome, ah well
                }
                this.linkedStylesheets.push(_ElemStyle);
                return _ElemStyle;
            };
            /**
             * Remove a stylesheet element
             *
             * @param       {Object}        s             style sheet reference
             * @return      {boolean}                     false if element is not a style sheet
             **/
            Util.prototype.removeStyleSheet = function (s) {
                if (s == null || typeof (s) != 'object') {
                    return false;
                }
                if (s.nodeName != 'STYLE') {
                    return false;
                }
                if (typeof (s.parentNode) == 'undefined' || s.parentNode == null) {
                    return false;
                }
                s.parentNode.removeChild(s);
                return true;
            };
            /**
             * Add a reference to an external stylesheet file
             *
             * @param   {string}  s   path to stylesheet file
             */
            Util.prototype.linkStyleSheet = function (s) {
                var headElements = document.getElementsByTagName('head');
                if (headElements.length > 0) {
                    var linkElement = document.createElement('link');
                    linkElement.type = 'text/css';
                    linkElement.rel = 'stylesheet';
                    linkElement.href = s;
                    this.linkedStylesheets.push(linkElement);
                    headElements[0].appendChild(linkElement);
                }
            };
            /**
             * Add a stylesheet with a font-face CSS descriptor for the embedded font appropriate
             * for the browser being used
             *
             * @param    {Object}  fd  keymanweb font descriptor
             **/
            Util.prototype.addFontFaceStyleSheet = function (fd) {
                // Test if a valid font descriptor
                if (typeof (fd) == 'undefined')
                    return;
                if (typeof (fd['files']) == 'undefined')
                    fd['files'] = fd['source'];
                if (typeof (fd['files']) == 'undefined')
                    return;
                var i, ttf = '', woff = '', eot = '', svg = '', fList = [];
                // TODO: 22 Aug 2014: check that font path passed from cloud is actually used!
                // Do not add a new font-face style sheet if already added for this font
                for (i = 0; i < this.embeddedFonts.length; i++) {
                    if (this.embeddedFonts[i] == fd['family']) {
                        return;
                    }
                }
                if (typeof (fd['files']) == 'string') {
                    fList[0] = fd['files'];
                }
                else {
                    fList = fd['files'];
                }
                for (i = 0; i < fList.length; i++) {
                    if (fList[i].toLowerCase().indexOf('.otf') > 0)
                        ttf = fList[i];
                    if (fList[i].toLowerCase().indexOf('.ttf') > 0)
                        ttf = fList[i];
                    if (fList[i].toLowerCase().indexOf('.woff') > 0)
                        woff = fList[i];
                    if (fList[i].toLowerCase().indexOf('.eot') > 0)
                        eot = fList[i];
                    if (fList[i].toLowerCase().indexOf('.svg') > 0)
                        svg = fList[i];
                }
                // Font path qualified to support page-relative fonts (build 347)
                if (ttf != '' && (ttf.indexOf('/') < 0)) {
                    ttf = this.keyman.options['fonts'] + ttf;
                }
                if (woff != '' && (woff.indexOf('/') < 0)) {
                    woff = this.keyman.options['fonts'] + woff;
                }
                if (eot != '' && (eot.indexOf('/') < 0)) {
                    eot = this.keyman.options['fonts'] + eot;
                }
                if (svg != '' && (svg.indexOf('/') < 0)) {
                    svg = this.keyman.options['fonts'] + svg;
                }
                // Build the font-face definition according to the browser being used
                var s = '@font-face {\nfont-family:'
                    + fd['family'] + ';\nfont-style:normal;\nfont-weight:normal;\n';
                // Detect if Internet Explorer and version if so
                var IE = keyman_4.Device._GetIEVersion();
                // Build the font source string according to the browser,
                // but return without adding the style sheet if the required font type is unavailable
                // Modern browsers: use WOFF, TTF and fallback finally to SVG. Don't provide EOT
                if (IE >= 9) {
                    if (this.device.OS == 'iOS') {
                        if (ttf != '') {
                            // Modify the url if required to prevent caching
                            ttf = this.unCached(ttf);
                            s = s + 'src:url(\'' + ttf + '\') format(\'truetype\');';
                        }
                        else {
                            return;
                        }
                    }
                    else {
                        var s0 = [];
                        if (this.device.OS == 'Android') {
                            // Android 4.2 and 4.3 have bugs in their rendering for some scripts
                            // with embedded ttf or woff.  svg mostly works so is a better initial
                            // choice on the Android browser.
                            if (svg != '') {
                                s0.push("url('" + svg + "') format('svg')");
                            }
                            if (woff != '') {
                                s0.push("url('" + woff + "') format('woff')");
                            }
                            if (ttf != '') {
                                s0.push("url('" + ttf + "') format('truetype')");
                            }
                        }
                        else {
                            if (woff != '') {
                                s0.push("url('" + woff + "') format('woff')");
                            }
                            if (ttf != '') {
                                s0.push("url('" + ttf + "') format('truetype')");
                            }
                            if (svg != '') {
                                s0.push("url('" + svg + "') format('svg')");
                            }
                        }
                        if (s0.length == 0) {
                            return;
                        }
                        s += 'src:' + s0.join(',') + ';';
                    }
                }
                else { // IE 6-8
                    if (eot != '') {
                        s = s + 'src:url(\'' + eot + '\');';
                    }
                    else {
                        return;
                    }
                }
                s = s + '\n}\n';
                this.addStyleSheet(s);
                this.embeddedFonts.push(fd['family']);
            };
            /**
             * Allow forced reload if necessary (stub only here)
             *
             *  @param  {string}  s unmodified URL
             *  @return {string}    modified URL
             */
            Util.prototype.unCached = function (s) {
                // var t=(new Date().getTime());
                // s = s + '?v=' + t;
                return s;
            };
            /**
             * Document cookie parsing for use by kernel, OSK, UI etc.
             *
             * @param       {string=}       cn        cookie name (optional)
             * @return      {Object}                  array of names and strings, or array of variables and values
             */
            Util.prototype.loadCookie = function (cn) {
                var v = {};
                if (arguments.length > 0) {
                    var cx = this.loadCookie();
                    for (var t in cx) {
                        if (t == cn) {
                            var d = decodeURIComponent(cx[t]).split(';');
                            for (var i = 0; i < d.length; i++) {
                                var xc = d[i].split('=');
                                if (xc.length > 1) {
                                    v[xc[0]] = xc[1];
                                }
                                else {
                                    v[xc[0]] = '';
                                }
                            }
                        }
                    }
                }
                else {
                    if (typeof (document.cookie) != 'undefined' && document.cookie != '') {
                        var c = document.cookie.split(/;\s*/);
                        for (var i = 0; i < c.length; i++) {
                            var d = c[i].split('=');
                            if (d.length == 2) {
                                v[d[0]] = d[1];
                            }
                        }
                    }
                }
                return v;
            };
            /**
             * Standard cookie saving for use by kernel, OSK, UI etc.
             *
             * @param       {string}      cn            name of cookie
             * @param       {Object}      cv            object with array of named arguments and values
             */
            Util.prototype.saveCookie = function (cn, cv) {
                var s = '';
                for (var v in cv) {
                    s = s + v + '=' + cv[v] + ";";
                }
                var d = new Date(new Date().valueOf() + 1000 * 60 * 60 * 24 * 30).toUTCString();
                document.cookie = cn + '=' + encodeURIComponent(s) + '; path=/; expires=' + d; //Fri, 31 Dec 2099 23:59:59 GMT;';
            };
            /**
             * Function     toNumber
             * Scope        Public
             * @param       {string}      s            numeric string
             * @param       {number}      dflt         default value
             * @return      {number}
             * Description  Return string converted to integer or default value
             */
            Util.prototype.toNumber = function (s, dflt) {
                var x = parseInt(s, 10);
                return isNaN(x) ? dflt : x;
            };
            /**
             * Function     toNumber
             * Scope        Public
             * @param       {string}      s            numeric string
             * @param       {number}      dflt         default value
             * @return      {number}
             * Description  Return string converted to real value or default value
             */
            Util.prototype.toFloat = function (s, dflt) {
                var x = parseFloat(s);
                return isNaN(x) ? dflt : x;
            };
            /**
             * Function     toNzString
             * Scope        Public
             * @param       {*}           item         variable to test
             * @param       {?*=}         dflt         default value
             * @return      {*}
             * Description  Test if a variable is null, false, empty string, or undefined, and return as string
             */
            Util.prototype.nzString = function (item, dflt) {
                var dfltValue = '';
                if (arguments.length > 1) {
                    dfltValue = dflt;
                }
                if (typeof (item) == 'undefined') {
                    return dfltValue;
                }
                if (item == null) {
                    return dfltValue;
                }
                if (item == 0 || item == '') {
                    return dfltValue;
                }
                return '' + item;
            };
            /**
             * Function     deepCopy
             * Scope        Private
             * @param       {Object}      p           object to copy
             * @param       {Array=}      c0          array member being copied
             * @return      {Object}                  clone ('deep copy') of object
             * Description  Makes an actual copy (not a reference) of an object, copying simple members,
             *              arrays and member objects but not functions, so use with care!
             */
            Util.prototype.deepCopy = function (p, c0) {
                var c = c0 || {};
                for (var i in p) {
                    if (typeof p[i] === 'object') {
                        c[i] = (p[i].constructor === Array) ? [] : {};
                        this.deepCopy(p[i], c[i]);
                    }
                    else {
                        c[i] = p[i];
                    }
                }
                return c;
            };
            /**
             * Return the event target for any browser
             *
             * @param       {Event}      e        event
             * @return      {Object}              HTML element
             */
            Util.prototype.eventTarget = function (e) {
                if (!e) {
                    return null;
                }
                else if (e.target) { // most browsers
                    return e.target;
                }
                else if (e.srcElement) {
                    return e.srcElement;
                }
                else if (window.event) { //IE 8 (and earlier)
                    return window.event.srcElement;
                }
                else {
                    return null; // shouldn't happen!
                }
            };
            /**
             * Return the event type for any browser
             *
             * @param       {Event}      e        event
             * @return      {string}              type of event
             */
            Util.prototype.eventType = function (e) {
                if (e && e.type) { // most browsers
                    return e.type;
                }
                else if (window.event) { // IE 8 (and earlier)
                    return window.event.type;
                }
                else {
                    return ''; // shouldn't happen!
                }
            };
            /**
             * Customized alert
             *
             * @param     {string}        s       alert text
             * @param     {function()=}   fn      function to call when alert dismissed
             */
            Util.prototype.alert = function (s, fn) {
                var bg = this.waiting, nn = bg.firstChild.childNodes;
                nn[0].style.display = 'block';
                nn[1].className = 'kmw-alert-text';
                nn[1].innerHTML = s;
                nn[2].style.display = 'none';
                bg.style.display = 'block';
                if (arguments.length > 1) {
                    bg.dismiss = fn;
                }
                else {
                    bg.dismiss = null;
                }
            };
            // Stub definition to be fleshed out depending upon native/embedded mode.
            Util.prototype.wait = function (s) {
            };
            /**
             *  Prepare the background and keyboard loading wait message box
             *  Should not be called before options are defined during initialization
             **/
            Util.prototype.prepareWait = function () {
                var bg = document.createElement('DIV'), lb = document.createElement('DIV'), lt = document.createElement('DIV'), gr = document.createElement('DIV'), bx = document.createElement('DIV');
                bg.className = 'kmw-wait-background';
                lb.className = 'kmw-wait-box';
                bg.dismiss = null;
                lt.className = 'kmw-wait-text';
                gr.className = 'kmw-wait-graphic';
                bx.className = 'kmw-alert-close';
                // Close alert if anywhere in box is touched, since close box is too small on mobiles
                lb.onmousedown = lb.onclick = function (e) {
                    // Ignore if waiting, only handle for alert
                    if (bx.style.display == 'block') {
                        bg.style.display = 'none';
                        if (bg.dismiss) {
                            bg.dismiss();
                        }
                    }
                };
                lb.addEventListener('touchstart', lb.onclick, false);
                bg.onmousedown = bg.onclick = function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                };
                bg.addEventListener('touchstart', bg.onclick, false);
                lb.appendChild(bx);
                lb.appendChild(lt);
                lb.appendChild(gr);
                bg.appendChild(lb);
                document.body.appendChild(bg);
                this.waiting = bg;
            };
            Util.prototype.shutdown = function () {
                // Remove all event-handler references rooted in KMW events.
                this.events = {};
                // Remove all events linking to elements of the original, unaltered page.
                // This should sever any still-existing page ties to this instance of KMW,
                // allowing browser GC to do its thing.
                for (var _i = 0, _a = this.domEvents; _i < _a.length; _i++) {
                    var event_1 = _a[_i];
                    this.detachDOMEvent(event_1.Pelem, event_1.Peventname, event_1.Phandler, event_1.PuseCapture);
                }
                // Remove any KMW-added DOM element clutter.
                this.waiting.parentNode.removeChild(this.waiting);
                for (var _b = 0, _c = this.linkedStylesheets; _b < _c.length; _b++) {
                    var ss_1 = _c[_b];
                    if (ss_1.remove) {
                        ss_1.remove();
                    }
                    else if (ss_1.parentNode) {
                        ss_1.parentNode.removeChild(ss_1);
                    }
                }
            };
            /**
             * Get path of keymanweb script, for relative references
             *
             * *** This is not currently used, but may possibly be needed if ***
             * *** script identification during loading proves unreliable.   ***
             *
             *  @param    {string}      sName   filename prefix
             *  @return   {string}      path to source, with trailing slash
            **/
            Util.prototype.myPath = function (sName) {
                var i, scripts = document.getElementsByTagName('script'), ss;
                for (i = 0; i < scripts.length; i++) {
                    ss = scripts[i];
                    if (ss.src.indexOf(sName) >= 0) {
                        return ss.src.substr(0, ss.src.lastIndexOf('/') + 1);
                    }
                }
                return '';
            };
            // Prepend the appropriate protocol if not included in path
            Util.prototype.prependProtocol = function (path) {
                var pattern = new RegExp('^https?:');
                if (pattern.test(path)) {
                    return path;
                }
                else if (path.substr(0, 2) == '//') {
                    return this.keyman.protocol + path;
                }
                else if (path.substr(0, 1) == '/') {
                    return this.keyman.protocol + '/' + path;
                }
                else {
                    return this.keyman.protocol + '//' + path;
                }
            };
            /**
             * Return the appropriate test string for a given font
             *
             * TODO: Tidy up and remove arrays once 'sample' included in font metadata
             *
             *  @param  {Object}    fd    font meta-data object
             *  @return {string}          string to compare width
             *
             */
            Util.prototype.testString = function (fd) {
                var fontName = fd['family'], i, s = 'BESbswy';
                if ('sample' in fd && typeof (fd['sample']) == 'string') {
                    return s + fd['sample'];
                }
                var f = ['TamilWeb', 'TibetanWeb', 'LatinWeb', 'CherokeeWeb',
                    'EgyptianWeb', 'SinhalaWeb', 'KhmerWeb', 'ArabicWeb',
                    'BurmeseWeb', 'LaoWeb', 'OriyaWeb', 'GeezWeb'], t = ['\u0BBE\u0BF5', '\u0F7F\u0FD0', '\u02B0\u02A4', '\u13D0\u13C9',
                    '\uA723\uF7D3', '\u0DD8\u0DA3', '\u17D6\u178E', '\u0639\u06B3',
                    '\u1038\u1024', '\u0EC0\u0EDD', '\u0B03\u0B06', '\u1361\u132C'];
                for (i = 0; i < f.length; i++) {
                    if (fontName == f[i]) {
                        return s + t[i];
                    }
                }
                return s;
            };
            /**
             * Test if a font is installed (or available) on the target platform
             *
             * @param       {Object}        fd    font structure
             * @return      {boolean}             true if font available
             */
            Util.prototype.checkFont = function (fd) {
                var fontReady = false, fontName = fd['family'];
                // Create an absolute positioned div and two paragraph elements with spans for the test string.
                // The paragraph elements ensure that the spans are measured from the same point, otherwise
                // pixel rounding can result in different widths for the same string and styles.
                // Using a separate invisible DIV is more reliable than other positioning.
                var d = document.createElement('DIV'), ds = d.style, p1 = document.createElement('P'), p2 = document.createElement('P'), t1 = document.createElement('SPAN'), s1 = t1.style, t2 = document.createElement('SPAN'), s2 = t2.style;
                ds.position = 'absolute';
                ds.top = '10px';
                ds.left = '10px';
                ds.visibility = 'hidden';
                document.body.appendChild(d);
                d.appendChild(p1);
                d.appendChild(p2);
                p1.appendChild(t1);
                p2.appendChild(t2);
                // Firefox fails without the !important prefix on the fallback font,
                // apparently applying the same font to both elements.
                // But it also fails to distinguish the two if !important is added to the test font!
                // *** TODO: See if still true after changes Dec 2013 ***
                // Must apply !important tag to font-family, but must apply it to the CSS style, not the JS object member
                // c.f. http://stackoverflow.com/questions/462537/overriding-important-style-using-javascript
                t1.setAttribute('style', 'font-family:monospace !important');
                s2.fontFamily = fontName + ',monospace';
                s1.fontSize = s2.fontSize = '24px'; // Not too large, to avoid wrapping or overflow
                // Include narrow and wide characters from each unique script
                t1.innerHTML = t2.innerHTML = this.testString(fd);
                // Compare the actual width of each span. Checking monospace, serif,
                // and sans-serif helps to avoid falsely reporting the font as ready
                // The width must be different for all three tests.
                if (t1.offsetWidth != t2.offsetWidth) {
                    t1.setAttribute('style', 'font-family:sans-serif !important');
                    s2.fontFamily = fontName + ',sans-serif';
                    if (t1.offsetWidth != t2.offsetWidth) {
                        t1.setAttribute('style', 'font-family:serif !important');
                        s2.fontFamily = fontName + ',serif';
                    }
                }
                fontReady = (t1.offsetWidth != t2.offsetWidth);
                // Delete test elements
                p1.removeChild(t1);
                p2.removeChild(t2);
                d.removeChild(p1);
                d.removeChild(p2);
                document.body.removeChild(d);
                return fontReady;
            };
            /**
             * Check a font descriptor for font availability, returning true if undefined
             *
             *  @param  {Object}  fd  font descriptor member of keyboard stub
             *  @return {boolean}
             **/
            Util.prototype.checkFontDescriptor = function (fd) {
                if (typeof (fd) == 'undefined' || typeof (fd['family']) != 'string') {
                    return true;
                }
                return this.checkFont(fd);
            };
            return Util;
        }());
        keyman_4.Util = Util;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var Util = com.keyman.Util;
/// <reference path="deadkeys.ts" />
/// <reference path="../kmwbase.ts" />
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman_5) {
        var text;
        (function (text) {
            //#region Helper type definitions
            var KeyInformation = /** @class */ (function () {
                function KeyInformation() {
                }
                return KeyInformation;
            }());
            text.KeyInformation = KeyInformation;
            var RuleDeadkey = /** @class */ (function () {
                function RuleDeadkey() {
                }
                return RuleDeadkey;
            }());
            var ContextAny = /** @class */ (function () {
                function ContextAny() {
                }
                return ContextAny;
            }());
            var RuleIndex = /** @class */ (function () {
                function RuleIndex() {
                }
                return RuleIndex;
            }());
            var ContextEx = /** @class */ (function () {
                function ContextEx() {
                }
                return ContextEx;
            }());
            var ContextNul = /** @class */ (function () {
                function ContextNul() {
                }
                return ContextNul;
            }());
            var StoreBeep = /** @class */ (function () {
                function StoreBeep() {
                }
                return StoreBeep;
            }());
            /**
             * Cache of context storing and retrieving return values from KC
             * Must be reset prior to each keystroke and after any text changes
             * MCD 3/1/14
             **/
            var CachedContext = /** @class */ (function () {
                function CachedContext() {
                }
                CachedContext.prototype.reset = function () {
                    this._cache = [];
                };
                CachedContext.prototype.get = function (n, ln) {
                    // return null; // uncomment this line to disable context caching
                    if (typeof this._cache[n] == 'undefined') {
                        return null;
                    }
                    else if (typeof this._cache[n][ln] == 'undefined') {
                        return null;
                    }
                    return this._cache[n][ln];
                };
                CachedContext.prototype.set = function (n, ln, val) {
                    if (typeof this._cache[n] == 'undefined') {
                        this._cache[n] = [];
                    }
                    this._cache[n][ln] = val;
                };
                return CachedContext;
            }());
            ;
            /**
             * An extended version of cached context storing designed to work with
             * `fullContextMatch` and its helper functions.
             */
            var CachedContextEx = /** @class */ (function () {
                function CachedContextEx() {
                }
                CachedContextEx.prototype.reset = function () {
                    this._cache = [];
                };
                CachedContextEx.prototype.get = function (n, ln) {
                    // return null; // uncomment this line to disable context caching
                    if (typeof this._cache[n] == 'undefined') {
                        return null;
                    }
                    else if (typeof this._cache[n][ln] == 'undefined') {
                        return null;
                    }
                    return this._cache[n][ln];
                };
                CachedContextEx.prototype.set = function (n, ln, val) {
                    if (typeof this._cache[n] == 'undefined') {
                        this._cache[n] = [];
                    }
                    this._cache[n][ln] = val;
                };
                return CachedContextEx;
            }());
            ;
            var BeepData = /** @class */ (function () {
                function BeepData(e) {
                    this.e = e;
                    this.c = e.style.backgroundColor;
                }
                BeepData.prototype.reset = function () {
                    this.e.style.backgroundColor = this.c;
                };
                return BeepData;
            }());
            //#endregion
            var KeyboardInterface = /** @class */ (function () {
                // Set to 1 if there is an active 'beep', otherwise leave as '0'.
                function KeyboardInterface() {
                    this.cachedContext = new CachedContext();
                    this.cachedContextEx = new CachedContextEx();
                    this.TSS_LAYER = 33;
                    this.TSS_PLATFORM = 31;
                    this._AnyIndices = []; // AnyIndex - array of any/index match indices
                    this._BeepObjects = []; // BeepObjects - maintains a list of active 'beep' visual feedback elements
                    this._BeepTimeout = 0; // BeepTimeout - a flag indicating if there is an active 'beep'. 
                    // Also needed for some legacy CJK keyboards.
                    this['GetLastActiveElement'] = this['getLastActiveElement'];
                    this['FocusLastActiveElement'] = this['focusLastActiveElement'];
                    this['HideHelp'] = this['hideHelp'];
                    this['ShowHelp'] = this['showHelp'];
                    this['ShowPinnedHelp'] = this['showPinnedHelp'];
                }
                /**
                 * Function     KSF
                 * Scope        Public
                 * Description  Save keyboard focus
                 */
                KeyboardInterface.prototype.saveFocus = function () {
                    var keyman = com.keyman.singleton;
                    if (!keyman.isHeadless) {
                        keyman_5.DOMEventHandlers.states._IgnoreNextSelChange = 1;
                    }
                };
                /**
                 * Function     _NotifyKeyboard
                 * Scope        Private
                 * @param       {number}    _PCommand     event code (16,17,18) or 0
                 * @param       {Object}    _PTarget      target element
                 * @param       {number}    _PData        1 or 0
                 * Description  Notifies keyboard of keystroke or other event
                 */
                KeyboardInterface.prototype.notifyKeyboard = function (_PCommand, _PTarget, _PData) {
                    var keyman = com.keyman.singleton;
                    var activeKeyboard = keyman.keyboardManager.activeKeyboard;
                    var target;
                    if (_PTarget instanceof text.OutputTarget) {
                        target = _PTarget;
                    }
                    else {
                        target = text.Processor.getOutputTarget(_PTarget);
                    }
                    // Good example use case - the Japanese CJK-picker keyboard
                    if (activeKeyboard != null && typeof (activeKeyboard['KNS']) == 'function') {
                        activeKeyboard['KNS'](_PCommand, target, _PData);
                    }
                };
                /**
                 * Function     KT
                 * Scope        Public
                 * @param       {string}      Ptext     Text to insert
                 * @param       {?number}     PdeadKey  Dead key number, if any (???)
                 * @return      {boolean}               true if inserted
                 * Description  Insert text into active control
                 */
                KeyboardInterface.prototype.insertText = function (Ptext, PdeadKey) {
                    var keyman = com.keyman.singleton;
                    this.resetContextCache();
                    // Find the correct output target to manipulate.
                    var outputTarget = this.activeTargetOutput ? this.activeTargetOutput : text.Processor.getOutputTarget();
                    if (outputTarget != null) {
                        if (!keyman.isHeadless) {
                            keyman.uiManager.setActivatingUI(true);
                            keyman_5.DOMEventHandlers.states._IgnoreNextSelChange = 100;
                            keyman.domManager.focusLastActiveElement();
                            keyman_5.DOMEventHandlers.states._IgnoreNextSelChange = 0;
                        }
                        if (Ptext != null) {
                            this.output(0, outputTarget, Ptext);
                        }
                        if ((typeof (PdeadKey) !== 'undefined') && (PdeadKey !== null)) {
                            this.deadkeyOutput(0, outputTarget, PdeadKey);
                        }
                        outputTarget.invalidateSelection();
                        return true;
                    }
                    return false;
                };
                /**
                 * Function     registerKeyboard  KR
                 * Scope        Public
                 * @param       {Object}      Pk      Keyboard  object
                 * Description  Register and load the keyboard
                 */
                KeyboardInterface.prototype.registerKeyboard = function (Pk) {
                    var keyman = com.keyman.singleton;
                    keyman.keyboardManager._registerKeyboard(Pk);
                };
                /**
                 * Add the basic keyboard parameters (keyboard stub) to the array of keyboard stubs
                 * If no language code is specified in a keyboard it cannot be registered,
                 * and a keyboard stub must be registered before the keyboard is loaded
                 * for the keyboard to be usable.
                 *
                 * @param       {Object}      Pstub     Keyboard stub object
                 * @return      {?number}               1 if already registered, else null
                 */
                KeyboardInterface.prototype.registerStub = function (Pstub) {
                    var keyman = com.keyman.singleton;
                    return keyman.keyboardManager._registerStub(Pstub);
                };
                /**
                 * Get *cached or uncached* keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {string}              Context string
                 *
                 * Example     [abcdef|ghi] as INPUT, with the caret position marked by |:
                 *             KC(2,1,Pelem) == "e"
                 *             KC(3,3,Pelem) == "def"
                 *             KC(10,10,Pelem) == "abcdef"  i.e. return as much as possible of the requested string
                 */
                KeyboardInterface.prototype.context = function (n, ln, outputTarget) {
                    var v = this.cachedContext.get(n, ln);
                    if (v !== null) {
                        return v;
                    }
                    var r = this.KC_(n, ln, outputTarget);
                    this.cachedContext.set(n, ln, r);
                    return r;
                };
                /**
                 * Get (uncached) keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {string}              Context string
                 *
                 * Example     [abcdef|ghi] as INPUT, with the caret position marked by |:
                 *             KC(2,1,Pelem) == "e"
                 *             KC(3,3,Pelem) == "def"
                 *             KC(10,10,Pelem) == "XXXXabcdef"  i.e. return as much as possible of the requested string, where X = \uFFFE
                 */
                KeyboardInterface.prototype.KC_ = function (n, ln, outputTarget) {
                    var tempContext = '';
                    tempContext = outputTarget.getTextBeforeCaret();
                    if (tempContext._kmwLength() < n) {
                        tempContext = Array(n - tempContext._kmwLength() + 1).join("\uFFFE") + tempContext;
                    }
                    return tempContext._kmwSubstr(-n)._kmwSubstr(0, ln);
                };
                /**
                 * Function     nul           KN
                 * Scope        Public
                 * @param       {number}      n       Length of context to check
                 * @param       {Object}      Ptarg   Element to work with (must be currently focused element)
                 * @return      {boolean}             True if length of context is less than or equal to n
                 * Description  Test length of context, return true if the length of the context is less than or equal to n
                 *
                 * Example     [abc|def] as INPUT, with the caret position marked by |:
                 *             KN(3,Pelem) == TRUE
                 *             KN(2,Pelem) == FALSE
                 *             KN(4,Pelem) == TRUE
                 */
                KeyboardInterface.prototype.nul = function (n, outputTarget) {
                    var cx = this.context(n + 1, 1, outputTarget);
                    // With #31, the result will be a replacement character if context is empty.
                    return cx === "\uFFFE";
                };
                /**
                 * Function     contextMatch  KCM
                 * Scope        Public
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {Object}      Ptarg   Focused element
                 * @param       {string}      val     String to match
                 * @param       {number}      ln      Number of characters to return
                 * @return      {boolean}             True if selected context matches val
                 * Description  Test keyboard context for match
                 */
                KeyboardInterface.prototype.contextMatch = function (n, outputTarget, val, ln) {
                    var cx = this.context(n, ln, outputTarget);
                    if (cx === val) {
                        return true; // I3318
                    }
                    outputTarget.deadkeys().resetMatched(); // I3318
                    return false;
                };
                /**
                 * Builds the *cached or uncached* keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {Array}               Context array (of strings and numbers)
                 */
                KeyboardInterface.prototype._BuildExtendedContext = function (n, ln, outputTarget) {
                    var cache = this.cachedContextEx.get(n, ln);
                    if (cache !== null) {
                        return cache;
                    }
                    else {
                        // By far the easiest way to correctly build what we want is to start from the right and work to what we need.
                        // We may have done it for a similar cursor position before.
                        cache = this.cachedContextEx.get(n, n);
                        if (cache === null) {
                            // First, let's make sure we have a cloned, sorted copy of the deadkey array.
                            var unmatchedDeadkeys = outputTarget.deadkeys().toSortedArray(); // Is reverse-order sorted for us already.
                            // Time to build from scratch!
                            var index = 0;
                            cache = { valContext: [], deadContext: [] };
                            while (cache.valContext.length < n) {
                                // As adapted from `deadkeyMatch`.
                                var sp = outputTarget.getDeadkeyCaret();
                                var deadPos = sp - index;
                                if (unmatchedDeadkeys.length > 0 && unmatchedDeadkeys[0].p > deadPos) {
                                    // We have deadkeys at the right-hand side of the caret!  They don't belong in the context, so pop 'em off.
                                    unmatchedDeadkeys.splice(0, 1);
                                    continue;
                                }
                                else if (unmatchedDeadkeys.length > 0 && unmatchedDeadkeys[0].p == deadPos) {
                                    // Take the deadkey.
                                    cache.deadContext[n - cache.valContext.length - 1] = unmatchedDeadkeys[0];
                                    cache.valContext = [unmatchedDeadkeys[0].d].concat(cache.valContext);
                                    unmatchedDeadkeys.splice(0, 1);
                                }
                                else {
                                    // Take the character.  We get "\ufffe" if it doesn't exist.
                                    var kc = this.context(++index, 1, outputTarget);
                                    cache.valContext = [kc].concat(cache.valContext);
                                }
                            }
                            this.cachedContextEx.set(n, n, cache);
                        }
                        // Now that we have the cache...
                        var subCache = cache;
                        subCache.valContext = subCache.valContext.slice(0, ln);
                        for (var i = 0; i < subCache.valContext.length; i++) {
                            if (subCache[i] == '\ufffe') {
                                subCache.valContext.splice(0, 1);
                                subCache.deadContext.splice(0, 1);
                            }
                        }
                        if (subCache.valContext.length == 0) {
                            subCache.valContext = ['\ufffe'];
                            subCache.deadContext = [];
                        }
                        this.cachedContextEx.set(n, ln, subCache);
                        return subCache;
                    }
                };
                /**
                 * Function       fullContextMatch    KFCM
                 * Scope          Private
                 * @param         {number}    n       Number of characters to move back from caret
                 * @param         {Object}    Ptarg   Focused element
                 * @param         {Array}     rule    An array of ContextEntries to match.
                 * @return        {boolean}           True if the fully-specified rule context matches the current KMW state.
                 *
                 * A KMW 10+ function designed to bring KMW closer to Keyman Desktop functionality,
                 * near-directly modeling (externally) the compiled form of Desktop rules' context section.
                 */
                KeyboardInterface.prototype.fullContextMatch = function (n, outputTarget, rule) {
                    // Stage one:  build the context index map.
                    var fullContext = this._BuildExtendedContext(n, rule.length, outputTarget);
                    var context = fullContext.valContext;
                    var deadContext = fullContext.deadContext;
                    var mismatch = false;
                    // This symbol internally indicates lack of context in a position.  (See KC_)
                    var NUL_CONTEXT = "\uFFFE";
                    var assertNever = function (x) {
                        // Could be accessed by improperly handwritten calls to `fullContextMatch`.
                        throw new Error("Unexpected object in fullContextMatch specification: " + x);
                    };
                    // Stage two:  time to match against the rule specified.
                    for (var i = 0; i < rule.length; i++) {
                        if (typeof rule[i] == 'string') {
                            var str = rule[i];
                            if (str !== context[i]) {
                                mismatch = true;
                                break;
                            }
                        }
                        else {
                            // TypeScript needs a cast to this intermediate type to do its discriminated union magic.
                            var r = rule[i];
                            switch (r.t) {
                                case 'd':
                                    // We still need to set a flag here; 
                                    if (r['d'] !== context[i]) {
                                        mismatch = true;
                                    }
                                    else {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'a':
                                    var lookup;
                                    if (typeof context[i] == 'string') {
                                        lookup = context[i];
                                    }
                                    else {
                                        lookup = { 't': 'd', 'd': context[i] };
                                    }
                                    var result = this.any(i, lookup, r.a);
                                    if (!r.n) { // If it's a standard 'any'...
                                        if (!result) {
                                            mismatch = true;
                                        }
                                        else if (deadContext[i] !== undefined) {
                                            // It's a deadkey match, so indicate that.
                                            deadContext[i].set();
                                        }
                                        // 'n' for 'notany'.  If we actually match or if we have nul context (\uFFFE), notany fails.
                                    }
                                    else if (r.n && (result || context[i] !== NUL_CONTEXT)) {
                                        mismatch = true;
                                    }
                                    break;
                                case 'i':
                                    // The context will never hold a 'beep.'
                                    var ch = this._Index(r.i, r.o);
                                    if (ch !== undefined && (typeof (ch) == 'string' ? ch : ch.d) !== context[i]) {
                                        mismatch = true;
                                    }
                                    else if (deadContext[i] !== undefined) {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'c':
                                    if (context[r.c - 1] !== context[i]) {
                                        mismatch = true;
                                    }
                                    else if (deadContext[i] !== undefined) {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'n':
                                    // \uFFFE is the internal 'no context here sentinel'.
                                    if (context[i] != NUL_CONTEXT) {
                                        mismatch = true;
                                    }
                                    break;
                                default:
                                    assertNever(r);
                            }
                        }
                    }
                    if (mismatch) {
                        // Reset the matched 'any' indices, if any.
                        outputTarget.deadkeys().resetMatched();
                        this._AnyIndices = [];
                    }
                    return !mismatch;
                };
                /**
                 * Function     KIK
                 * Scope        Public
                 * @param       {Object}  e   keystroke event
                 * @return      {boolean}     true if keypress event
                 * Description  Test if event as a keypress event
                 */
                KeyboardInterface.prototype.isKeypress = function (e) {
                    var keyman = com.keyman.singleton;
                    if (keyman.keyboardManager.activeKeyboard['KM']) { // I1380 - support KIK for positional layouts
                        return !e.LisVirtualKey; // will now return true for U_xxxx keys, but not for T_xxxx keys
                    }
                    else {
                        return keyman.keyMapManager._USKeyCodeToCharCode(e) ? true : false; // I1380 - support KIK for positional layouts
                    }
                };
                /**
                 * Function     keyMatch      KKM
                 * Scope        Public
                 * @param       {Object}      e           keystroke event
                 * @param       {number}      Lruleshift
                 * @param       {number}      Lrulekey
                 * @return      {boolean}                 True if key matches rule
                 * Description  Test keystroke with modifiers against rule
                 */
                KeyboardInterface.prototype.keyMatch = function (e, Lruleshift, Lrulekey) {
                    var retVal = false; // I3318
                    var keyCode = (e.Lcode == 173 ? 189 : e.Lcode); //I3555 (Firefox hyphen issue)
                    var keyman = com.keyman.singleton;
                    var bitmask = keyman.keyboardManager.getKeyboardModifierBitmask();
                    var Codes = com.keyman.text.Codes;
                    var modifierBitmask = bitmask & Codes.modifierBitmasks["ALL"];
                    var stateBitmask = bitmask & Codes.stateBitmasks["ALL"];
                    if (e.vkCode > 255) {
                        keyCode = e.vkCode; // added to support extended (touch-hold) keys for mnemonic layouts
                    }
                    if (e.LisVirtualKey || keyCode > 255) {
                        if ((Lruleshift & 0x4000) == 0x4000 || (keyCode > 255)) { // added keyCode test to support extended keys
                            retVal = ((Lrulekey == keyCode) && ((Lruleshift & modifierBitmask) == e.Lmodifiers)); //I3318, I3555
                            retVal = retVal && this.stateMatch(e, Lruleshift & stateBitmask);
                        }
                    }
                    else if ((Lruleshift & 0x4000) == 0) {
                        retVal = (keyCode == Lrulekey); // I3318, I3555
                    }
                    if (!retVal) {
                        this.activeTargetOutput.deadkeys().resetMatched(); // I3318
                    }
                    return retVal; // I3318
                };
                ;
                /**
                 * Function     stateMatch    KSM
                 * Scope        Public
                 * @param       {Object}      e       keystroke event
                 * @param       {number}      Lstate
                 * Description  Test keystroke against state key rules
                 */
                KeyboardInterface.prototype.stateMatch = function (e, Lstate) {
                    return ((Lstate & e.Lstates) == Lstate);
                };
                /**
                 * Function     keyInformation  KKI
                 * Scope        Public
                 * @param       {Object}      e
                 * @return      {Object}              Object with event's virtual key flag, key code, and modifiers
                 * Description  Get object with extended key event information
                 */
                KeyboardInterface.prototype.keyInformation = function (e) {
                    var ei = new KeyInformation();
                    ei['vk'] = e.LisVirtualKey;
                    ei['code'] = e.Lcode;
                    ei['modifiers'] = e.Lmodifiers;
                    return ei;
                };
                ;
                /**
                 * Function     deadkeyMatch  KDM
                 * Scope        Public
                 * @param       {number}      n       offset from current cursor position
                 * @param       {Object}      Ptarg   target element
                 * @param       {number}      d       deadkey
                 * @return      {boolean}             True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                KeyboardInterface.prototype.deadkeyMatch = function (n, outputTarget, d) {
                    return outputTarget.hasDeadkeyMatch(n, d);
                };
                /**
                 * Function     beepReset   KBR
                 * Scope        Public
                 * Description  Reset/terminate beep or flash (not currently used: Aug 2011)
                 */
                KeyboardInterface.prototype.beepReset = function () {
                    this.resetContextCache();
                    var Lbo;
                    this._BeepTimeout = 0;
                    for (Lbo = 0; Lbo < this._BeepObjects.length; Lbo++) { // I1511 - array prototype extended
                        this._BeepObjects[Lbo].reset();
                    }
                    this._BeepObjects = [];
                };
                /**
                 * Function     beep          KB
                 * Scope        Public
                 * @param       {Object}      Pelem     element to flash
                 * Description  Flash body as substitute for audible beep; notify embedded device to vibrate
                 */
                KeyboardInterface.prototype.beep = function (outputTarget) {
                    this.resetContextCache();
                    // Do not trigger a 'beep' when operating on alternates - the use case of Mocks.
                    if (outputTarget instanceof text.Mock) {
                        return;
                    }
                    var keyman = com.keyman.singleton;
                    if ('beepKeyboard' in keyman) {
                        keyman['beepKeyboard']();
                    }
                    var Pelem = outputTarget.getElement();
                    if (outputTarget instanceof keyman_5.dom.DesignIFrame) {
                        Pelem = outputTarget.docRoot; // I1446 - beep sometimes fails to flash when using OSK and rich control
                    }
                    if (!Pelem) {
                        return; // There's no way to signal a 'beep' to null, so just cut everything short.
                    }
                    if (!Pelem.style || typeof (Pelem.style.backgroundColor) == 'undefined') {
                        return;
                    }
                    for (var Lbo = 0; Lbo < this._BeepObjects.length; Lbo++) { // I1446 - beep sometimes fails to return background color to normal
                        // I1511 - array prototype extended
                        if (this._BeepObjects[Lbo].e == Pelem) {
                            return;
                        }
                    }
                    this._BeepObjects = keyman._push(this._BeepObjects, new BeepData(Pelem));
                    Pelem.style.backgroundColor = '#000000';
                    if (this._BeepTimeout == 0) {
                        this._BeepTimeout = 1;
                        window.setTimeout(this.beepReset.bind(this), 50);
                    }
                };
                KeyboardInterface.prototype._ExplodeStore = function (store) {
                    if (typeof (store) == 'string') {
                        var keyman_6 = com.keyman.singleton;
                        var kbdTag = keyman_6.keyboardManager.getActiveKeyboardTag();
                        // Is the result cached?
                        if (kbdTag.stores[store]) {
                            return kbdTag.stores[store];
                        }
                        // Nope, so let's build its cache.
                        var result = [];
                        for (var i = 0; i < store._kmwLength(); i++) {
                            result.push(store._kmwCharAt(i));
                        }
                        // Cache the result for later!
                        kbdTag.stores[store] = result;
                        return result;
                    }
                    else {
                        return store;
                    }
                };
                /**
                 * Function     any           KA
                 * Scope        Public
                 * @param       {number}      n     character position (index)
                 * @param       {string}      ch    character to find in string
                 * @param       {string}      s     'any' string
                 * @return      {boolean}           True if character found in 'any' string, sets index accordingly
                 * Description  Test for character matching
                 */
                KeyboardInterface.prototype.any = function (n, ch, s) {
                    if (ch == '') {
                        return false;
                    }
                    s = this._ExplodeStore(s);
                    var Lix = -1;
                    for (var i = 0; i < s.length; i++) {
                        if (typeof (s[i]) == 'string') {
                            if (s[i] == ch) {
                                Lix = i;
                                break;
                            }
                        }
                        else if (s[i]['d'] === ch['d']) {
                            Lix = i;
                            break;
                        }
                    }
                    this._AnyIndices[n] = Lix;
                    return Lix >= 0;
                };
                /**
                 * Function     _Index
                 * Scope        Public
                 * @param       {string}      Ps      string
                 * @param       {number}      Pn      index
                 * Description  Returns the character from a store string according to the offset in the index array
                 */
                KeyboardInterface.prototype._Index = function (Ps, Pn) {
                    Ps = this._ExplodeStore(Ps);
                    if (this._AnyIndices[Pn - 1] < Ps.length) { //I3319
                        return Ps[this._AnyIndices[Pn - 1]];
                    }
                    else {
                        /* Should not be possible for a compiled keyboard, but may arise
                        * during the development of handwritten keyboards.
                        */
                        console.warn("Unmatched contextual index() statement detected in rule with index " + Pn + "!");
                        return "";
                    }
                };
                /**
                 * Function     indexOutput   KIO
                 * Scope        Public
                 * @param       {number}      Pdn     no of character to overwrite (delete)
                 * @param       {string}      Ps      string
                 * @param       {number}      Pn      index
                 * @param       {Object}      Pelem   element to output to
                 * Description  Output a character selected from the string according to the offset in the index array
                 */
                KeyboardInterface.prototype.indexOutput = function (Pdn, Ps, Pn, outputTarget) {
                    this.resetContextCache();
                    var assertNever = function (x) {
                        // Could be accessed by improperly handwritten calls to `fullContextMatch`.
                        throw new Error("Unexpected object in fullContextMatch specification: " + x);
                    };
                    var indexChar = this._Index(Ps, Pn);
                    if (indexChar !== "") {
                        if (typeof indexChar == 'string') {
                            this.output(Pdn, outputTarget, indexChar); //I3319
                        }
                        else if (indexChar['t']) {
                            var storeEntry = indexChar;
                            switch (storeEntry.t) {
                                case 'b': // Beep commands may appear within stores.
                                    this.beep(outputTarget);
                                    break;
                                case 'd':
                                    this.deadkeyOutput(Pdn, outputTarget, indexChar['d']);
                                    break;
                                default:
                                    assertNever(storeEntry);
                            }
                        }
                        else { // For keyboards developed during 10.0's alpha phase - t:'d' was assumed.
                            this.deadkeyOutput(Pdn, outputTarget, indexChar['d']);
                        }
                    }
                };
                /**
                 * Function     deleteContext KDC
                 * Scope        Public
                 * @param       {number}      dn      number of context entries to overwrite
                 * @param       {Object}      Pelem   element to output to
                 * @param       {string}      s       string to output
                 * Description  Keyboard output
                 */
                KeyboardInterface.prototype.deleteContext = function (dn, outputTarget) {
                    var context;
                    // We want to control exactly which deadkeys get removed.
                    if (dn > 0) {
                        context = this._BuildExtendedContext(dn, dn, outputTarget);
                        var nulCount = 0;
                        for (var i = 0; i < context.valContext.length; i++) {
                            var dk = context.deadContext[i];
                            if (dk) {
                                // Remove deadkey in context.
                                outputTarget.deadkeys().remove(dk);
                                // Reduce our reported context size.
                                dn--;
                            }
                            else if (context.valContext[i] == "\uFFFE") {
                                // Count any `nul` sentinels that would contribute to our deletion count.
                                nulCount++;
                            }
                        }
                        // Prevent attempts to delete nul sentinels, as they don't exist in the actual context.
                        // (Addresses regression from KMW v 12.0 paired with Developer bug through same version)
                        var contextLength = context.valContext.length - nulCount;
                        if (dn > contextLength) {
                            dn = contextLength;
                        }
                    }
                    // If a matched deadkey hasn't been deleted, we don't WANT to delete it.
                    outputTarget.deadkeys().resetMatched();
                    // Why reinvent the wheel?  Delete the remaining characters by 'inserting a blank string'.
                    this.output(dn, outputTarget, '');
                };
                /**
                 * Function     output        KO
                 * Scope        Public
                 * @param       {number}      dn      number of characters to overwrite
                 * @param       {Object}      Pelem   element to output to
                 * @param       {string}      s       string to output
                 * Description  Keyboard output
                 */
                KeyboardInterface.prototype.output = function (dn, outputTarget, s) {
                    this.resetContextCache();
                    var keyman = com.keyman.singleton;
                    // KeymanTouch for Android uses direct insertion of the character string
                    if ('oninserttext' in keyman && !(outputTarget instanceof text.Mock)) {
                        keyman['oninserttext'](dn, s);
                    }
                    outputTarget.saveProperties();
                    outputTarget.clearSelection();
                    outputTarget.deadkeys().deleteMatched(); // I3318
                    if (dn >= 0) {
                        // Automatically manages affected deadkey positions.  Does not delete deadkeys b/c legacy behavior support.
                        outputTarget.deleteCharsBeforeCaret(dn);
                    }
                    // Automatically manages affected deadkey positions.
                    outputTarget.insertTextBeforeCaret(s);
                    outputTarget.restoreProperties();
                    // Refresh element content after change (if needed)
                    if (typeof (keyman.refreshElementContent) == 'function') {
                        keyman.refreshElementContent(outputTarget.getElement());
                    }
                    if ((dn >= 0 || s) && outputTarget.getElement() == keyman_5.DOMEventHandlers.states.activeElement) {
                        // Record that we've made an edit.
                        keyman_5.DOMEventHandlers.states.changed = true;
                    }
                };
                /**
                 * Function     deadkeyOutput KDO
                 * Scope        Public
                 * @param       {number}      Pdn     no of character to overwrite (delete)
                 * @param       {Object}      Pelem   element to output to
                 * @param       {number}      Pd      deadkey id
                 * Description  Record a deadkey at current cursor position, deleting Pdn characters first
                 */
                KeyboardInterface.prototype.deadkeyOutput = function (Pdn, outputTarget, Pd) {
                    this.resetContextCache();
                    if (Pdn >= 0) {
                        this.output(Pdn, outputTarget, ""); //I3318 corrected to >=
                    }
                    outputTarget.insertDeadkeyBeforeCaret(Pd);
                    //    _DebugDeadKeys(Pelem, 'KDeadKeyOutput: dn='+Pdn+'; deadKey='+Pd);
                };
                /**
                 * KIFS compares the content of a system store with a string value
                 *
                 * @param       {number}      systemId    ID of the system store to test (only TSS_LAYER currently supported)
                 * @param       {string}      strValue    String value to compare to
                 * @param       {Object}      Pelem       Currently active element (may be needed by future tests)
                 * @return      {boolean}                 True if the test succeeds
                 */
                KeyboardInterface.prototype.ifStore = function (systemId, strValue, outputTarget) {
                    var keyman = com.keyman.singleton;
                    var result = true;
                    if (systemId == this.TSS_LAYER) {
                        // How would this be handled in an eventual headless mode?
                        result = (keyman.osk.vkbd.layerId === strValue);
                    }
                    else if (systemId == this.TSS_PLATFORM) {
                        var i, constraint, constraints = strValue.split(' ');
                        for (i = 0; i < constraints.length; i++) {
                            constraint = constraints[i].toLowerCase();
                            switch (constraint) {
                                case 'touch':
                                case 'hardware':
                                    if (keyman.util.activeDevice.touchable != (constraint == 'touch')) {
                                        result = false;
                                    }
                                    break;
                                case 'macos':
                                case 'mac':
                                    constraint = 'macosx';
                                // fall through
                                case 'macosx':
                                case 'windows':
                                case 'android':
                                case 'ios':
                                case 'linux':
                                    if (keyman.util.activeDevice.OS.toLowerCase() != constraint) {
                                        result = false;
                                    }
                                    break;
                                case 'tablet':
                                case 'phone':
                                case 'desktop':
                                    if (keyman.util.device.formFactor != constraint) {
                                        result = false;
                                    }
                                    break;
                                case 'web':
                                    if (keyman.util.device.browser == 'native') {
                                        result = false; // web matches anything other than 'native'
                                    }
                                    break;
                                case 'native':
                                // This will return true for embedded KeymanWeb
                                case 'ie':
                                case 'chrome':
                                case 'firefox':
                                case 'safari':
                                case 'edge':
                                case 'opera':
                                    if (keyman.util.device.browser != constraint) {
                                        result = false;
                                    }
                                    break;
                                default:
                                    result = false;
                            }
                        }
                    }
                    return result; //Moved from previous line, now supports layer selection, Build 350 
                };
                /**
                 * KSETS sets the value of a system store to a string
                 *
                 * @param       {number}      systemId    ID of the system store to set (only TSS_LAYER currently supported)
                 * @param       {string}      strValue    String to set as the system store content
                 * @param       {Object}      Pelem       Currently active element (may be needed in future tests)
                 * @return      {boolean}                 True if command succeeds
                 *                                        (i.e. for TSS_LAYER, if the layer is successfully selected)
                 */
                KeyboardInterface.prototype.setStore = function (systemId, strValue, outputTarget) {
                    var keyman = com.keyman.singleton;
                    this.resetContextCache();
                    if (systemId == this.TSS_LAYER) {
                        // Do not trigger a layer change when operating on alternates - the use case of Mocks.
                        if (outputTarget instanceof text.Mock) {
                            return;
                        }
                        // How would this be handled in an eventual headless mode?
                        return keyman.osk.vkbd.showLayer(strValue); //Buld 350, osk reference now OK, so should work
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * Load an option store value from a cookie or default value
                 *
                 * @param       {string}      kbdName     keyboard internal name
                 * @param       {string}      storeName   store (option) name, embedded in cookie name
                 * @param       {string}      dfltValue   default value
                 * @return      {string}                  current or default option value
                 */
                KeyboardInterface.prototype.loadStore = function (kbdName, storeName, dfltValue) {
                    var keyman = com.keyman.singleton;
                    this.resetContextCache();
                    var cName = 'KeymanWeb_' + kbdName + '_Option_' + storeName, cValue = keyman.util.loadCookie(cName);
                    if (typeof cValue[storeName] != 'undefined') {
                        return decodeURIComponent(cValue[storeName]);
                    }
                    else {
                        return dfltValue;
                    }
                };
                /**
                 * Save an option store value to a cookie
                 *
                 * @param       {string}      storeName   store (option) name, embedded in cookie name
                 * @param       {string}      optValue    option value to save
                 * @return      {boolean}                 true if save successful
                 */
                KeyboardInterface.prototype.saveStore = function (storeName, optValue) {
                    var keyman = com.keyman.singleton;
                    this.resetContextCache();
                    var kbd = keyman.keyboardManager.activeKeyboard;
                    if (!kbd || typeof kbd['KI'] == 'undefined' || kbd['KI'] == '') {
                        return false;
                    }
                    var cName = 'KeymanWeb_' + kbd['KI'] + '_Option_' + storeName, cValue = encodeURIComponent(optValue);
                    keyman.util.saveCookie(cName, cValue);
                    return true;
                };
                KeyboardInterface.prototype.resetContextCache = function () {
                    this.cachedContext.reset();
                    this.cachedContextEx.reset();
                };
                KeyboardInterface.prototype.doInputEvent = function (_target) {
                    var event;
                    // TypeScript doesn't yet recognize InputEvent as a type!
                    if (typeof window['InputEvent'] == 'function') {
                        event = new window['InputEvent']('input', { "bubbles": true, "cancelable": false });
                    } // No else - there is no supported version in some browsers.
                    // Ensure that touch-aliased elements fire as if from the aliased element.
                    if (_target['base'] && _target['base']['kmw_ip']) {
                        _target = _target['base'];
                    }
                    if (_target && event) {
                        _target.dispatchEvent(event);
                    }
                };
                KeyboardInterface.prototype.defaultBackspace = function (outputTarget) {
                    if (!outputTarget) {
                        // Find the correct output target to manipulate.
                        outputTarget = this.activeTargetOutput ? this.activeTargetOutput : text.Processor.getOutputTarget();
                    }
                    this.output(1, outputTarget, "");
                    if (outputTarget.getElement()) {
                        this.doInputEvent(outputTarget.getElement());
                    }
                };
                /**
                 * Function     processKeystroke
                 * Scope        Private
                 * @param       {Object}        device      The device object properties to be utilized for this keystroke.
                 * @param       {Object}        element     The page element receiving input
                 * @param       {Object}        keystroke   The input keystroke (with its properties) to be mapped by the keyboard.
                 * Description  Encapsulates calls to keyboard input processing.
                 * @returns     {number}        0 if no match is made, otherwise 1.
                 */
                KeyboardInterface.prototype.processKeystroke = function (device, outputTarget, keystroke) {
                    var keyman = com.keyman.singleton;
                    // Clear internal state tracking data from prior keystrokes.
                    if (!outputTarget) {
                        throw "No target specified for keyboard output!";
                    }
                    outputTarget.invalidateSelection();
                    outputTarget.deadkeys().resetMatched(); // I3318    
                    this.resetContextCache();
                    // Ensure the settings are in place so that KIFS/ifState activates and deactivates
                    // the appropriate rule(s) for the modeled device.
                    keyman.util.activeDevice = device;
                    // Calls the start-group of the active keyboard.
                    this.activeTargetOutput = outputTarget;
                    var matched = keyman.keyboardManager.activeKeyboard['gs'](outputTarget, keystroke);
                    this.activeTargetOutput = null;
                    return matched;
                };
                /**
                 * Legacy entry points (non-standard names)- included only to allow existing IME keyboards to continue to be used
                 */
                KeyboardInterface.prototype['getLastActiveElement'] = function () {
                    return text.Processor.getOutputTarget();
                };
                KeyboardInterface.prototype['focusLastActiveElement'] = function () {
                    var keyman = com.keyman.singleton;
                    if (!keyman.isHeadless) {
                        keyman.domManager.focusLastActiveElement();
                    }
                };
                //The following entry points are defined but should not normally be used in a keyboard, as OSK display is no longer determined by the keyboard
                KeyboardInterface.prototype['hideHelp'] = function () {
                    var keyman = com.keyman.singleton;
                    if (!keyman.isHeadless) {
                        keyman.osk._Hide(true);
                    }
                };
                KeyboardInterface.prototype['showHelp'] = function (Px, Py) {
                    var keyman = com.keyman.singleton;
                    if (!keyman.isHeadless) {
                        keyman.osk._Show(Px, Py);
                    }
                };
                KeyboardInterface.prototype['showPinnedHelp'] = function () {
                    var keyman = com.keyman.singleton;
                    if (!keyman.isHeadless) {
                        keyman.osk.userPositioned = true;
                        keyman.osk._Show(-1, -1);
                    }
                };
                KeyboardInterface.prototype.resetContext = function () {
                    var keyman = com.keyman.singleton;
                    if (!keyman.isHeadless && keyman.osk.vkbd) {
                        keyman.osk.vkbd.layerId = 'default';
                    }
                    // Find the correct output target to manipulate.
                    var outputTarget = this.activeTargetOutput ? this.activeTargetOutput : text.Processor.getOutputTarget();
                    if (outputTarget) {
                        outputTarget.deadkeys().clear();
                    }
                    this.resetContextCache();
                    this.resetVKShift();
                    if (keyman.modelManager) {
                        keyman.modelManager.invalidateContext();
                    }
                    if (!keyman.isHeadless) {
                        keyman.osk._Show();
                    }
                };
                ;
                KeyboardInterface.prototype.setNumericLayer = function () {
                    var keyman = com.keyman.singleton;
                    var i;
                    if (!keyman.isHeadless) {
                        var osk_1 = keyman.osk.vkbd;
                        for (i = 0; i < osk_1.layers.length; i++) {
                            if (osk_1.layers[i].id == 'numeric') {
                                osk_1.layerId = 'numeric';
                                keyman.osk._Show();
                            }
                        }
                    }
                };
                ;
                /**
                 * Reset OSK shift states when entering or exiting the active element
                 **/
                KeyboardInterface.prototype.resetVKShift = function () {
                    var keyman = com.keyman.singleton;
                    var processor = com.keyman.singleton.textProcessor;
                    if (!keyman.isHeadless && !keyman.uiManager.isActivating && keyman.osk.vkbd) {
                        if (processor._UpdateVKShift) {
                            processor._UpdateVKShift(null, 15, 0); //this should be enabled !!!!! TODO
                        }
                    }
                };
                return KeyboardInterface;
            }());
            text.KeyboardInterface = KeyboardInterface;
        })(text = keyman_5.text || (keyman_5.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="kmwbase.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_7) {
        var CloudRequestEntry = /** @class */ (function () {
            function CloudRequestEntry(id, language) {
                this.id = id;
                this.language = language;
            }
            CloudRequestEntry.prototype.toString = function () {
                var kbid = this.id;
                var lgid = '';
                var kvid = '';
                if (this.language) {
                    kbid = kbid + '@' + this.language;
                    if (this.version) {
                        kbid = kbid + '@' + this.version;
                    }
                }
                else {
                    if (this.version) {
                        kbid = kbid + '@@' + this.version;
                    }
                }
                //TODO: add specifier validation... 
                return kbid;
            };
            return CloudRequestEntry;
        }());
        var KeyboardFont = /** @class */ (function () {
            function KeyboardFont(fontObj, fontPath) {
                this['family'] = fontObj['family'];
                this['files'] = fontObj['source'];
                this['path'] = fontPath;
            }
            return KeyboardFont;
        }());
        var KeyboardStub = /** @class */ (function () {
            function KeyboardStub(id, langCode) {
                this['KI'] = 'Keyboard_' + id;
                this['KLC'] = langCode;
            }
            return KeyboardStub;
        }());
        keyman_7.KeyboardStub = KeyboardStub;
        var KeyboardTag = /** @class */ (function () {
            function KeyboardTag() {
                this.stores = {};
            }
            return KeyboardTag;
        }());
        keyman_7.KeyboardTag = KeyboardTag;
        var KeyboardManager = /** @class */ (function () {
            function KeyboardManager(kmw) {
                this.activeStub = null;
                this.keyboardStubs = [];
                this.deferredStubs = []; // The list of user-provided keyboard stub registration objects.
                this.deferredKRS = []; // Array of pending keyboard stubs from KRS, to register after initialization
                this.deferredKR = []; // Array of pending keyboards, to be installed at end of initialization
                // The following was not actually utilized within KeymanWeb; I think it's handled via different logic.  
                // See setDefaultKeyboard() below.
                this.dfltStub = null; // First keyboard stub loaded - default for touch-screen devices, ignored on desktops
                this.keyboards = [];
                this.languageList = null; // List of keyboard languages available for KeymanCloud
                this.languagesPending = []; // Array of languages waiting to be registered
                this.linkedScripts = [];
                /**
                 * Get an associative array of keyboard identification strings
                 *   This was defined as an array, so is kept that way, but
                 *   Javascript treats it as an object anyway
                 *
                 * @param       {Object}    Lkbd       Keyboard object
                 * @return      {Object}               Copy of keyboard identification strings
                 *
                 */
                this._GetKeyboardDetail = function (Lkbd) {
                    var Lr = {};
                    Lr['Name'] = Lkbd['KN'];
                    Lr['InternalName'] = Lkbd['KI'];
                    Lr['LanguageName'] = Lkbd['KL']; // I1300 - Add support for language names
                    Lr['LanguageCode'] = Lkbd['KLC']; // I1702 - Add support for language codes, region names, region codes, country names and country codes
                    Lr['RegionName'] = Lkbd['KR'];
                    Lr['RegionCode'] = Lkbd['KRC'];
                    Lr['CountryName'] = Lkbd['KC'];
                    Lr['CountryCode'] = Lkbd['KCC'];
                    Lr['KeyboardID'] = Lkbd['KD'];
                    Lr['Font'] = Lkbd['KFont'];
                    Lr['OskFont'] = Lkbd['KOskFont'];
                    return Lr;
                };
                this.keymanweb = kmw;
            }
            KeyboardManager.prototype.getActiveKeyboardName = function () {
                return this.activeKeyboard ? this.activeKeyboard['KI'] : '';
            };
            KeyboardManager.prototype.getActiveKeyboardTag = function () {
                return this.activeKeyboard ? this.activeKeyboard['_kmw'] : null;
            };
            KeyboardManager.prototype.getActiveLanguage = function (fullName) {
                if (this.activeStub == null) {
                    return '';
                }
                else if (fullName) {
                    return this.activeStub['KL'];
                }
                else {
                    return this.activeStub['KLC'];
                }
            };
            /**
             * Get array of available keyboard stubs
             *
             * @return   {Array}     Array of available keyboards
             *
             */
            KeyboardManager.prototype.getDetailedKeyboards = function () {
                var Lr = [], Ln, Lstub, Lrn;
                for (Ln = 0; Ln < this.keyboardStubs.length; Ln++) // I1511 - array prototype extended
                 {
                    Lstub = this.keyboardStubs[Ln];
                    Lrn = this._GetKeyboardDetail(Lstub); // I2078 - Full keyboard detail
                    Lr = this.keymanweb._push(Lr, Lrn); // TODO:  Resolve without need for the cast.
                }
                return Lr;
            };
            KeyboardManager.prototype.registerDeferredStubs = function () {
                this.addKeyboardArray(this.deferredStubs);
                // KRS stubs (legacy format registration)    
                for (var j = 0; j < this.deferredKRS.length; j++) {
                    this._registerStub(this.deferredKRS[j]);
                }
            };
            KeyboardManager.prototype.registerDeferredKeyboards = function () {
                for (var j = 0; j < this.deferredKR.length; j++) {
                    this._registerKeyboard(this.deferredKR[j]);
                }
            };
            /**
             * Register a fully specified keyboard (add meta-data for each language) immediately
             *
             * @param  {Object}  arg
             * @returns {boolean}
             **/
            KeyboardManager.prototype.addStub = function (arg) {
                if (typeof (arg['id']) != 'string') {
                    return false;
                }
                if (typeof (arg['language']) != "undefined") {
                    console.warn("The 'language' property for keyboard stubs has been deprecated.  Please use the 'languages' property instead.");
                    arg['languages'] = arg['language'];
                }
                if (typeof (arg['languages']) == 'undefined') {
                    return false;
                }
                // Default the keyboard name to its id, capitalized
                if (typeof (arg['name']) != 'string') {
                    arg['name'] = arg['id'].replace('_', ' ');
                    arg['name'] = arg['name'].substr(0, 1).toUpperCase() + arg['name'].substr(1);
                }
                var lgArg = arg['languages'];
                var lgList = [], i, lg;
                if (typeof (lgArg.length) == 'undefined') {
                    lgList[0] = lgArg;
                }
                else {
                    lgList = lgArg;
                }
                var localOptions = {
                    'keyboardBaseUri': this.keymanweb.options['keyboards'],
                    'fontBaseUri': this.keymanweb.options['fonts']
                };
                // Add a stub for each correctly specified language
                for (i = 0; i < lgList.length; i++) {
                    this.mergeStub(arg, lgList[i], localOptions);
                }
                return true;
            };
            /**
             *  Create or update a keyboard meta-data 'stub' during keyboard registration
             *
             *  Cross-reference with https://help.keyman.com/developer/engine/web/11.0/reference/core/addKeyboards.
             *
             *  @param  {Object}  kp  (partial) keyboard meta-data object (`spec` object)
             *  @param  {Object}  lp  language object (`spec.languages` object)
             *  @param  {Object}  options   KeymanCloud callback options
             **/
            KeyboardManager.prototype.mergeStub = function (kp, lp, options) {
                var sp = this.findStub(kp['id'], lp['id']);
                var isNew = false;
                if (sp == null) {
                    sp = new KeyboardStub(kp['id'], lp['id']);
                    this.keyboardStubs.push(sp);
                    isNew = true;
                }
                // Accept region as number (from Cloud server), code, or name
                var region = lp['region'], rIndex = 0;
                if (typeof (region) == 'number') {
                    if (region < 1 || region > 9) {
                        rIndex = 0;
                    }
                    else {
                        rIndex = region - 1;
                    }
                }
                else if (typeof (region) == 'string') {
                    var list = (region.length == 2 ? KeyboardManager.regionCodes : KeyboardManager.regions);
                    for (var i = 0; i < list.length; i++) {
                        if (region.toLowerCase() == list[i].toLowerCase()) {
                            rIndex = i;
                            break;
                        }
                    }
                }
                var rx;
                sp['KL'] = (typeof sp['KL'] === 'undefined') ? lp['name'] : sp['KL'];
                sp['KR'] = (typeof sp['KR'] === 'undefined') ? KeyboardManager.regions[rIndex] : sp['KR'];
                sp['KRC'] = (typeof sp['KRC'] === 'undefined') ? KeyboardManager.regionCodes[rIndex] : sp['KRC'];
                sp['KN'] = (typeof sp['KN'] === 'undefined') ? kp['name'] : sp['KN'];
                if (typeof (sp['KF']) == 'undefined') {
                    rx = RegExp('^(([\\.]/)|([\\.][\\.]/)|(/))|(:)');
                    sp['KF'] = kp['filename'];
                    if (!rx.test(sp['KF'])) {
                        sp['KF'] = options['keyboardBaseUri'] + sp['KF'];
                    }
                }
                // Font path defined by cloud entry
                var fontPath = options['fontBaseUri'];
                // or overridden locally, in page source
                if (this.keymanweb.options['fonts'] != '') {
                    fontPath = this.keymanweb.options['fonts'];
                    rx = new RegExp('^https?\\:');
                    if (!rx.test(fontPath)) {
                        if (fontPath.substr(0, 2) == '//') {
                            fontPath = this.keymanweb.protocol + fontPath;
                        }
                        else if (fontPath.substr(0, 1) == '/') {
                            fontPath = this.keymanweb.rootPath + fontPath.substr(1);
                        }
                        else {
                            fontPath = this.keymanweb.rootPath + fontPath;
                        }
                    }
                }
                else {
                    this.keymanweb.options.fonts = fontPath;
                }
                // Add font specifiers where necessary and not overridden by user
                if (typeof (lp['font']) != 'undefined') {
                    sp['KFont'] = (typeof sp['KFont'] === 'undefined') ? new KeyboardFont(lp['font'], fontPath) : sp['KFont'];
                }
                // Fixed OSK font issue Github #7 (9/1/2015)
                if (typeof (lp['oskFont']) != 'undefined') {
                    sp['KOskFont'] = (typeof sp['KOskFont'] === 'undefined') ? new KeyboardFont(lp['oskFont'], fontPath) : sp['KOskFont'];
                }
                // Update the UI 
                this.doKeyboardRegistered(sp['KI'], sp['KL'], sp['KN'], sp['KLC'], sp['KP']);
                // If we have no activeStub because there were no stubs, set the new keyboard as active.
                // Do not trigger on merges.
                if (!this.activeStub && isNew && this.keyboardStubs.length == 1) {
                    // #676: We call _SetActiveKeyboard so we can avoid overwriting 
                    // cookies that determine our active keyboard at page load time
                    this.doBeforeKeyboardChange(sp['KI'], sp['KLC']);
                    this._SetActiveKeyboard(sp['KI'], sp['KLC'], false);
                    this.doKeyboardChange(sp['KI'], sp['KLC']);
                }
            };
            /**
             *  Find a keyboard stub by id in the registered keyboards list
             *
             *  @param  {string}  kid   internal keyboard id (without 'Keyboard_' prefix)
             *  @param  {string}  lgid  language code
             *
             **/
            KeyboardManager.prototype.findStub = function (kid, lgid) {
                var i;
                for (i = 0; i < this.keyboardStubs.length; i++) {
                    if ((this.keyboardStubs[i]['KI'] == 'Keyboard_' + kid) && (this.keyboardStubs[i]['KLC'] == lgid)) {
                        return this.keyboardStubs[i];
                    }
                }
                return null;
            };
            // Called on the embedded path at the end of its initialization.
            KeyboardManager.prototype.setDefaultKeyboard = function () {
                if (this.keyboardStubs.length > 0) {
                    // Select the first stub as our active keyboard.
                    this._SetActiveKeyboard(this.keyboardStubs[0]['KI'], this.keyboardStubs[0]['KLC']);
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
             * Allow to change active keyboard by (internal) keyboard name
             *
             * @param       {string}    PInternalName   Internal name
             * @param       {string}    PLgCode         Language code
             */
            KeyboardManager.prototype.setActiveKeyboard = function (PInternalName, PLgCode) {
                //TODO: This does not make sense: the callbacks should be in _SetActiveKeyboard, not here,
                //      since this is always called FROM the UI, which should not need notification.
                //      If UI callbacks are needed at all, they should be within _SetActiveKeyboard 
                // Skip on embedded which namespaces packageID::Keyboard_keyboardID
                if (!this.keymanweb.isEmbedded && PInternalName && PInternalName.indexOf("Keyboard_") != 0) {
                    PInternalName = "Keyboard_" + PInternalName;
                }
                this.doBeforeKeyboardChange(PInternalName, PLgCode);
                var p = this._SetActiveKeyboard(PInternalName, PLgCode, true);
                if (this.keymanweb.domManager.getLastActiveElement() != null) {
                    this.keymanweb.domManager.focusLastActiveElement(); // TODO:  Resolve without need for the cast.
                }
                // If we ever allow PLgCode to be set by default, we can auto-detect the language code
                // after the _SetActiveKeyboard call.
                // if(!PLgCode && (<KeymanBase>keymanweb).keyboardManager.activeStub) {
                //   PLgCode = (<KeymanBase>keymanweb).keyboardManager.activeStub['KLC'];
                // }
                this.doKeyboardChange(PInternalName, PLgCode);
                return p;
            };
            /**
             * Change active keyboard to keyboard selected by (internal) name and language code
             *
             *  Test if selected keyboard already loaded, and simply update active stub if so.
             *  Otherwise, insert a script to download and insert the keyboard from the repository
             *  or user-indicated file location.
             *
             * Note that the test-case oriented 'recorder' stubs this method to provide active
             * keyboard stub information.  If changing this function, please ensure the recorder is
             * not affected.
             *
             * @param       {string}    PInternalName
             * @param       {string=}    PLgCode
             * @param       {boolean=}   saveCookie
             */
            KeyboardManager.prototype._SetActiveKeyboard = function (PInternalName, PLgCode, saveCookie) {
                var n, Ln;
                var util = this.keymanweb.util;
                var osk = this.keymanweb.osk;
                // Set default language code
                if (arguments.length < 2 || (!PLgCode)) {
                    PLgCode = '---';
                }
                // Check that the saved keyboard is currently registered
                for (n = 0; n < this.keyboardStubs.length; n++) {
                    if (PInternalName == this.keyboardStubs[n]['KI']) {
                        if (PLgCode == this.keyboardStubs[n]['KLC'] || PLgCode == '---')
                            break;
                    }
                }
                // Mobile device addition: force selection of the first keyboard if none set
                if (util.device.touchable && (PInternalName == '' || PInternalName == null || n >= this.keyboardStubs.length)) {
                    if (this.keyboardStubs.length != 0) {
                        PInternalName = this.keyboardStubs[0]['KI'];
                        PLgCode = this.keyboardStubs[0]['KLC'];
                    }
                }
                // Save name of keyboard (with language code) as a cookie
                if (arguments.length > 2 && saveCookie) {
                    this.saveCurrentKeyboard(PInternalName, PLgCode);
                }
                // Check if requested keyboard and stub are currently active
                if (this.activeStub && this.activeKeyboard && this.activeKeyboard['KI'] == PInternalName
                    && this.activeStub['KI'] == PInternalName //this part of test should not be necessary, but keep anyway
                    && this.activeStub['KLC'] == PLgCode && !this.keymanweb.mustReloadKeyboard)
                    return Promise.resolve();
                // Check if current keyboard matches requested keyboard, but not stub
                if (this.activeKeyboard && (this.activeKeyboard['KI'] == PInternalName)) {
                    // If so, simply update the active stub
                    for (Ln = 0; Ln < this.keyboardStubs.length; Ln++) {
                        if ((this.keyboardStubs[Ln]['KI'] == PInternalName)
                            && (this.keyboardStubs[Ln]['KLC'] == PLgCode)) {
                            this.activeStub = this.keyboardStubs[Ln];
                            // Append a stylesheet for this keyboard for keyboard specific styles 
                            // or if needed to specify an embedded font
                            osk.vkbd.appendStyleSheet();
                            // Re-initializate OSK before returning if required
                            if (this.keymanweb.mustReloadKeyboard) {
                                osk._Load();
                            }
                            return Promise.resolve();
                        }
                    }
                }
                this.activeKeyboard = null;
                this.activeStub = null;
                // Hide OSK and do not update keyboard list if using internal keyboard (desktops)
                if (PInternalName == '') {
                    osk._Hide(false);
                    if (!this.keymanweb.isEmbedded) {
                        util.wait(false);
                    }
                    return Promise.resolve();
                }
                // Determine if the keyboard was previously loaded but is not active and use the prior load if so.
                for (Ln = 0; Ln < this.keyboards.length; Ln++) { // I1511 - array prototype extended
                    if (this.keyboards[Ln]['KI'] == PInternalName) {
                        this.activeKeyboard = this.keyboards[Ln];
                        this.keymanweb.domManager._SetTargDir(this.keymanweb.domManager.getLastActiveElement()); // I2077 - LTR/RTL timing
                        // and update the active stub
                        for (var Ls = 0; Ls < this.keyboardStubs.length; Ls++) {
                            if ((this.keyboardStubs[Ls]['KI'] == PInternalName) &&
                                (this.keyboardStubs[Ls]['KLC'] == PLgCode || PLgCode == '---')) {
                                this.activeStub = this.keyboardStubs[Ls];
                                break;
                            }
                        }
                        break;
                    }
                }
                if (this.activeKeyboard == null) {
                    for (Ln = 0; Ln < this.keyboardStubs.length; Ln++) { // I1511 - array prototype extended
                        if ((this.keyboardStubs[Ln]['KI'] == PInternalName)
                            && ((this.keyboardStubs[Ln]['KLC'] == PLgCode) || (PLgCode == '---'))) {
                            // Force OSK display for CJK keyboards (keyboards using a pick list)
                            if (this.isCJK(this.keyboardStubs[Ln]) || util.device.touchable) {
                                osk._Enabled = true;
                            }
                            // Create a script to load from the server - when it finishes loading, it will register itself, 
                            //  detect that it is active, and focus as appropriate. The second test is needed to allow recovery from a failed script load
                            // Ensure we're not already loading the keyboard.
                            if (!this.keyboardStubs[Ln].asyncLoader) {
                                // Always (temporarily) hide the OSK when loading a new keyboard, to ensure that a failure to load doesn't leave the current OSK displayed
                                if (osk.ready) {
                                    osk._Hide(false);
                                }
                                var loadingStub = this.keyboardStubs[Ln];
                                // Tag the stub so that we don't double-load the keyboard!
                                loadingStub.asyncLoader = {};
                                var kbdName = loadingStub['KN'];
                                var lngName = loadingStub['KL'];
                                kbdName = kbdName.replace(/\s*keyboard\s*/i, '');
                                // Setup our default error-messaging callback if it should be implemented.
                                loadingStub.asyncLoader.callback = function (altString, msgType) {
                                    var msg = altString || 'Sorry, the ' + kbdName + ' keyboard for ' + lngName + ' is not currently available.';
                                    // Thanks, Closure errors.  
                                    if (!this.keymanweb.isEmbedded) {
                                        util.wait(false);
                                        util.alert(altString || msg, function () {
                                            this.keymanweb['setActiveKeyboard'](''); // The API call!
                                        }.bind(this));
                                    }
                                    switch (msgType) { // in case we extend this later.
                                        case 'err':
                                            console.error(msg);
                                            break;
                                        case 'warn':
                                        default:
                                            console.warn(msg);
                                            break;
                                    }
                                    if (Ln > 0) {
                                        var Ps = this.keyboardStubs[0];
                                        this._SetActiveKeyboard(Ps['KI'], Ps['KLC'], true);
                                    }
                                }.bind(this);
                                loadingStub.asyncLoader.timer = window.setTimeout(loadingStub.asyncLoader.callback, 10000);
                                //Display the loading delay bar (Note: only append 'keyboard' if not included in name.) 
                                if (!this.keymanweb.isEmbedded) {
                                    util.wait('Installing keyboard<br/>' + kbdName);
                                }
                                // Installing the script immediately does not work reliably if two keyboards are
                                // loaded in succession if there is any delay in downloading the script.
                                // It works much more reliably if deferred (KMEW-101, build 356)
                                // The effect of a delay can also be tested, for example, by setting the timeout to 5000
                                var manager = this;
                                loadingStub.asyncLoader.promise = new Promise(function (resolve, reject) {
                                    window.setTimeout(function () {
                                        manager.installKeyboard(resolve, reject, loadingStub);
                                    }, 0);
                                });
                            }
                            this.activeStub = this.keyboardStubs[Ln];
                            return this.keyboardStubs[Ln].asyncLoader.promise;
                        }
                    }
                    this.keymanweb.domManager._SetTargDir(this.keymanweb.domManager.getLastActiveElement()); // I2077 - LTR/RTL timing
                }
                var Pk = this.activeKeyboard; // I3319
                if (Pk !== null) // I3363 (Build 301)
                    String.kmwEnableSupplementaryPlane(Pk && ((Pk['KS'] && (Pk['KS'] == 1)) || (Pk['KN'] == 'Hieroglyphic'))); // I3319
                // Initialize the OSK (provided that the base code has been loaded)
                osk._Load();
                return Promise.resolve();
            };
            /**
             * Install a keyboard script that has been downloaded from a keyboard server
             * Operates as the core of a Promise, hence the 'resolve' and 'reject' parameters.
             *
             *  @param  {Object}  kbdStub   keyboard stub to be loaded.
             *
             **/
            KeyboardManager.prototype.installKeyboard = function (resolve, reject, kbdStub) {
                var util = this.keymanweb.util;
                var osk = this.keymanweb.osk;
                var Lscript = util._CreateElement('script');
                Lscript.charset = "UTF-8"; // KMEW-89
                Lscript.type = 'text/javascript';
                // Preserve any namespaced IDs by use of the script's id tag attribute!
                if (this.keymanweb.isEmbedded) {
                    Lscript.id = kbdStub['KI'];
                }
                var kbdFile = kbdStub['KF'];
                var kbdLang = kbdStub['KL'];
                var kbdName = kbdStub['KN'];
                var manager = this;
                // Add a handler for cases where the new <script> block fails to load.
                Lscript.addEventListener('error', function () {
                    if (kbdStub.asyncLoader.timer !== null) {
                        // Clear the timeout timer.
                        window.clearTimeout(kbdStub.asyncLoader.timer);
                        kbdStub.asyncLoader.timer = null;
                    }
                    // We already know the load has failed... why wait?
                    kbdStub.asyncLoader.callback('Cannot find the ' + kbdName + ' keyboard for ' + kbdLang + '.', 'warn');
                    kbdStub.asyncLoader = null;
                    reject();
                }, false);
                // The load event will activate a newly-loaded keyboard if successful and report an error if it is not.
                Lscript.addEventListener('load', function () {
                    if (kbdStub.asyncLoader.timer !== null) {
                        // Clear the timeout timer.
                        window.clearTimeout(kbdStub.asyncLoader.timer);
                        kbdStub.asyncLoader.timer = null;
                    }
                    // To determine if the load was successful, we'll need to check the keyboard array for our desired keyboard.
                    // Test if keyboard already loaded
                    var kbd = manager.getKeyboardByID(kbdStub['KI']), Li;
                    if (kbd) { // Is cleared upon a successful load.
                        //Activate keyboard, if it's still the active stub.
                        if (kbdStub == manager.activeStub) {
                            manager.doBeforeKeyboardChange(kbd['KI'], kbdStub['KLC']);
                            manager.activeKeyboard = kbd;
                            if (manager.keymanweb.domManager.getLastActiveElement() != null) { // TODO:  Resolve without need for the cast.
                                manager.keymanweb.uiManager.justActivated = true; // TODO:  Resolve without need for the cast.
                                manager.keymanweb.domManager._SetTargDir(manager.keymanweb.domManager.getLastActiveElement());
                            }
                            String.kmwEnableSupplementaryPlane(kbd && ((kbd['KS'] && kbd['KS'] == 1) || kbd['KN'] == 'Hieroglyphic')); // I3319 - SMP extension, I3363 (Build 301)
                            manager.saveCurrentKeyboard(kbd['KI'], kbdStub['KLC']);
                            // Prepare and show the OSK for this keyboard
                            osk._Load();
                        }
                        // Remove the wait message, if defined
                        if (!manager.keymanweb.isEmbedded) {
                            util.wait(false);
                        }
                        kbdStub.asyncLoader = null;
                        resolve();
                        // A handler portion for cases where the new <script> block loads, but fails to process.
                    }
                    else { // Output error messages even when embedded - they're useful when debugging the apps and KMEA/KMEI engines.
                        kbdStub.asyncLoader.callback('Error registering the ' + kbdName + ' keyboard for ' + kbdLang + '.', 'error');
                        kbdStub.asyncLoader = null;
                        reject();
                    }
                }, false);
                // IE likes to instantly start loading the file when assigned to an element, so we do this after the rest
                // of our setup.  This method is not relocated here (yet) b/c it varies based upon 'native' vs 'embedded'.
                Lscript.src = this.keymanweb.getKeyboardPath(kbdFile);
                try {
                    document.body.appendChild(Lscript);
                    this.linkedScripts.push(Lscript);
                }
                catch (ex) {
                    try {
                        document.getElementsByTagName('head')[0].appendChild(Lscript);
                    }
                    catch (ex2) {
                        reject();
                    }
                }
            };
            /* TODO: why not use util.loadCookie and saveCookie?? */
            /**
             * Function     saveCurrentKeyboard
             * Scope        Private
             * @param       {string}    PInternalName       name of keyboard
             * @param       {string}    PLgCode             language code
             * Description Saves current keyboard as a cookie
             */
            KeyboardManager.prototype.saveCurrentKeyboard = function (PInternalName, PLgCode) {
                var s = "current=" + PInternalName + ":" + PLgCode;
                this.keymanweb.util.saveCookie('KeymanWeb_Keyboard', { 'current': PInternalName + ':' + PLgCode });
                // Additionally, make sure we save the (upcoming) per-control keyboard settings.
                // This allows us to ensure the keyboard is set correctly without waiting for focus event
                // triggers - very helpful for automated testing.
                if (!this.keymanweb.isEmbedded) {
                    this.keymanweb.touchAliasing._BlurKeyboardSettings(PInternalName, PLgCode);
                }
            };
            /**
             * Restore the most recently used keyboard, if still available
             */
            KeyboardManager.prototype.restoreCurrentKeyboard = function () {
                var stubs = this.keyboardStubs, i, n = stubs.length;
                // Do nothing if no stubs loaded
                if (stubs.length < 1)
                    return;
                // If no saved keyboard, default to US English, else first loaded stub
                var d = this.getSavedKeyboard();
                var t = d.split(':');
                // Identify the stub with the saved keyboard
                t = d.split(':');
                if (t.length < 2)
                    t[1] = '';
                // This loop is needed to select the correct stub when several apply to a given keyboard
                // TODO: There should be a better way!
                for (i = 0; i < n; i++) {
                    if (stubs[i]['KI'] == t[0] && (stubs[i]['KLC'] == t[1] || t[1] == ''))
                        break;
                }
                // Sets the default stub (as specified with the `getSavedKeyboard` call) as active.
                // if((i < n) || (device.touchable && (this.activeKeyboard == null)))
                if ((i < n) || (this.activeKeyboard == null)) {
                    this._SetActiveKeyboard(t[0], t[1], false);
                    this.keymanweb.globalKeyboard = t[0];
                    this.keymanweb.globalLanguageCode = t[1];
                    this.doKeyboardChange(t[0], t[1]); // And update the UI if necessary
                }
            };
            /**
             * Gets the cookie for the name and language code of the most recently active keyboard
             *
             *  Defaults to US English, but this needs to be user-set in later revision (TODO)
             *
             * @return      {string}          InternalName:LanguageCode
             **/
            KeyboardManager.prototype.getSavedKeyboard = function () {
                var v = this.keymanweb.util.loadCookie('KeymanWeb_Keyboard');
                if (typeof (v['current']) != 'string') {
                    return 'Keyboard_us:eng';
                }
                // Check that the requested keyboard is included in the available keyboard stubs
                var n, stubs = this.keyboardStubs, kd;
                for (n = 0; n < stubs.length; n++) {
                    kd = stubs[n]['KI'] + ':' + stubs[n]['KLC'];
                    if (kd == v['current'])
                        return kd;
                }
                // Default to US English if available (but don't assume it is first)
                for (n = 0; n < stubs.length; n++) {
                    kd = stubs[n]['KI'] + ':' + stubs[n]['KLC'];
                    if (kd == 'Keyboard_us:eng')
                        return kd;
                }
                // Otherwise use the first keyboard stub
                if (stubs.length > 0) {
                    return stubs[0]['KI'] + ':' + stubs[0]['KLC'];
                }
                // Or US English if no stubs loaded (should never happen)
                return 'Keyboard_us:eng';
            };
            /**
             * Function    isCJK
             * Scope       Public
             * @param      {Object=}  k0
             * @return     {boolean}
             * Description Tests if active keyboard (or optional argument) uses a pick list (Chinese, Japanese, Korean, etc.)
             *             (This function accepts either keyboard structure.)
             */
            KeyboardManager.prototype.isCJK = function (k0) {
                var k = this.activeKeyboard, lg = '';
                if (arguments.length > 0) {
                    k = k0;
                }
                if (k) {
                    if (typeof (k['KLC']) != 'undefined') {
                        lg = k['KLC'];
                    }
                    else if (typeof (k['LanguageCode']) != 'undefined') {
                        lg = k['LanguageCode'];
                    }
                }
                return ((lg == 'cmn') || (lg == 'jpn') || (lg == 'kor'));
            };
            KeyboardManager.prototype.isRTL = function (k0) {
                var k = k0 || this.activeKeyboard;
                return (k != null) && (k['KRTL']);
            };
            /**
             * Function     isChiral
             * Scope        Public
             * @param       {string|Object=}   k0
             * @return      {boolean}
             * Description  Tests if the active keyboard (or optional argument) uses chiral modifiers.
             */
            KeyboardManager.prototype.isChiral = function (k0) {
                if (typeof (k0) == "string") {
                    k0 = this.getKeyboardByID(k0);
                }
                return !!(this.getKeyboardModifierBitmask(k0) & keyman_7.text.Codes.modifierBitmasks.IS_CHIRAL);
            };
            /**
             * Function     getKeyboardModifierBitmask
             * Scope        Private
             * @param       {Object=}   k0
             * @return      {number}
             * Description  Obtains the currently-active modifier bitmask for the active keyboard.
             */
            KeyboardManager.prototype.getKeyboardModifierBitmask = function (k0) {
                var k = this.activeKeyboard;
                if (arguments.length > 0 && typeof k0 != 'undefined') {
                    k = k0;
                }
                if (!k) {
                    return 0x0000;
                }
                if (k['KMBM']) {
                    return k['KMBM'];
                }
                return keyman_7.text.Codes.modifierBitmasks['NON_CHIRAL'];
            };
            KeyboardManager.prototype.getFont = function (k0) {
                var k = k0 || this.activeKeyboard;
                if (k && k['KV']) {
                    return k['KV']['F'];
                }
                return null;
            };
            KeyboardManager.prototype.layoutIsDesktopBased = function (k0) {
                var keyman = com.keyman.singleton;
                var k = k0 || this.activeKeyboard;
                if (k && k['KVKL']) {
                    // A custom mobile layout is defined... but are we using it?
                    return keyman.util.device.formFactor == 'desktop';
                }
                else {
                    return true;
                }
            };
            /**
             * Function     _getKeyboardByID
             * Scope        Private
             * @param       {string}  keyboardID
             * @return      {Object|null}
             * Description  Returns the internal, registered keyboard object - not the stub, but the keyboard itself.
             */
            KeyboardManager.prototype.getKeyboardByID = function (keyboardID) {
                var Li;
                for (Li = 0; Li < this.keyboards.length; Li++) {
                    if (keyboardID == this.keyboards[Li]['KI']) {
                        return this.keyboards[Li];
                    }
                }
                return null;
            };
            /* ------------------------------------------------------------
            *  Definitions for adding, removing, and requesting keyboards.
            *  ------------------------------------------------------------
            */
            /**
             * Function       isUniqueRequest
             * Scope          Private
             * @param         {Object}    tEntry
             * Description    Checks to ensure that the stub isn't already loaded within KMW or subject
             *                to an already-pending request.
             */
            KeyboardManager.prototype.isUniqueRequest = function (cloudList, tEntry) {
                var k;
                if (this.findStub(tEntry.id, tEntry.language) == null) {
                    for (k = 0; k < cloudList.length; k++) {
                        if (cloudList[k].id == tEntry['id'] && cloudList[k].language == tEntry.language) {
                            return false;
                        }
                    }
                    return true;
                }
                else {
                    return false;
                }
            };
            ;
            /**
             * Build 362: addKeyboardArray() link to Cloud. One or more arguments may be used
             *
             * @param {string|Object} x keyboard name string or keyboard metadata JSON object
             *
             */
            KeyboardManager.prototype.addKeyboardArray = function (x) {
                // Store all keyboard meta-data for registering later if called before initialization
                if (!this.keymanweb.initialized) {
                    for (var k = 0; k < x.length; k++) {
                        this.deferredStubs.push(x[k]);
                    }
                    return;
                }
                // Ignore empty array passed as argument
                if (x.length == 0) {
                    return;
                }
                // Create a temporary array of metadata objects from the arguments used
                var i, j, kp, kbid, lgid, kvid, cmd = '', comma = '';
                var cloudList = [];
                var tEntry;
                for (i = 0; i < x.length; i++) {
                    if (typeof (x[i]) == 'string' && x[i].length > 0) {
                        var pList = x[i].split('@'), lList = [''];
                        if (pList[0].toLowerCase() == 'english') {
                            pList[0] = 'us';
                        }
                        if (pList.length > 1) {
                            lList = pList[1].split(',');
                        }
                        for (j = 0; j < lList.length; j++) {
                            tEntry = new CloudRequestEntry(pList[0]);
                            if (lList[j] != '') {
                                tEntry.language = lList[j];
                            }
                            if (pList.length > 2) {
                                tEntry.version = pList[2];
                            }
                            // If we've already registered or requested a stub for this keyboard-language pairing,
                            // don't bother with a cloud request.
                            if (this.isUniqueRequest(cloudList, tEntry)) {
                                cloudList.push(tEntry);
                            }
                        }
                    }
                    if (typeof (x[i]) == 'object' && x[i] != null) {
                        // Register any local keyboards immediately:
                        // - must specify filename, keyboard name, language codes, region codes
                        // - no request will be sent to cloud
                        var stub = x[i];
                        if (typeof (x[i]['filename']) == 'string') {
                            if (!this.addStub(x[i])) {
                                alert('To use a custom keyboard, you must specify file name, keyboard name, language, language code and region code.');
                            }
                        }
                        else {
                            if (x[i]['language']) {
                                console.warn("The 'language' property for keyboard stubs has been deprecated.  Please use the 'languages' property instead.");
                                x[i]['languages'] = x[i]['language'];
                            }
                            lList = x[i]['languages'];
                            //Array or single entry?
                            if (typeof (lList.length) == 'number') {
                                for (j = 0; j < lList.length; j++) {
                                    tEntry = new CloudRequestEntry(x[i]['id'], x[i]['languages'][j]['id']);
                                    if (this.isUniqueRequest(cloudList, tEntry)) {
                                        cloudList.push(tEntry);
                                    }
                                }
                            }
                            else { // Single language element
                                tEntry = new CloudRequestEntry(x[i]['id'], x[i]['languages'][j]['id']);
                                if (this.isUniqueRequest(cloudList, tEntry)) {
                                    cloudList.push(tEntry);
                                }
                            }
                        }
                    }
                }
                // Return if all keyboards being registered are local and fully specified
                if (cloudList.length == 0) {
                    return;
                }
                // Update the keyboard metadata list from keyman.com - build the command
                cmd = '&keyboardid=';
                for (i = 0; i < cloudList.length; i++) {
                    cmd = cmd + comma + cloudList[i].toString();
                    comma = ',';
                }
                // Request keyboard metadata from the Keyman Cloud keyboard metadata server
                this.keymanCloudRequest(cmd, false);
            };
            /**
             *  Register a keyboard for each associated language
             *
             *  @param  {Object}  kp  Keyboard Object or Object array
             *  @param  {Object}  options   keymanCloud callback options
             *  @param  {number}  nArg  keyboard index in argument array
             *
             **/
            KeyboardManager.prototype.registerLanguagesForKeyboard = function (kp, options, nArg) {
                var i, j, id, nDflt = 0, kbId = '';
                // Do not attempt to process badly formatted requests
                if (typeof (kp) == 'undefined') {
                    return;
                }
                if (typeof (options['keyboardid']) == 'string') {
                    kbId = options['keyboardid'].split(',')[nArg];
                }
                // When keyboards requested by language code, several keyboards may be returned as an array
                if (typeof (kp.length) == 'number') {
                    // If language code is suffixed by $, register all keyboards for this language
                    if (kp.length == 1 || kbId.substr(-1, 1) == '$' || kbId == '') {
                        for (i = 0; i < kp.length; i++) {
                            this.registerLanguagesForKeyboard(kp[i], options, nArg);
                        }
                    }
                    // Register the default keyboard for the language code
                    // Until a default is defined, the default will be the Windows keyboard, 
                    // that is, the keyboard named for the language (exception: English:US), or the
                    // first keyboard found.
                    else {
                        for (i = 0; i < kp.length; i++) {
                            id = kp[i].id.toLowerCase();
                            if (id == 'us') {
                                id = 'english';
                            }
                            for (j = 0; j < kp[i]['languages'].length; j++) {
                                if (id == kp[i]['languages'][j]['name'].toLowerCase()) {
                                    nDflt = i;
                                    break;
                                }
                            }
                        }
                        this.registerLanguagesForKeyboard(kp[nDflt], options, nArg);
                    }
                }
                else { // Otherwise, process a single keyboard for the specified languages 
                    // May need to filter returned stubs by language
                    var lgCode = kbId.split('@')[1];
                    if (typeof (lgCode) == 'string') {
                        lgCode = lgCode.replace(/\$$/, '');
                    }
                    // Can only add keyboard stubs for defined languages
                    var ll = kp['languages'];
                    if (typeof (ll) != 'undefined') {
                        if (typeof (ll.length) == 'number') {
                            for (i = 0; i < ll.length; i++) {
                                if (typeof (lgCode) == 'undefined' || ll[i]['id'] == lgCode) {
                                    this.mergeStub(kp, ll[i], options);
                                }
                            }
                        }
                        else {
                            this.mergeStub(kp, ll, options);
                        }
                    }
                }
            };
            /**
             * Call back from cloud for adding keyboard metadata
             *
             * @param {Object}    x   metadata object
             **/
            KeyboardManager.prototype.register = function (x) {
                var options = x['options'];
                // Always clear the timer associated with this callback
                if (x['timerid']) {
                    window.clearTimeout(x['timerid']);
                }
                // Indicate if unable to register keyboard
                if (typeof (x['error']) == 'string') {
                    var badName = '';
                    if (typeof (x['keyboardid']) == 'string') {
                        badName = x['keyboardid'].substr(0, 1).toUpperCase() + x['keyboardid'].substr(1);
                    }
                    this.serverUnavailable(badName + ' keyboard not found.');
                    return;
                }
                // Ignore callback unless the context is defined
                if (typeof (options) == 'undefined' || typeof (options['context']) == 'undefined') {
                    return;
                }
                // Register each keyboard for the specified language codes
                if (options['context'] == 'keyboard') {
                    var i, kp = x['keyboard'];
                    // Process array of keyboard definitions
                    if (typeof (kp.length) == 'number') {
                        for (i = 0; i < kp.length; i++) {
                            this.registerLanguagesForKeyboard(kp[i], options, i);
                        }
                    }
                    else { // Process a single keyboard definition
                        this.registerLanguagesForKeyboard(kp, options, 0);
                    }
                }
                else if (options['context'] == 'language') { // Download the full list of supported keyboard languages
                    this.languageList = x['languages'];
                    if (this.languagesPending) {
                        this.addLanguageKeyboards(this.languagesPending);
                    }
                    this.languagesPending = [];
                }
            };
            /**
             *  Add default or all keyboards for a given language
             *
             *  @param  {Object}   languages    Array of language names
             **/
            KeyboardManager.prototype.addLanguageKeyboards = function (languages) {
                var i, j, lgName, cmd, first, addAll;
                // Defer registering keyboards by language until the language list has been loaded
                if (this.languageList == null) {
                    first = (this.languagesPending.length == 0);
                    for (i = 0; i < languages.length; i++) {
                        this.languagesPending.push(languages[i]);
                    }
                    if (first) {
                        this.keymanCloudRequest('', true);
                    }
                }
                else { // Identify and register each keyboard by language name
                    cmd = '';
                    for (i = 0; i < languages.length; i++) {
                        lgName = languages[i].toLowerCase();
                        addAll = (lgName.substr(-1, 1) == '$');
                        if (addAll) {
                            lgName = lgName.substr(0, lgName.length - 1);
                        }
                        for (j = 0; j < this.languageList.length; j++) {
                            if (lgName == this.languageList[j]['name'].toLowerCase()) {
                                if (cmd != '') {
                                    cmd = cmd + ',';
                                }
                                cmd = cmd + '@' + this.languageList[j]['id'];
                                if (addAll) {
                                    cmd = cmd + '$';
                                }
                                break;
                            }
                        }
                    }
                    if (cmd == '') {
                        this.keymanweb.util.alert('No keyboards are available for ' + languages[0] + '. '
                            + 'Does it have another language name?');
                    }
                    else {
                        this.keymanCloudRequest('&keyboardid=' + cmd, false);
                    }
                }
            };
            /**
             *  Request keyboard metadata from the Keyman Cloud keyboard metadata server
             *
             *  @param  {string}   cmd        command string
             *  @param  {boolean?} byLanguage if true, context=languages, else context=keyboards
             **/
            KeyboardManager.prototype.keymanCloudRequest = function (cmd, byLanguage) {
                var URL = 'https://api.keyman.com/cloud/4.0/', tFlag, Lscript = this.keymanweb.util._CreateElement('script');
                URL = URL + ((arguments.length > 1) && byLanguage ? 'languages' : 'keyboards')
                    + '?jsonp=keyman.register&languageidtype=bcp47&version=' + this.keymanweb['version'];
                var kbdManager = this;
                // Set callback timer
                tFlag = '&timerid=' + window.setTimeout(function () {
                    kbdManager.serverUnavailable(cmd);
                }, 10000);
                Lscript.charset = "UTF-8";
                Lscript.src = URL + cmd + tFlag;
                Lscript.type = 'text/javascript';
                try {
                    document.body.appendChild(Lscript);
                }
                catch (ex) {
                    document.getElementsByTagName('head')[0].appendChild(Lscript);
                }
            };
            /**
             *  Display warning if Keyman Cloud server fails to respond
             *
             *  @param  {string}  cmd command string sent to Cloud
             *
             **/
            KeyboardManager.prototype.serverUnavailable = function (cmd) {
                this.keymanweb.util.alert(cmd == '' ? 'Unable to connect to Keyman Cloud server!' : cmd);
                this.keymanweb.warned = true;
            };
            /**
             * Build 362: removeKeyboards() remove keyboard from list of available keyboards
             *
             * @param {string} x keyboard name string
             *
             */
            KeyboardManager.prototype.removeKeyboards = function (x) {
                if (arguments.length == 0) {
                    return false;
                }
                var i, j;
                var success = true, activeRemoved = false, anyRemoved = false;
                ;
                for (i = 0; i < arguments.length; i++) {
                    for (j = this.keyboardStubs.length - 1; j >= 0; j--) {
                        if ('Keyboard_' + arguments[i] == this.keyboardStubs[j]['KI']) {
                            if ('Keyboard_' + arguments[i] == this.getActiveKeyboardName()) {
                                activeRemoved = true;
                            }
                            anyRemoved = true;
                            this.keyboardStubs.splice(j, 1);
                            break;
                        }
                    }
                    if (j < 0) {
                        success = false;
                    }
                }
                if (activeRemoved) {
                    if (this.keyboardStubs.length > 0) {
                        // Always reset to the first remaining keyboard
                        this._SetActiveKeyboard(this.keyboardStubs[0]['KI'], this.keyboardStubs[0]['KLC'], true);
                    }
                    else {
                        this._SetActiveKeyboard('', '', false);
                    }
                    // This is likely to be triggered by a UI call of some sort, and we need to treat
                    // this call as such to properly maintain the globalKeyboard setting.
                    this.keymanweb.uiManager.justActivated = true;
                }
                if (anyRemoved) {
                    // Update the UI keyboard menu
                    this.doKeyboardUnregistered();
                }
                return success;
            };
            /**
             * Function     _registerKeyboard  KR
             * Scope        Public
             * @param       {Object}      Pk      Keyboard  object
             * Description  Register and load the keyboard
             */
            KeyboardManager.prototype._registerKeyboard = function (Pk) {
                // If initialization not yet complete, list the keyboard to be registered on completion of initialization
                if (!this.keymanweb.initialized) {
                    this.deferredKR.push(Pk);
                    return;
                }
                if (Pk['_kmw']) {
                    console.error("The keyboard _kmw property is a reserved field for engine use only; this keyboard is invalid.");
                    return;
                }
                else {
                    Pk['_kmw'] = new KeyboardTag();
                }
                var Li, Lstub;
                // For package namespacing with KMEA/KMEI.
                if (this.keymanweb.isEmbedded) {
                    this.keymanweb.preserveID(Pk);
                }
                // Check if the active stub refers to this keyboard, else find applicable stub
                var Ps = this.activeStub;
                var savedActiveStub = this.activeStub;
                if (!Ps || !('KI' in Ps) || (Ps['KI'] != Pk['KI'])) {
                    // Find the first stub for this keyboard
                    for (Lstub = 0; Lstub < this.keyboardStubs.length; Lstub++) { // I1511 - array prototype extended
                        Ps = this.keyboardStubs[Lstub];
                        if (Pk['KI'] == Ps['KI']) {
                            break;
                        }
                        Ps = null;
                    }
                }
                // Build 369: ensure active stub defined when loading local keyboards 
                if (this.activeStub == null && Ps != null) {
                    this.activeStub = Ps;
                }
                // Register the stub for this language (unless it is already registered)
                // keymanweb.KRS(Ps?Ps:Pk); 
                // Test if keyboard already loaded
                for (Li = 0; Li < this.keyboards.length; Li++) {
                    if (Pk['KI'] == this.keyboards[Li]['KI']) {
                        return;
                    }
                }
                // Append to keyboards array
                this.keyboards = this.keymanweb._push(this.keyboards, Pk); // TODO:  Resolve without need for the cast.
                // Execute any external (UI) code needed after loading keyboard
                this.doKeyboardLoaded(Pk['KI']);
                // Restore the originally-active stub to its prior state.  No need to change it permanently.
                this.activeStub = savedActiveStub;
            };
            /**
             * Add the basic keyboard parameters (keyboard stub) to the array of keyboard stubs
             * If no language code is specified in a keyboard it cannot be registered,
             * and a keyboard stub must be registered before the keyboard is loaded
             * for the keyboard to be usable.
             *
             * @param       {Object}      Pstub     Keyboard stub object
             * @return      {?number}               1 if already registered, else null
             */
            KeyboardManager.prototype._registerStub = function (Pstub) {
                var Lk;
                // In initialization not complete, list the stub to be registered on completion of initialization
                if (!this.keymanweb.initialized) {
                    this.deferredKRS.push(Pstub);
                    return null;
                }
                // The default stub is always the first keyboard stub loaded [and will be ignored by desktop browsers - not for beta, anyway]
                if (this.dfltStub == null) {
                    this.dfltStub = Pstub;
                    //if(device.formFactor == 'desktop') return 1;    //Needs further thought before release
                }
                // If no language code has been defined, and no stub has been registered for this keyboard, register with empty string as the language code
                if (this.keymanweb.isEmbedded) {
                    this.keymanweb.namespaceID(Pstub);
                } // else leave undefined.  It's nice to condition upon.
                if (typeof (Pstub['KLC']) == 'undefined') {
                    Pstub['KLC'] = '';
                }
                if (typeof (Pstub['KL']) == 'undefined') {
                    Pstub['KL'] = 'undefined';
                }
                // If language code already defined (or not specified in stub), check to see if stub already registered
                for (Lk = 0; Lk < this.keyboardStubs.length; Lk++) {
                    if (this.keyboardStubs[Lk]['KI'] == Pstub['KI']) {
                        if (Pstub['KLC'] == '' || (this.keyboardStubs[Lk]['KLC'] == Pstub['KLC'])) {
                            return 1; // no need to register
                        }
                    }
                }
                // Register stub (add to KeyboardStubs array)
                this.keyboardStubs = this.keymanweb._push(this.keyboardStubs, Pstub); // TODO:  Resolve without need for the cast.
                // TODO: Need to distinguish between initial loading of a large number of stubs and any subsequent loading.
                //   UI initialization should not be needed for each registration, only at end.
                // Reload this keyboard if it was the last active keyboard and 
                // make any changes needed by UI for new keyboard stub
                // (Uncommented for Build 360)
                this.doKeyboardRegistered(Pstub['KI'], Pstub['KL'], Pstub['KN'], Pstub['KLC'], Pstub['KP']);
                // If we have no activeStub because there were no stubs, set the new keyboard as active.
                // Do not trigger on merges.
                if (!this.activeStub && this.dfltStub == Pstub && this.keyboardStubs.length == 1) {
                    this.setActiveKeyboard(Pstub['KI'], Pstub['KLC']);
                }
                return null;
            };
            /*
            * Last part - the events.
            */
            /**
             * Execute external (UI) code needed on registering keyboard, used
             * to update each UIs language menu
             *
             * Note that the argument object is not at present used by any UI,
             * since the menu is always fully recreated when needed, but the arguments
             * remain defined to allow for possible use in future (Aug 2014)
             *
             * @param       {string}            _internalName
             * @param       {string}            _language
             * @param       {string}            _keyboardName
             * @param       {string}            _languageCode
             * @param       {string=}           _packageID        Used by KMEA/KMEI to track .kmp related info.
             * @return      {boolean}
             */
            KeyboardManager.prototype.doKeyboardRegistered = function (_internalName, _language, _keyboardName, _languageCode, _packageID) {
                var p = { 'internalName': _internalName, 'language': _language, 'keyboardName': _keyboardName, 'languageCode': _languageCode };
                // Utilized only by our embedded codepaths.
                if (_packageID) {
                    p['package'] = _packageID;
                }
                return this.keymanweb.util.callEvent('kmw.keyboardregistered', p);
            };
            /**
             * Execute external (UI) code to rebuild menu when deregistering keyboard
             *
             * @return      {boolean}
             */
            KeyboardManager.prototype.doKeyboardUnregistered = function () {
                var p = {};
                return this.keymanweb.util.callEvent('kmw.keyboardregistered', p);
            };
            /**
             * Execute external (UI) code needed on loading keyboard
             *
             * @param       {string}            _internalName
             * @return      {boolean}
             */
            KeyboardManager.prototype.doKeyboardLoaded = function (_internalName) {
                var p = {};
                p['keyboardName'] = _internalName;
                return this.keymanweb.util.callEvent('kmw.keyboardloaded', p);
            };
            /**
             * Function     doBeforeKeyboardChange
             * Scope        Private
             * @param       {string}            _internalName
             * @param       {string}            _languageCode
             * @return      {boolean}
             * Description  Execute external (UI) code needed before changing keyboard
             */
            KeyboardManager.prototype.doBeforeKeyboardChange = function (_internalName, _languageCode) {
                var p = {};
                p['internalName'] = _internalName;
                p['languageCode'] = _languageCode;
                return this.keymanweb.util.callEvent('kmw.beforekeyboardchange', p);
            };
            /**
             * Execute external (UI) code needed *after* changing keyboard
             *
             * @param       {string}            _internalName
             * @param       {string}            _languageCode
             * @param       {boolean=}           _indirect
             * @return      {boolean}
             */
            KeyboardManager.prototype.doKeyboardChange = function (_internalName, _languageCode, _indirect) {
                var p = {
                    'internalName': _internalName,
                    'languageCode': _languageCode,
                    'indirect': (arguments.length > 2 ? _indirect : false)
                };
                return this.keymanweb.util.callEvent('kmw.keyboardchange', p);
            };
            KeyboardManager.prototype.shutdown = function () {
                for (var _i = 0, _a = this.linkedScripts; _i < _a.length; _i++) {
                    var script = _a[_i];
                    if (script.remove) {
                        script.remove();
                    }
                    else if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                }
            };
            // Language regions as defined by cloud server
            KeyboardManager.regions = ['World', 'Africa', 'Asia', 'Europe', 'South America', 'North America', 'Oceania', 'Central America', 'Middle East'];
            KeyboardManager.regionCodes = ['un', 'af', 'as', 'eu', 'sa', 'na', 'oc', 'ca', 'me'];
            return KeyboardManager;
        }());
        keyman_7.KeyboardManager = KeyboardManager;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var KeyMap = /** @class */ (function () {
            function KeyMap() {
            }
            return KeyMap;
        }());
        var BrowserKeyMaps = /** @class */ (function () {
            function BrowserKeyMaps() {
                this.FF = new KeyMap();
                this.Safari = new KeyMap();
                this.Opera = new KeyMap();
                //ffie['k109'] = 189; // -    // These two number-pad VK rules are *not* correct for more recent FF! JMD 8/11/12
                //ffie['k107'] = 187; // =    // FF 3.0 // I2062
                this.FF['k61'] = 187; // =   // FF 2.0
                this.FF['k59'] = 186; // ;
            }
            return BrowserKeyMaps;
        }());
        var LanguageKeyMaps = /** @class */ (function () {
            function LanguageKeyMaps() {
                /* I732 START - 13/03/2007 MCD: Swedish: Start mapping of keystroke to US keyboard #2 */
                // Swedish key map
                this['se'] = new KeyMap();
                this['se']['k220'] = 192; // `
                this['se']['k187'] = 189; // -
                this['se']['k219'] = 187; // =
                this['se']['k221'] = 219; // [
                this['se']['k186'] = 221; // ]
                this['se']['k191'] = 220; // \
                this['se']['k192'] = 186; // ;
                this['se']['k189'] = 191; // /
                this['uk'] = new KeyMap(); // I1299
                this['uk']['k223'] = 192; // // ` U+00AC (logical not) =>  ` ~
                this['uk']['k192'] = 222; // ' @  =>  ' "
                this['uk']['k222'] = 226; // # ~  => K_oE2     // I1504 - UK keyboard mixup #, \
                this['uk']['k220'] = 220; // \ |  => \ |       // I1504 - UK keyboard mixup #, \
            }
            return LanguageKeyMaps;
        }());
        var KeyMapManager = /** @class */ (function () {
            function KeyMapManager() {
                this.browserMap = new BrowserKeyMaps();
                this.languageMap = new LanguageKeyMaps();
                this._usCodeInit();
            }
            KeyMapManager.prototype._usCodeInit = function () {
                var s0 = new KeyMap(), s1 = new KeyMap();
                s0['k192'] = 96;
                s0['k49'] = 49;
                s0['k50'] = 50;
                s0['k51'] = 51;
                s0['k52'] = 52;
                s0['k53'] = 53;
                s0['k54'] = 54;
                s0['k55'] = 55;
                s0['k56'] = 56;
                s0['k57'] = 57;
                s0['k48'] = 48;
                s0['k189'] = 45;
                s0['k187'] = 61;
                s0['k81'] = 113;
                s0['k87'] = 119;
                s0['k69'] = 101;
                s0['k82'] = 114;
                s0['k84'] = 116;
                s0['k89'] = 121;
                s0['k85'] = 117;
                s0['k73'] = 105;
                s0['k79'] = 111;
                s0['k80'] = 112;
                s0['k219'] = 91;
                s0['k221'] = 93;
                s0['k220'] = 92;
                s0['k65'] = 97;
                s0['k83'] = 115;
                s0['k68'] = 100;
                s0['k70'] = 102;
                s0['k71'] = 103;
                s0['k72'] = 104;
                s0['k74'] = 106;
                s0['k75'] = 107;
                s0['k76'] = 108;
                s0['k186'] = 59;
                s0['k222'] = 39;
                s0['k90'] = 122;
                s0['k88'] = 120;
                s0['k67'] = 99;
                s0['k86'] = 118;
                s0['k66'] = 98;
                s0['k78'] = 110;
                s0['k77'] = 109;
                s0['k188'] = 44;
                s0['k190'] = 46;
                s0['k191'] = 47;
                s1['k192'] = 126;
                s1['k49'] = 33;
                s1['k50'] = 64;
                s1['k51'] = 35;
                s1['k52'] = 36;
                s1['k53'] = 37;
                s1['k54'] = 94;
                s1['k55'] = 38;
                s1['k56'] = 42;
                s1['k57'] = 40;
                s1['k48'] = 41;
                s1['k189'] = 95;
                s1['k187'] = 43;
                s1['k81'] = 81;
                s1['k87'] = 87;
                s1['k69'] = 69;
                s1['k82'] = 82;
                s1['k84'] = 84;
                s1['k89'] = 89;
                s1['k85'] = 85;
                s1['k73'] = 73;
                s1['k79'] = 79;
                s1['k80'] = 80;
                s1['k219'] = 123;
                s1['k221'] = 125;
                s1['k220'] = 124;
                s1['k65'] = 65;
                s1['k83'] = 83;
                s1['k68'] = 68;
                s1['k70'] = 70;
                s1['k71'] = 71;
                s1['k72'] = 72;
                s1['k74'] = 74;
                s1['k75'] = 75;
                s1['k76'] = 76;
                s1['k186'] = 58;
                s1['k222'] = 34;
                s1['k90'] = 90;
                s1['k88'] = 88;
                s1['k67'] = 67;
                s1['k86'] = 86;
                s1['k66'] = 66;
                s1['k78'] = 78;
                s1['k77'] = 77;
                s1['k188'] = 60;
                s1['k190'] = 62;
                s1['k191'] = 63;
                this._usCharCodes = [s0, s1];
            };
            /**
             * Function     _USKeyCodeToCharCode
             * Scope        Private
             * @param       {Event}     Levent      KMW event object
             * @return      {number}                Character code
             * Description Translate keyboard codes to standard US layout codes
             */
            KeyMapManager.prototype._USKeyCodeToCharCode = function (Levent) {
                return this._usCharCodes[Levent.Lmodifiers & 0x10 ? 1 : 0]['k' + Levent.Lcode];
            };
            ;
            return KeyMapManager;
        }());
        keyman.KeyMapManager = KeyMapManager;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman_8) {
        var Hotkey = /** @class */ (function () {
            function Hotkey(code, shift, handler) {
                this.code = code;
                this.shift = shift;
                this.handler = handler;
            }
            Hotkey.prototype.matches = function (keyCode, shiftState) {
                return (this.code == keyCode && this.shift == shiftState);
            };
            return Hotkey;
        }());
        var HotkeyManager = /** @class */ (function () {
            function HotkeyManager(keyman) {
                this.hotkeys = [];
                /**
                 * Function     _Process
                 * Scope        Private
                 * @param       {Event}       e       event
                 * Description  Passes control to handlers according to the hotkey pressed
                 */
                this._Process = function (e) {
                    if (!e) {
                        e = window.event;
                    }
                    var _Lcode = this.keyman.textProcessor._GetEventKeyCode(e);
                    if (_Lcode == null) {
                        return false;
                    }
                    // Removed testing of e.shiftKey==null  I3363 (Build 301)
                    var _Lmodifiers = (e.shiftKey ? 0x10 : 0) |
                        (e.ctrlKey ? 0x20 : 0) |
                        (e.altKey ? 0x40 : 0);
                    for (var i = 0; i < this.hotkeys.length; i++) {
                        if (this.hotkeys[i].matches(_Lcode, _Lmodifiers)) {
                            this.hotkeys[i].handler();
                            e.returnValue = false;
                            if (e && e.preventDefault) {
                                e.preventDefault();
                            }
                            e.cancelBubble = true;
                            return false;
                        }
                    }
                    return true;
                }.bind(this);
                this.keyman = keyman;
            }
            /**
             * Function     addHotkey
             * Scope        Public
             * @param       {number}            keyCode
             * @param       {number}            shiftState
             * @param       {function(Object)}  handler
             * Description  Add hot key handler to array of document-level hotkeys triggered by key up event
             */
            HotkeyManager.prototype.addHotKey = function (keyCode, shiftState, handler) {
                // Test if existing handler for this code and replace it if so
                for (var i = 0; i < this.hotkeys.length; i++) {
                    if (this.hotkeys[i].code == keyCode && this.hotkeys[i].shift == shiftState) {
                        this.hotkeys[i].handler = handler;
                        return;
                    }
                }
                // Otherwise add it to the array
                this.hotkeys.push(new Hotkey(keyCode, shiftState, handler));
            };
            /**
             * Function     removeHotkey
             * Scope        Public
             * @param       {number}        keyCode
             * @param       {number}        shiftState
             * Description  Remove a hot key handler from array of document-level hotkeys triggered by key up event
             */
            /*keymanweb['removeHotKey'] = */ HotkeyManager.prototype.removeHotkey = function (keyCode, shiftState) {
                for (var i = 0; i < this.hotkeys.length; i++) {
                    if (this.hotkeys[i].matches(keyCode, shiftState)) {
                        this.hotkeys.splice(i, 1);
                        return;
                    }
                }
            };
            return HotkeyManager;
        }());
        keyman_8.HotkeyManager = HotkeyManager;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman_9) {
        var UIState = /** @class */ (function () {
            function UIState(pending, activated) {
                this['activationPending'] = pending;
                this['activated'] = activated;
            }
            return UIState;
        }());
        keyman_9.UIState = UIState;
        var UIManager = /** @class */ (function () {
            function UIManager(keyman) {
                this.isActivating = false; // ActivatingKeymanWebUI - is the KeymanWeb DIV in process of being clicked on?
                this.justActivated = false; // JustActivatedKeymanWebUI - focussing back to control after KeymanWeb UI interaction
                /**
                 * Function     doUnload
                 * Scope        Private
                 * @return      {boolean}
                 * Description  Execute UI cleanup code before unloading the UI (may not be required?)
                 */
                this.doUnload = function () {
                    var p = {};
                    return this.keyman.util.callEvent('kmw.unloaduserinterface', p);
                };
                this.keyman = keyman;
            }
            /**
             * Function     getUIState
             * Scope        Public
             * @return      {Object.<string,boolean>}
             * Description  Return object with activation state of UI:
             *                activationPending (bool):   KMW being activated
             *                activated         (bool):   KMW active
             */
            UIManager.prototype.getUIState = function () {
                return new UIState(this.isActivating, this.justActivated);
            };
            /**
             * Set or clear the IsActivatingKeymanWebUI flag (exposed function)
             *
             * @param       {(boolean|number)}  state  Activate (true,false)
             */
            UIManager.prototype.setActivatingUI = function (state) {
                this.isActivating = state ? true : false;
            };
            /**
             * Function     doLoad
             * Scope        Private
             * @return      {boolean}
             * Description  Execute UI initialization code after loading the UI
             *              // Appears to be unused; could be eliminated?  Though, doUnload IS used.
             */
            UIManager.prototype.doLoad = function () {
                var p = {};
                return this.keyman.util.callEvent('kmw.loaduserinterface', p);
            };
            return UIManager;
        }());
        keyman_9.UIManager = UIManager;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 10.0
   Copyright 2017 SIL International
***/
///<reference path="../utils/version.ts"/>
var com;
(function (com) {
    var keyman;
    (function (keyman_10) {
        var osk;
        (function (osk) {
            var Codes = com.keyman.text.Codes;
            // This class manages default layout construction for consumption by OSKs without a specified layout.
            var Layouts = /** @class */ (function () {
                function Layouts() {
                }
                /**
                * Build a default layout for keyboards with no explicit layout
                *
                * @param   {Object}  PVK             keyboard object (as loaded)
                * @param   {Object}  kbdDevVersion   object representing the version of Developer that compiled the keyboard
                * @param   {number}  kbdBitmask      keyboard modifier bitmask
                * @param   {string}  formFactor
                * @return  {Object}
                */
                Layouts.buildDefaultLayout = function (PVK, kbdDevVersion, kbdBitmask, formFactor) {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    // Build a layout using the default for the device
                    var layoutType = formFactor;
                    if (typeof Layouts.dfltLayout[layoutType] != 'object') {
                        layoutType = 'desktop';
                    }
                    // Clone the default layout object for this device
                    var layout = util.deepCopy(Layouts.dfltLayout[layoutType]);
                    var n, layers = layout['layer'], keyLabels = PVK['KLS'], key102 = PVK['K102'];
                    var i, j, k, m, row, rows, key, keys;
                    var chiral = (kbdBitmask & Codes.modifierBitmasks.IS_CHIRAL) != 0;
                    var kmw10Plus = !(typeof keyLabels == 'undefined' || !keyLabels);
                    if (!kmw10Plus) {
                        // Save the processed key label information to the keyboard's general data.
                        // Makes things more efficient elsewhere and for reloading after keyboard swaps.
                        keyLabels = PVK['KLS'] = Layouts.processLegacyDefinitions(PVK['BK']);
                    }
                    // Identify key labels (e.g. *Shift*) that require the special OSK font
                    var specialLabel = /\*\w+\*/;
                    // *** Step 1:  instantiate the layer objects. ***
                    // Get the list of valid layers, enforcing that the 'default' layer must be the first one processed.
                    var validIdList = Object.getOwnPropertyNames(keyLabels), invalidIdList = [];
                    validIdList.splice(validIdList.indexOf('default'), 1);
                    validIdList = ['default'].concat(validIdList);
                    // Automatic AltGr emulation if the 'leftctrl-leftalt' layer is otherwise undefined.
                    if (Layouts.emulatesAltGr(keyLabels)) {
                        // We insert only the layers that need to be emulated.
                        if ((validIdList.indexOf('leftctrl-leftalt') == -1) && validIdList.indexOf('rightalt') != -1) {
                            validIdList.push('leftctrl-leftalt');
                            keyLabels['leftctrl-leftalt'] = keyLabels['rightalt'];
                        }
                        if ((validIdList.indexOf('leftctrl-leftalt-shift') == -1) && validIdList.indexOf('rightalt-shift') != -1) {
                            validIdList.push('leftctrl-leftalt-shift');
                            keyLabels['leftctrl-leftalt-shift'] = keyLabels['rightalt-shift'];
                        }
                    }
                    // For desktop devices, we must create all layers, even if invalid.
                    if (formFactor == 'desktop') {
                        invalidIdList = Layouts.generateLayerIds(chiral);
                        // Filter out all ids considered valid.  (We also don't want duplicates in the following list...)
                        for (n = 0; n < invalidIdList.length; n++) {
                            if (validIdList.indexOf(invalidIdList[n]) != -1) {
                                invalidIdList.splice(n--, 1);
                            }
                        }
                    }
                    // This ensures all 'valid' layers are at the front of the layer array and managed by the main loop below.
                    // 'invalid' layers aren't handled by the loop and thus remain blank after it.
                    var idList = validIdList.concat(invalidIdList);
                    if (kmw10Plus && formFactor != 'desktop') { // KLS exists, so we know the exact layer set.
                        // Find the SHIFT key...
                        var shiftKey = null;
                        rows = layers[0]['row'];
                        for (var r = 0; r < rows.length; r++) {
                            keys = rows[r]['key'];
                            for (var c = 0; c < keys.length; c++) {
                                key = keys[c];
                                if (key['id'] == 'K_SHIFT') {
                                    shiftKey = key;
                                }
                            }
                        }
                        if (shiftKey) {
                            // Erase the legacy shifted subkey array.
                            shiftKey['sk'] = [];
                            for (var layerID in keyLabels) {
                                if (layerID == 'default' || layerID == 'shift') {
                                    // These two are accessible from the layer without subkeys.
                                    continue;
                                }
                                // Create a new subkey for the specified layer so that it will be accessible via OSK.
                                var specialChar = Layouts.modifierSpecials[layerID];
                                shiftKey['sk'].push(new osk.OSKKeySpec("K_" + specialChar, specialChar, null, "1", layerID));
                            }
                        }
                        else {
                            // Seriously, this should never happen.  It's here for the debugging log only.
                            console.warn("Error in default layout - cannot find default Shift key!");
                        }
                    }
                    for (n = 0; n < idList.length; n++) {
                        // Populate non-default (shifted) keygroups
                        if (n > 0) {
                            layers[n] = util.deepCopy(layers[0]);
                        }
                        layers[n]['id'] = idList[n];
                        layers[n]['nextlayer'] = idList[n]; // This would only be different for a dynamic keyboard
                        // Extraced into a helper method to improve readability.
                        Layouts.formatDefaultLayer(layers[n], chiral, formFactor, !!key102);
                    }
                    // *** Step 2: Layer objects now exist; time to fill them with the appropriate key labels and key styles ***
                    for (n = 0; n < layers.length; n++) {
                        var layer = layers[n], kx, shiftKey = null, nextKey = null, allText = '';
                        var capsKey = null, numKey = null, scrollKey = null; // null if not in the OSK layout.
                        var layerSpec = keyLabels[layer['id']];
                        var isShift = layer['id'] == 'shift' ? 1 : 0;
                        var isDefault = layer['id'] == 'default' || isShift ? 1 : 0;
                        rows = layer['row'];
                        for (i = 0; i < rows.length; i++) {
                            keys = rows[i]['key'];
                            for (j = 0; j < keys.length; j++) {
                                key = keys[j];
                                kx = Layouts.dfltCodes.indexOf(key['id']);
                                // Only create keys for defined layers.  ('default' and 'shift' are always defined.)
                                if (layerSpec || isDefault) {
                                    // Get keycap text from visual keyboard array, if defined in keyboard
                                    if (layerSpec) {
                                        if (kx >= 0 && kx < layerSpec.length)
                                            key['text'] = layerSpec[kx];
                                    }
                                    // Legacy (pre 12.0) behavior:  fall back to US English keycap text as default for the base two layers
                                    // if a key cap is not otherwise defined. (Any intentional 'ghost' keys must be explicitly defined.)
                                    if (isDefault && kbdDevVersion.precedes(keyman_10.utils.Version.NO_DEFAULT_KEYCAPS)) {
                                        if (key['id'] != 'K_SPACE' && kx + 65 * isShift < Layouts.dfltText.length && key['text'] !== null) {
                                            key['text'] = key['text'] || Layouts.dfltText[kx + 65 * isShift];
                                        }
                                    }
                                }
                                // Leave any unmarked key caps as null strings
                                if (key['text'] !== null) {
                                    key['text'] = key['text'] || '';
                                }
                                // Detect important tracking keys.
                                switch (key['id']) {
                                    case "K_SHIFT":
                                        shiftKey = key;
                                        break;
                                    case "K_TAB":
                                        nextKey = key;
                                        break;
                                    case "K_CAPS":
                                        capsKey = key;
                                        break;
                                    case "K_NUMLOCK":
                                        numKey = key;
                                        break;
                                    case "K_SCROLL":
                                        scrollKey = key;
                                        break;
                                }
                                // Remove pop-up shift keys referencing invalid layers (Build 349)
                                if (key['sk'] != null) {
                                    for (k = 0; k < key['sk'].length; k++) {
                                        if (validIdList.indexOf(key['sk'][k]['nextlayer']) == -1) {
                                            key['sk'].splice(k--, 1);
                                        }
                                    }
                                    if (key['sk'].length == 0) {
                                        key['sk'] = null;
                                    }
                                }
                            }
                        }
                        // We're done with the layer keys initialization pass.  Time to do post-analysis layer-level init where necessary.
                        layer.shiftKey = shiftKey;
                        layer.capsKey = capsKey;
                        layer.numKey = numKey;
                        layer.scrollKey = scrollKey;
                        // Set modifier key appearance and behaviour for non-desktop devices using the default layout
                        if (formFactor != 'desktop') {
                            if (n > 0 && shiftKey != null) {
                                shiftKey['sp'] = Layouts.buttonClasses['SHIFT-ON'];
                                shiftKey['sk'] = null;
                                shiftKey['text'] = Layouts.modifierSpecials[layers[n].id] ? Layouts.modifierSpecials[layers[n].id] : "*Shift*";
                            }
                        }
                    }
                    return layout;
                };
                /**
             * Function     getLayerId
             * Scope        Private
             * @param       {number}      m     shift modifier code
             * @return      {string}            layer string from shift modifier code (desktop keyboards)
             * Description  Get name of layer from code, where the modifer order is determined by ascending bit-flag value.
             */
                Layouts.getLayerId = function (m) {
                    var modifierCodes = Codes.modifierCodes;
                    var s = '';
                    if (m == 0) {
                        return 'default';
                    }
                    else {
                        if (m & modifierCodes['LCTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'leftctrl';
                        }
                        if (m & modifierCodes['RCTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'rightctrl';
                        }
                        if (m & modifierCodes['LALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'leftalt';
                        }
                        if (m & modifierCodes['RALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'rightalt';
                        }
                        if (m & modifierCodes['SHIFT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'shift';
                        }
                        if (m & modifierCodes['CTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'ctrl';
                        }
                        if (m & modifierCodes['ALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'alt';
                        }
                        return s;
                    }
                };
                /**
                 * Signifies whether or not the OSK facilitates AltGr / Right-alt emulation for this keyboard.
                 * @param   {Object=}   keyLabels
                 * @return  {boolean}
                 */
                Layouts.emulatesAltGr = function (keyLabels) {
                    var layers;
                    var keyman = window['keyman'];
                    var modifierCodes = Codes.modifierCodes;
                    // If we're not chiral, we're not emulating.
                    if (!keyman.keyboardManager.isChiral()) {
                        return false;
                    }
                    if (!keyLabels) {
                        var activeKeyboard = keyman.keyboardManager.activeKeyboard;
                        if (activeKeyboard == null || activeKeyboard['KV'] == null) {
                            return false;
                        }
                        layers = activeKeyboard['KV']['KLS'];
                    }
                    else {
                        layers = keyLabels;
                    }
                    var emulationMask = modifierCodes['LCTRL'] | modifierCodes['LALT'];
                    var unshiftedEmulationLayer = layers[Layouts.getLayerId(emulationMask)];
                    var shiftedEmulationLayer = layers[Layouts.getLayerId(modifierCodes['SHIFT'] | emulationMask)];
                    // buildDefaultLayout ensures that these are aliased to the original modifier set being emulated.
                    // As a result, we can directly test for reference equality.
                    if (unshiftedEmulationLayer != null &&
                        unshiftedEmulationLayer != layers[Layouts.getLayerId(modifierCodes['RALT'])]) {
                        return false;
                    }
                    if (shiftedEmulationLayer != null &&
                        shiftedEmulationLayer != layers[Layouts.getLayerId(modifierCodes['RALT'] | modifierCodes['SHIFT'])]) {
                        return false;
                    }
                    // It's technically possible for the OSK to not specify anything while allowing chiral input.  A last-ditch catch:
                    var bitmask = keyman.keyboardManager.getKeyboardModifierBitmask();
                    if ((bitmask & emulationMask) != emulationMask) {
                        // At least one of the emulation modifiers is never used by the keyboard!  We can confirm everything's safe.
                        return true;
                    }
                    if (unshiftedEmulationLayer == null && shiftedEmulationLayer == null) {
                        // We've run out of things to go on; we can't detect if chiral AltGr emulation is intended or not.
                        // TODO:  handle this again!
                        // if(!osk.altGrWarning) {
                        //   console.warn("Could not detect if AltGr emulation is safe, but defaulting to active emulation!")
                        //   // Avoid spamming the console with warnings on every call of the method.
                        //   osk.altGrWarning = true;
                        // }
                        return true;
                    }
                    return true;
                };
                /**
                 * Generates a list of potential layer ids for the specified chirality mode.
                 *
                 * @param   {boolean}   chiral    // Does the keyboard use chiral modifiers or not?
                 */
                Layouts.generateLayerIds = function (chiral) {
                    var layerCnt, offset;
                    if (chiral) {
                        layerCnt = 32;
                        offset = 0x01;
                    }
                    else {
                        layerCnt = 8;
                        offset = 0x10;
                    }
                    var layerIds = [];
                    for (var i = 0; i < layerCnt; i++) {
                        layerIds.push(Layouts.getLayerId(i * offset));
                    }
                    return layerIds;
                };
                /**
                 * Sets a formatting property for the modifier keys when constructing a default layout for a keyboard.
                 *
                 * @param   {Object}    layer   // One layer specification
                 * @param   {boolean}   chiral  // Whether or not the keyboard uses chiral modifier information.
                 * @param   {string}    formFactor  // The form factor of the device the layout is being constructed for.
                 * @param   {boolean}   key102      // Whether or not the extended key 102 should be hidden.
                 */
                Layouts.formatDefaultLayer = function (layer, chiral, formFactor, key102) {
                    var layerId = layer['id'];
                    var buttonClasses = Layouts.buttonClasses;
                    // Correct appearance of state-dependent modifier keys according to group
                    for (var i = 0; i < layer['row'].length; i++) {
                        var row = layer['row'][i];
                        var keys = row['key'];
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            switch (key['id']) {
                                case 'K_SHIFT':
                                case 'K_LSHIFT':
                                case 'K_RSHIFT':
                                    if (layerId.indexOf('shift') != -1) {
                                        key['sp'] = buttonClasses['SHIFT-ON'];
                                    }
                                    if ((formFactor != 'desktop') && (layerId != 'default')) {
                                        key['nextlayer'] = 'default';
                                    }
                                    break;
                                case 'K_LCTRL':
                                case 'K_LCONTROL':
                                    if (chiral) {
                                        if (layerId.indexOf('leftctrl') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_RCTRL':
                                case 'K_RCONTROL':
                                    if (chiral) {
                                        if (layerId.indexOf('rightctrl') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_CONTROL':
                                    if (layerId.indexOf('ctrl') != -1) {
                                        if (!chiral || (layerId.indexOf('leftctrl') != -1 && layerId.indexOf('rightctrl') != -1)) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                    }
                                    break;
                                case 'K_LALT':
                                    if (chiral) {
                                        if (layerId.indexOf('leftalt') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_RALT':
                                    if (chiral) {
                                        if (layerId.indexOf('rightalt') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_ALT':
                                    if (layerId.indexOf('alt') != -1) {
                                        if (!chiral || (layerId.indexOf('leftalt') != -1 && layerId.indexOf('rightalt') != -1)) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                    }
                                    break;
                                case 'K_oE2':
                                    if (typeof key102 == 'undefined' || !key102) {
                                        if (formFactor == 'desktop') {
                                            keys.splice(j--, 1);
                                            keys[0]['width'] = '200';
                                        }
                                        else {
                                            keys[j]['sp'] = buttonClasses['HIDDEN'];
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                };
                /**
                 * Converts the legacy BK property from pre 10.0 into the KLS keyboard layer spec format,
                 * sparsifying it as possible to pre-emptively check invalid layers.
                 *
                 * @param   {Array}   BK      keyboard object (as loaded)
                 * @return  {Object}
                 */
                Layouts.processLegacyDefinitions = function (BK) {
                    //['default','shift','ctrl','shiftctrl','alt','shiftalt','ctrlalt','shiftctrlalt'];
                    var idList = Layouts.generateLayerIds(false); // Non-chiral.
                    var KLS = {};
                    // The old default:  eight auto-managed layers...
                    for (var n = 0; n < idList.length; n++) {
                        var id = idList[n], arr = [], valid = false;
                        // ... with keycode mappings in blocks of 65.
                        for (var k = 0; k < 65; k++) {
                            var index = k + 65 * n;
                            arr.push(BK[index]);
                            // The entry for K_SPACE's keycode tends to hold ' ' instead of '', which causes
                            // the whole layer to be treated as 'valid' if not included in the conditional.
                            if (index < BK.length && BK[index] != '' && k != Layouts.dfltCodes.indexOf('K_SPACE')) {
                                valid = true;
                            }
                        }
                        if (valid) {
                            KLS[id] = arr;
                        }
                    }
                    // There must always be at least a plain 'default' layer.  Array(65).fill('') would be preferable but isn't supported on IE, 
                    // but buildDefaultLayer will set the defaults for these layers if no entry exists for them in the array due to length.
                    if (typeof KLS['default'] == 'undefined' || !KLS['default']) {
                        KLS['default'] = [''];
                    }
                    // There must always be at least a plain 'shift' layer.
                    if (typeof KLS['shift'] == 'undefined' || !KLS['shift']) {
                        KLS['shift'] = [''];
                    }
                    return KLS;
                };
                Layouts.dfltCodes = [
                    "K_BKQUOTE", "K_1", "K_2", "K_3", "K_4", "K_5", "K_6", "K_7", "K_8", "K_9", "K_0",
                    "K_HYPHEN", "K_EQUAL", "K_*", "K_*", "K_*", "K_Q", "K_W", "K_E", "K_R", "K_T",
                    "K_Y", "K_U", "K_I", "K_O", "K_P", "K_LBRKT", "K_RBRKT", "K_BKSLASH", "K_*",
                    "K_*", "K_*", "K_A", "K_S", "K_D", "K_F", "K_G", "K_H", "K_J", "K_K", "K_L",
                    "K_COLON", "K_QUOTE", "K_*", "K_*", "K_*", "K_*", "K_*", "K_oE2",
                    "K_Z", "K_X", "K_C", "K_V", "K_B", "K_N", "K_M", "K_COMMA", "K_PERIOD",
                    "K_SLASH", "K_*", "K_*", "K_*", "K_*", "K_*", "K_SPACE"
                ];
                Layouts.dfltText = '`1234567890-=\xA7~~qwertyuiop[]\\~~~asdfghjkl;\'~~~~~?zxcvbnm,./~~~~~ '
                    + '~!@#$%^&*()_+\xA7~~QWERTYUIOP{}\\~~~ASDFGHJKL:"~~~~~?ZXCVBNM<>?~~~~~ ';
                // Cross-reference with the ids in osk.setButtonClass.
                Layouts.buttonClasses = {
                    'DEFAULT': '0',
                    'SHIFT': '1',
                    'SHIFT-ON': '2',
                    'SPECIAL': '3',
                    'SPECIAL-ON': '4',
                    'DEADKEY': '8',
                    'BLANK': '9',
                    'HIDDEN': '10'
                };
                Layouts.modifierSpecials = {
                    'leftalt': '*LAlt*',
                    'rightalt': '*RAlt*',
                    'alt': '*Alt*',
                    'leftctrl': '*LCtrl*',
                    'rightctrl': '*RCtrl*',
                    'ctrl': '*Ctrl*',
                    'ctrl-alt': '*AltGr*',
                    'leftctrl-leftalt': '*LAltCtrl*',
                    'rightctrl-rightalt': '*RAltCtrl*',
                    'leftctrl-leftalt-shift': '*LAltCtrlShift*',
                    'rightctrl-rightalt-shift': '*RAltCtrlShift*',
                    'shift': '*Shift*',
                    'shift-alt': '*AltShift*',
                    'shift-ctrl': '*CtrlShift*',
                    'shift-ctrl-alt': '*AltCtrlShift*',
                    'leftalt-shift': '*LAltShift*',
                    'rightalt-shift': '*RAltShift*',
                    'leftctrl-shift': '*LCtrlShift*',
                    'rightctrl-shift': '*RCtrlShift*'
                };
                Layouts._BaseLayout = 'us'; // default BaseLayout
                Layouts._BaseLayoutEuro = {
                    'se': '\u00a71234567890+´~~~QWERTYUIOP\u00c5\u00a8\'~~~ASDFGHJKL\u00d6\u00c4~~~~~<ZXCVBNM,.-~~~~~ ',
                    'uk': '`1234567890-=~~~QWERTYUIOP[]#~~~ASDFGHJKL;\'~~~~~\\ZXCVBNM,./~~~~~ ' // UK
                }; // I1299 (not currently exposed, but may need to be e.g. for external users)
                // Defines the default visual layout for a keyboard.
                Layouts.dfltLayout = {
                    "desktop": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_BKQUOTE" },
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "sp": "1", "width": "130" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_TAB", "text": "*Tab*", "sp": "1", "width": "130" },
                                            { "id": "K_Q" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "id": "K_BKSLASH" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_CAPS", "text": "*Caps*", "sp": "1", "width": "165" },
                                            { "id": "K_A" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_ENTER", "text": "*Enter*", "sp": "1", "width": "165" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            { "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "130" },
                                            { "id": "K_oE2" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_RSHIFT", "text": "*Shift*", "sp": "1", "width": "130" }
                                        ]
                                    },
                                    {
                                        "id": "5",
                                        "key": [
                                            { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "170" },
                                            { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "160" },
                                            { "id": "K_SPACE", "text": "", "width": "770" },
                                            { "id": "K_RALT", "text": "*Alt*", "sp": "1", "width": "160" },
                                            { "id": "K_RCONTROL", "text": "*Ctrl*", "sp": "1", "width": "170" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    "tablet": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "0",
                                        "key": [
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_Q", "pad": "25" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_A", "pad": "50" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_BKSLASH", "width": "90" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_oE2", "width": "90" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_BKQUOTE" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            {
                                                "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "200", "sk": [
                                                    { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "50", "nextlayer": "ctrl" },
                                                    { "id": "K_LCONTROL", "text": "*LCtrl*", "sp": "1", "width": "50", "nextlayer": "leftctrl" },
                                                    { "id": "K_RCONTROL", "text": "*RCtrl*", "sp": "1", "width": "50", "nextlayer": "rightctrl" },
                                                    { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "50", "nextlayer": "alt" },
                                                    { "id": "K_LALT", "text": "*LAlt*", "sp": "1", "width": "50", "nextlayer": "leftalt" },
                                                    { "id": "K_RALT", "text": "*RAlt*", "sp": "1", "width": "50", "nextlayer": "rightalt" },
                                                    { "id": "K_ALTGR", "text": "*AltGr*", "sp": "1", "width": "50", "nextlayer": "ctrl-alt" }
                                                ]
                                            },
                                            { "id": "K_LOPT", "text": "*Menu*", "sp": "1", "width": "150" },
                                            { "id": "K_SPACE", "text": "", "width": "570" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "sp": "1", "width": "150" },
                                            { "id": "K_ENTER", "text": "*Enter*", "sp": "1", "width": "200" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    "phone": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "0",
                                        "key": [
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_Q", "pad": "25" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_A", "pad": "50" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_BKSLASH", "width": "90" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_oE2", "width": "90" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_BKQUOTE" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            {
                                                "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "200", "sk": [
                                                    { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "50", "nextlayer": "ctrl" },
                                                    { "id": "K_LCONTROL", "text": "*LCtrl*", "sp": "1", "width": "50", "nextlayer": "leftctrl" },
                                                    { "id": "K_RCONTROL", "text": "*RCtrl*", "sp": "1", "width": "50", "nextlayer": "rightctrl" },
                                                    { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "50", "nextlayer": "alt" },
                                                    { "id": "K_LALT", "text": "*LAlt*", "sp": "1", "width": "50", "nextlayer": "leftalt" },
                                                    { "id": "K_RALT", "text": "*RAlt*", "sp": "1", "width": "50", "nextlayer": "rightalt" },
                                                    { "id": "K_ALTGR", "text": "*AltGr*", "sp": "1", "width": "50", "nextlayer": "ctrl-alt" }
                                                ]
                                            },
                                            { "id": "K_LOPT", "text": "*Menu*", "width": "150", "sp": "1" },
                                            { "id": "K_SPACE", "width": "570", "text": "" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "width": "150", "sp": "1" },
                                            { "id": "K_ENTER", "text": "*Enter*", "width": "200", "sp": "1" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                };
                return Layouts;
            }());
            osk.Layouts = Layouts;
        })(osk = keyman_10.osk || (keyman_10.osk = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman_11) {
        var osk;
        (function (osk_2) {
            // Manages the language selection UI for touch-form factors, which is triggered by an OSK key.
            // Used by 'native'-mode KMW only - the Android and iOS embedding apps implement their own menus.
            var LanguageMenu = /** @class */ (function () {
                function LanguageMenu(keyman) {
                    this.keyman = keyman;
                    this.scrolling = false;
                    this.shim = this.constructShim();
                }
                LanguageMenu.prototype.constructShim = function () {
                    var languageMenu = this;
                    var shim = this.keyman.util._CreateElement('div');
                    var osk = this.keyman.osk;
                    shim.id = 'kmw-language-menu-background';
                    shim.addEventListener('touchstart', function (e) {
                        e.preventDefault();
                        languageMenu.hide();
                        // Display build only if touching menu, space *and* one other point on screen (build 369)
                        if (e.touches.length > 2) {
                            var sX = e.touches[1].pageX, sY = e.touches[1].pageY;
                            var spaceBar = osk.vkbd.spaceBar;
                            if (sX > spaceBar.offsetLeft && sX < spaceBar.offsetLeft + spaceBar.offsetWidth &&
                                sY > spaceBar.offsetTop && sY < spaceBar.offsetTop + spaceBar.offsetHeight) {
                                osk.showBuild();
                            }
                        }
                    }, false);
                    return shim;
                };
                /**
                 * Display list of installed keyboards in pop-up menu
                 **/
                LanguageMenu.prototype.show = function () {
                    var n = 0, kbdList = this.keyman.keyboardManager.keyboardStubs, nKbds = kbdList.length;
                    var util = this.keyman.util;
                    if (nKbds < 1) {
                        return;
                    }
                    // Create the menu list container element
                    var menu = this.lgList = util._CreateElement('div'), ss;
                    this.lgList.id = 'kmw-language-menu';
                    // Insert a transparent overlay to prevent anything else happening during keyboard selection,
                    // but allow the menu to be closed if anywhere else on screen is touched
                    var osk = this.keyman.osk;
                    var languageMenu = this;
                    document.body.appendChild(this.shim);
                    // Add two nested DIVs to properly support iOS scrolling with momentum
                    //  c.f. https://github.com/joelambert/ScrollFix/issues/2
                    var m2 = util._CreateElement('div'), s2 = m2.style, m3 = util._CreateElement('div'), s3 = m3.style;
                    m2.id = 'kmw-menu-scroll-container';
                    m3.id = 'kmw-menu-scroller';
                    // Support momentum scrolling on iOS
                    if ('WebkitOverflowScrolling' in s2) {
                        s2.WebkitOverflowScrolling = 'touch';
                    }
                    m2.appendChild(m3);
                    menu.appendChild(m2);
                    // Add menu index strip
                    var i, x, mx = util._CreateElement('div');
                    mx.id = 'kmw-menu-index';
                    for (i = 1; i <= 26; i++) {
                        x = util._CreateElement('p');
                        x.innerHTML = String.fromCharCode(i + 64);
                        mx.appendChild(x);
                    }
                    // Add index selection (for a large menu)
                    mx.addEventListener('touchstart', function (e) {
                        languageMenu.scrollToLanguage(e, m2, m3);
                    }, false);
                    mx.addEventListener('touchend', function (e) {
                        e.stopPropagation();
                        e.preventDefault();
                    }, false);
                    menu.appendChild(mx);
                    //TODO: not sure if either of these two handlers ar actually needed.  touchmove handler may be doing all that is necessary.
                    // Add scroll end event handling to override body scroll
                    menu.addEventListener('scroll', function (e) {
                        languageMenu.scrolling = true;
                    }, false);
                    m2.addEventListener('scroll', function (e) {
                        //this.lgList.scrolling=true;
                        if (m2.scrollTop < 1) {
                            m2.scrollTop = 1;
                        }
                        if (m2.scrollTop > m2.scrollHeight - m2.offsetHeight - 1) {
                            m2.scrollTop = m2.scrollHeight - m2.offsetHeight - 1;
                        }
                    }, false);
                    // Add a list of keyboards to the innermost DIV
                    this.activeLgNo = this.addLanguages(m3, kbdList);
                    // Get number of visible (language) selectors
                    var nLgs = m3.childNodes.length - 1;
                    // Do not display until sizes have been calculated
                    this.lgList.style.visibility = 'hidden';
                    // Append menu to document body, not to OSK
                    document.body.appendChild(this.lgList);
                    // Adjust size for viewport scaling (probably not needed for iOS, but check!)
                    if (util.device.OS == 'Android' && 'devicePixelRatio' in window) {
                        this.lgList.style.fontSize = (2 / window.devicePixelRatio) + 'em';
                    }
                    // Adjust width for pixel scaling on Android tablets
                    if (util.device.OS == 'Android' && util.device.formFactor == 'tablet' && 'devicePixelRatio' in window) {
                        var w = parseInt(util.getStyleValue(menu, 'width'), 10), ms = menu.style;
                        if (!isNaN(w)) {
                            ms.width = ms.maxWidth = (2 * w / window.devicePixelRatio) + 'px';
                        }
                        w = parseInt(util.getStyleValue(m2, 'width'), 10);
                        ms = m2.style;
                        if (!isNaN(w)) {
                            ms.width = ms.maxWidth = (2 * w / window.devicePixelRatio) + 'px';
                        }
                        w = parseInt(util.getStyleValue(m3, 'width'), 10);
                        ms = m3.style;
                        if (!isNaN(w)) {
                            ms.width = ms.maxWidth = (2 * w / window.devicePixelRatio) + 'px';
                        }
                    }
                    // Adjust initial top and height of menu
                    this.adjust(0);
                    // Adjust the index font size and line height
                    var dy = mx.childNodes[1].offsetTop - mx.childNodes[0].offsetTop, lineHeight = Math.floor(menu.offsetHeight / 26.0), scale = Math.round(100.0 * lineHeight / dy) / 100.0, factor = (scale > 0.6 ? 1 : 2);
                    if (scale > 1.25) {
                        scale = 1.25;
                    }
                    for (i = 0; i < 26; i++) {
                        var qs = mx.childNodes[i].style;
                        if (factor == 2 && (i % 2) == 1) {
                            qs.display = 'none';
                        }
                        else {
                            qs.fontSize = (scale * factor) + 'em';
                            qs.lineHeight = (lineHeight * factor) + 'px';
                        }
                    }
                    // Increase width of outer menu DIV by index, else hide index
                    var menuWidth = m2.offsetWidth;
                    if (m2.scrollHeight > m2.offsetHeight + 3) {
                        menuWidth = menuWidth + mx.offsetWidth;
                    }
                    else {
                        mx.style.display = 'none';
                    }
                    menu.style.width = menuWidth + 'px';
                    // Now display the menu
                    this.lgList.style.visibility = '';
                    // Set initial scroll to show current language (but never less than 1, to avoid dragging body)
                    var top = m3.firstChild.offsetHeight * this.activeLgNo + 1;
                    m2.scrollTop = top;
                    // The scrollTop value is limited by the device, and must be limited to avoid dragging the document body
                    if (m2.scrollTop < top) {
                        m2.scrollTop = m2.scrollHeight - m2.offsetHeight;
                    }
                    if (m2.scrollTop > m2.scrollHeight - m2.offsetHeight - 1) {
                        m2.scrollTop = m2.scrollHeight - m2.offsetHeight - 1;
                    }
                };
                /**
                 * Adjust top and height of language menu
                 *
                 * @param   {number}  nKbds number of displayed keyboards to add to number of languages
                 **/
                LanguageMenu.prototype.adjust = function (nKbds) {
                    var osk = this.keyman.osk;
                    var util = this.keyman.util;
                    var device = util.device;
                    var menu = this.lgList, m2 = menu.firstChild, m3 = m2.firstChild, barWidth = 0, s = menu.style, mx = menu.childNodes[1], maxHeight = window.innerHeight - osk.vkbd.lgKey.offsetHeight - 16, nItems = m3.childNodes.length + nKbds - 1, // Number of (visible) keyboard selectors
                    itemHeight = m3.firstChild.firstChild.offsetHeight, menuHeight = nItems * itemHeight;
                    // Correct maxheight for viewport scaling (iPhone/iPod only) and internal position corrections
                    if (device.OS == 'iOS') {
                        if (device.formFactor == 'phone') {
                            barWidth = (util.landscapeView() ? 36 : 0);
                            maxHeight = (window.innerHeight - barWidth - 16) * util.getViewportScale();
                        }
                        else if (device.formFactor == 'tablet') {
                            barWidth = (util.landscapeView() ? 16 : 0);
                            maxHeight = (maxHeight - barWidth);
                        }
                    }
                    // Explicitly set position and height
                    s.left = keyman_11.dom.Utils.getAbsoluteX(osk.vkbd.lgKey) + 'px';
                    if (menuHeight > maxHeight) {
                        menuHeight = maxHeight;
                    }
                    s.height = menuHeight + 'px';
                    // Position menu at bottom of screen using the same positioning model as the OSK.
                    s.bottom = '0px';
                    // Explicitly set the scroller and index heights to the container height
                    mx.style.height = m2.style.height = s.height;
                };
                /**
                 * Add an index to the language menu
                 *
                 *  @param  {Object}  e         touch start event from index
                 *  @param  {Object}  m2        menu scroller DIV
                 *  @param  {Object}  menu      DIV with list of languages
                 */
                LanguageMenu.prototype.scrollToLanguage = function (e, m2, menu) {
                    e.stopImmediatePropagation();
                    e.stopPropagation();
                    e.preventDefault();
                    var target = e.touches[0].target;
                    // Will return 'P', not 'p'.
                    if (target.nodeName != 'P') {
                        return;
                    }
                    var i, t, top = 0, initial = target.innerHTML.charCodeAt(0), nn = menu.childNodes;
                    try {
                        for (i = 0; i < nn.length - 1; i++) {
                            t = nn[i].firstChild.innerHTML.toUpperCase().charCodeAt(0);
                            if (t >= initial) {
                                break;
                            }
                        }
                    }
                    catch (ex) { }
                    try {
                        top = menu.firstChild.offsetHeight * i + 1;
                        m2.scrollTop = top;
                    }
                    catch (ex) {
                        top = 0;
                    }
                    try {
                        if (m2.scrollTop < top) {
                            m2.scrollTop = m2.scrollHeight - m2.offsetHeight;
                        }
                        if (m2.scrollTop > m2.scrollHeight - m2.offsetHeight - 1) {
                            m2.scrollTop = m2.scrollHeight - m2.offsetHeight - 1;
                        }
                    }
                    catch (ex) { }
                };
                /**
                 * Display all languages for installed keyboards in scrollable list
                 *
                 *    @param    {Object}    menu      DIV to which language selectors will be added
                 *    @param    {Object}    kbdList   array of keyboard stub objects
                 *    @return   {number}              index of currently active language
                 **/
                LanguageMenu.prototype.addLanguages = function (menu, kbdList) {
                    var nStubs = kbdList.length;
                    var util = this.keyman.util;
                    var device = util.device;
                    // Create and sort a list of languages
                    var k, n, lg, langs = [];
                    for (n = 0; n < nStubs; n++) {
                        lg = kbdList[n]['KL'];
                        if (langs.indexOf(lg) == -1) {
                            langs.push(lg);
                        }
                    }
                    langs.sort();
                    // Get current scale factor (reciprocal of viewport scale)
                    var scale = Math.round(100 / util.getViewportScale()) / 100;
                    var dx, lgBar, i, kb, activeLanguageIndex = -1;
                    var _loop_1 = function () {
                        dx = util._CreateElement('div');
                        dx.className = 'kbd-list-closed';
                        lgBar = util._CreateElement('p');
                        lgBar.kList = [];
                        for (n = 0; n < nStubs; n++) {
                            if (kbdList[n]['KL'] == langs[k]) {
                                lgBar.kList.push(kbdList[n]);
                            }
                        }
                        // Adjust bar size for current viewport scaling (iOS only!)
                        if (device.OS == 'iOS') {
                            lgBar.style.fontSize = scale + 'em';
                        }
                        // Add to menu
                        dx.appendChild(lgBar);
                        menu.appendChild(dx);
                        if (langs[k] == this_1.keyman.keyboardManager.activeStub['KL']) {
                            activeLanguageIndex = k;
                        }
                        var languageMenu = this_1;
                        // Several keyboards for this language
                        if (lgBar.kList.length > 1) {
                            lgBar.className = 'kbd-list';
                            lgBar.innerHTML = langs[k] + '...';
                            lgBar.scrolled = false;
                            lgBar.ontouchend = function (e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (e.target.scrolled)
                                    e.target.scrolled = false;
                                else
                                    this.parentNode.className = (this.parentNode.className == 'kbd-list-closed' ? 'kbd-list-open' : 'kbd-list-closed');
                                // Adjust top of menu to allow for expanded list
                                languageMenu.adjust(this.parentNode.className == 'kbd-list-closed' ? 0 : this.kList.length);
                            };
                            lgBar.addEventListener('touchstart', function (e) { e.stopPropagation(); }, false);
                            lgBar.addEventListener('touchmove', function (e) { e.target.scrolled = true; e.stopPropagation(); }, false);
                            for (i = 0; i < lgBar.kList.length; i++) {
                                kb = util._CreateElement('p');
                                kb.className = 'kbd-list-entry';
                                if (device.OS == 'iOS') {
                                    kb.style.fontSize = scale + 'em';
                                }
                                this_1.addKeyboard(lgBar.kList[i], kb, false);
                                dx.appendChild(kb);
                            }
                            // Only one keyboard for this language
                        }
                        else {
                            lgBar.innerHTML = langs[k];
                            lgBar.className = 'kbd-single-entry';
                            this_1.addKeyboard(lgBar.kList[0], lgBar, true);
                        }
                        if (k == activeLanguageIndex) {
                            lgBar.className = lgBar.className + ' current';
                        }
                    };
                    var this_1 = this;
                    for (k = 0; k < langs.length; k++) {
                        _loop_1();
                    }
                    // Add a non-selectable bottom bar so to allow scrolling to the last language
                    var padLast = util._CreateElement('div');
                    padLast.id = 'kmw-menu-footer';
                    var cancelTouch = function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    };
                    padLast.addEventListener('touchstart', cancelTouch, false);
                    padLast.addEventListener('touchmove', cancelTouch, false);
                    padLast.addEventListener('touchend', cancelTouch, false);
                    menu.appendChild(padLast);
                    return activeLanguageIndex;
                };
                /**
                 * Add a keyboard entry to the language menu *
                 *
                 * @param   {Object}    kbd     keyboard object
                 * @param   {Object}    kb      element being added and styled
                 * @param   {boolean}   unique  is this the only keyboard for the language?
                 */
                LanguageMenu.prototype.addKeyboard = function (kbd, kb, unique) {
                    kb.kn = kbd['KI']; // InternalName;
                    kb.kc = kbd['KLC']; // LanguageCode;
                    kb.innerHTML = unique ? kbd['KL'] : kbd['KN'].replace(' Keyboard', ''); // Name
                    // We're setting up a few events - this alias helps avoid scoping issues.
                    var languageMenu = this;
                    // Touchstart (or mspointerdown) event highlights the touched list item
                    var touchStart = function (e) {
                        e.stopPropagation();
                        if (this.className.indexOf('selected') <= 0) {
                            this.className = this.className + ' selected';
                        }
                        languageMenu.scrolling = false;
                        languageMenu.y0 = e.touches[0].pageY; //osk.lgList.childNodes[0].scrollTop;
                        return true;
                    };
                    //TODO: Still drags Android background sometimes (not consistently)
                    // Touchmove drags the list and prevents release from selecting the language
                    var touchMove = function (e) {
                        e.stopImmediatePropagation();
                        var scroller = languageMenu.lgList.childNodes[0], yMax = scroller.scrollHeight - scroller.offsetHeight, y, dy;
                        if ("undefined" != typeof e.pageY) {
                            y = e.pageY;
                        }
                        else if ("undefined" != typeof e.touches) {
                            y = e.touches[0].pageY;
                        }
                        else {
                            return;
                        }
                        dy = y - languageMenu.y0;
                        // Scroll up (show later listed languages)
                        if (dy < 0) {
                            if (scroller.scrollTop >= yMax - 1) {
                                e.preventDefault();
                                languageMenu.y0 = y;
                            }
                            // Scroll down (show earlier listed languages)
                        }
                        else if (dy > 0) {
                            if (scroller.scrollTop < 2) {
                                e.preventDefault();
                                languageMenu.y0 = y;
                            }
                            // Dont' scroll - can happen if changing scroll direction
                        }
                        else {
                            return;
                        }
                        // Disable selected language if drag more than 5px
                        if (dy < -5 || dy > 5) {
                            languageMenu.scrolling = true;
                            this.className = this.className.replace(/\s*selected/, '');
                            languageMenu.y0 = y;
                        }
                        return true;
                    };
                    // Touch release (click) event selects touched list item
                    var touchEnd = function (e) {
                        e.preventDefault();
                        if (typeof (e.stopImmediatePropagation) != 'undefined') {
                            e.stopImmediatePropagation();
                        }
                        else {
                            e.stopPropagation();
                        }
                        if (languageMenu.scrolling) {
                            this.className = this.className.replace(/\s*selected/, '');
                        }
                        else {
                            com.keyman.DOMEventHandlers.states.setFocusTimer();
                            languageMenu.lgList.style.display = 'none'; //still allows blank menu momentarily on selection
                            languageMenu.keyman.keyboardManager._SetActiveKeyboard(this.kn, this.kc, true);
                            languageMenu.keyman.keyboardManager.doKeyboardChange(this.kn, this.kc);
                            languageMenu.keyman.domManager.focusLastActiveElement();
                            languageMenu.hide();
                            // Update the OSK with the new keyboard
                            languageMenu.keyman.osk._Show();
                        }
                        return true;
                    };
                    kb.onmspointerdown = touchStart;
                    kb.addEventListener('touchstart', touchStart, false);
                    kb.onmspointermove = touchMove;
                    kb.addEventListener('touchmove', touchMove, false);
                    kb.onmspointerout = touchEnd;
                    kb.addEventListener('touchend', touchEnd, false);
                };
                /**
                 * Remove the language menu again
                 **/
                LanguageMenu.prototype.hide = function () {
                    var osk = this.keyman.osk;
                    var languageMenu = this;
                    if (this.lgList) {
                        osk.vkbd.highlightKey(osk.vkbd.lgKey, false);
                        this.lgList.style.visibility = 'hidden';
                        window.setTimeout(function () {
                            // In case of extremely rapid keyboard swaps, this event may trigger more than once - 
                            // the shim's on-touch event can trigger after a keyboard has been selected!
                            if (languageMenu.shim.parentElement) {
                                document.body.removeChild(languageMenu.shim);
                                document.body.removeChild(languageMenu.lgList);
                            }
                        }, 500);
                    }
                };
                return LanguageMenu;
            }());
            osk_2.LanguageMenu = LanguageMenu;
        })(osk = keyman_11.osk || (keyman_11.osk = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var osk;
        (function (osk) {
            var ActiveKey = /** @class */ (function () {
                function ActiveKey() {
                }
                ActiveKey.polyfill = function (key, displayLayer) {
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveKey();
                    for (var prop in dummy) {
                        if (!key.hasOwnProperty(prop)) {
                            key[prop] = dummy[prop];
                        }
                    }
                    var aKey = key;
                    aKey.displayLayer = displayLayer;
                    aKey.layer = aKey.layer || displayLayer;
                };
                ActiveKey.DEFAULT_PAD = 15; // Padding to left of key, in virtual units
                ActiveKey.DEFAULT_RIGHT_MARGIN = 15; // Padding to right of right-most key, in virtual units
                ActiveKey.DEFAULT_KEY_WIDTH = 100; // Width of a key, if not specified, in virtual units
                // Defines key defaults
                ActiveKey.DEFAULT_KEY = {
                    text: '',
                    width: ActiveKey.DEFAULT_KEY_WIDTH.toString(),
                    sp: '0',
                    pad: ActiveKey.DEFAULT_PAD.toString()
                };
                return ActiveKey;
            }());
            osk.ActiveKey = ActiveKey;
            var ActiveRow = /** @class */ (function () {
                function ActiveRow() {
                }
                ActiveRow.polyfill = function (row, displayLayer, totalWidth, proportionalY) {
                    // Apply defaults, setting the width and other undefined properties for each key
                    var keys = row['key'];
                    for (var j = 0; j < keys.length; j++) {
                        var key = keys[j];
                        for (var tp in ActiveKey.DEFAULT_KEY) {
                            if (typeof key[tp] != 'string') {
                                key[tp] = ActiveKey.DEFAULT_KEY[tp];
                            }
                        }
                        // Modify the key type for special keys with non-standard labels
                        // to allow the keyboard font to ovveride the SpecialOSK font.
                        // Blank keys are no longer reclassed - can use before/after CSS to add text
                        switch (key['sp']) {
                            case '1':
                                if (!ActiveRow.SPECIAL_LABEL.test(key['text']) && key['text'] != '') {
                                    key['sp'] = '3';
                                }
                                break;
                            case '2':
                                if (!ActiveRow.SPECIAL_LABEL.test(key['text']) && key['text'] != '') {
                                    key['sp'] = '4';
                                }
                                break;
                        }
                        ActiveKey.polyfill(key, displayLayer);
                    }
                    /* The calculations here are effectively 'virtualized'.  When used with the OSK, the VisualKeyboard
                     * will overwrite these values with their true runtime geometry.
                     *
                     * These calculations approximate those of the actual OSK (without fitting to a specific resolution)
                     * and are intended for use with layout testing (while headless) in the future.
                     */
                    // Calculate percentage-based scalings by summing defined widths and scaling each key to %.
                    // Save each percentage key width as a separate member (do *not* overwrite layout specified width!)
                    var keyPercent, padPercent, totalPercent = 0;
                    for (var j = 0; j < keys.length - 1; j++) {
                        keyPercent = parseInt(keys[j]['width'], 10) / totalWidth;
                        keys[j]['widthpc'] = keyPercent;
                        padPercent = parseInt(keys[j]['pad'], 10) / totalWidth;
                        keys[j]['padpc'] = padPercent;
                        // compute center's default x-coord (used in headless modes)
                        keys[j].proportionalX = (totalPercent + padPercent + (keyPercent / 2));
                        keys[j].proportionalWidth = keyPercent;
                        totalPercent += padPercent + keyPercent;
                    }
                    // Allow for right OSK margin (15 layout units)
                    var rightMargin = ActiveKey.DEFAULT_RIGHT_MARGIN / totalWidth;
                    totalPercent += rightMargin;
                    // If a single key, and padding is negative, add padding to right align the key
                    if (keys.length == 1 && parseInt(keys[0]['pad'], 10) < 0) {
                        keyPercent = parseInt(keys[0]['width'], 10) / totalWidth;
                        keys[0]['widthpc'] = keyPercent;
                        totalPercent += keyPercent;
                        keys[0]['padpc'] = 1 - totalPercent;
                        // compute center's default x-coord (used in headless modes)
                        keys[0].proportionalX = ((totalPercent - rightMargin) - keyPercent / 2);
                        keys[0].proportionalWidth = keyPercent;
                    }
                    else if (keys.length > 0) {
                        var j = keys.length - 1;
                        padPercent = parseInt(keys[j]['pad'], 10) / totalWidth;
                        keys[j]['padpc'] = padPercent;
                        totalPercent += padPercent;
                        keys[j]['widthpc'] = keyPercent = 1 - totalPercent;
                        // compute center's default x-coord (used in headless modes)
                        keys[j].proportionalX = (1 - rightMargin) - keyPercent / 2;
                        keys[j].proportionalWidth = keyPercent;
                    }
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveRow();
                    for (var key in dummy) {
                        if (!row.hasOwnProperty(key)) {
                            row[key] = dummy[key];
                        }
                    }
                    var aRow = row;
                    aRow.proportionalY = proportionalY;
                };
                ActiveRow.prototype.populateKeyMap = function (map) {
                    this.key.forEach(function (key) {
                        if (key.id) {
                            map[key.id] = key;
                        }
                    });
                };
                // Identify key labels (e.g. *Shift*) that require the special OSK font
                ActiveRow.SPECIAL_LABEL = /\*\w+\*/;
                return ActiveRow;
            }());
            var ActiveLayer = /** @class */ (function () {
                function ActiveLayer() {
                }
                ActiveLayer.polyfill = function (layer, formFactor) {
                    layer.aligned = false;
                    // Create a DIV for each row of the group
                    var rows = layer['row'];
                    // Calculate the maximum row width (in layout units)
                    var totalWidth = 0;
                    for (var i = 0; i < layer['row'].length; i++) {
                        var width = 0;
                        var row = rows[i];
                        var keys = row['key'];
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            // Test for a trailing comma included in spec, added as null object by IE
                            if (key == null) {
                                keys.length = keys.length - 1;
                            }
                            else {
                                var kw, kp;
                                kw = (typeof key['width'] == 'string' && key['width'] != '') ? parseInt(key['width'], 10) : ActiveKey.DEFAULT_KEY_WIDTH;
                                if (isNaN(kw) || kw == 0)
                                    kw = ActiveKey.DEFAULT_KEY_WIDTH;
                                key['width'] = kw.toString();
                                kp = (typeof key['pad'] == 'string' && key['pad'] != '') ? parseInt(key['pad'], 10) : ActiveKey.DEFAULT_PAD;
                                if (isNaN(kp) || kp == 0)
                                    kp = ActiveKey.DEFAULT_PAD; // KMEW-119
                                key['pad'] = kp.toString();
                                width += kw + kp;
                                //if(typeof key['width'] == 'string' && key['width'] != '') width += parseInt(key['width'],10); else width += DEFAULT_KEY_WIDTH;
                                //if(typeof key['pad'] == 'string' && key['pad'] != '') width += parseInt(key['pad'],10); else width += 5;
                            }
                        }
                        if (width > totalWidth) {
                            totalWidth = width;
                        }
                    }
                    // Add default right margin
                    if (formFactor == 'desktop') {
                        totalWidth += 5; // TODO: resolve difference between touch and desktop; why don't we use ActiveKey.DEFAULT_RIGHT_MARGIN?
                    }
                    else {
                        totalWidth += ActiveKey.DEFAULT_RIGHT_MARGIN;
                    }
                    var rowCount = layer.row.length;
                    for (var i = 0; i < rowCount; i++) {
                        // Calculate proportional y-coord of row.  0 is at top with highest y-coord.
                        var rowProportionalY = (i + 0.5) / rowCount;
                        ActiveRow.polyfill(layer.row[i], layer.id, totalWidth, rowProportionalY);
                    }
                    // Add class functions and properties to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveLayer();
                    for (var key in dummy) {
                        if (!layer.hasOwnProperty(key)) {
                            layer[key] = dummy[key];
                        }
                    }
                    var aLayer = layer;
                    aLayer.totalWidth = totalWidth;
                    aLayer.defaultKeyProportionalWidth = parseInt(ActiveKey.DEFAULT_KEY.width, 10) / totalWidth;
                    aLayer.rowProportionalHeight = 1.0 / rowCount;
                    aLayer.keyMap = aLayer.constructKeyMap();
                };
                ActiveLayer.prototype.constructKeyMap = function () {
                    var map = {};
                    this.row.forEach(function (row) {
                        row.populateKeyMap(map);
                    });
                    return map;
                };
                /**
                 * Builds a sorted-order array of most likely keys to be intended for a given touch.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.getTouchProbabilities = function (touchCoords, kbdScaleRatio) {
                    var distribution = this.simpleTouchDistribution(touchCoords, kbdScaleRatio);
                    var list = [];
                    for (var key in distribution) {
                        list.push({ keyId: key, p: distribution[key] });
                    }
                    return list.sort(function (a, b) {
                        return b.p - a.p; // Largest probability keys should be listed first.
                    });
                };
                /**
                 * Computes a probability distribution regarding the likelihood of a touch command being intended
                 * for each of the layout's keys.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.simpleTouchDistribution = function (touchCoords, kbdScaleRatio) {
                    var keyDists = this.keyTouchDistances(touchCoords, kbdScaleRatio);
                    var keyProbs = {};
                    var totalMass = 0;
                    // Should we wish to allow multiple different transforms for distance -> probability, use a function parameter in place
                    // of the formula in the loop below.
                    for (var key in keyDists) {
                        totalMass += keyProbs[key] = 1 / (keyDists[key] + 1e-6); // Prevent div-by-0 errors.
                    }
                    for (var key in keyProbs) {
                        keyProbs[key] /= totalMass;
                    }
                    return keyProbs;
                };
                /**
                 * Computes a squared 'pseudo-distance' for the touch from each key.  (Not a proper metric.)
                 * Intended for use in generating a probability distribution over the keys based on the touch input.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.keyTouchDistances = function (touchCoords, kbdScaleRatio) {
                    var layer = this;
                    var keyDists = {};
                    // This double-nested loop computes a pseudo-distance for the touch from each key.  Quite useful for
                    // generating a probability distribution.
                    this.row.forEach(function (row) {
                        row.key.forEach(function (key) {
                            // If the key lacks an ID, just skip it.  Sometimes used for padding.
                            if (!key.id) {
                                return;
                            }
                            // These represent the within-key distance of the touch from the key's center.
                            // Both should be on the interval [0, 0.5].
                            var dx = Math.abs(touchCoords.x - key.proportionalX);
                            var dy = Math.abs(touchCoords.y - row.proportionalY);
                            // If the touch isn't within the key, these store the out-of-key distance
                            // from the closest point on the key being checked.
                            var distX, distY;
                            if (dx > 0.5 * key.proportionalWidth) {
                                distX = (dx - 0.5 * key.proportionalWidth);
                                dx = 0.5;
                            }
                            else {
                                distX = 0;
                                dx /= key.proportionalWidth;
                            }
                            if (dy > 0.5 * layer.rowProportionalHeight) {
                                distY = (dy - 0.5 * layer.rowProportionalHeight);
                                dy = 0.5;
                            }
                            else {
                                distY = 0;
                                dy /= layer.rowProportionalHeight;
                            }
                            // Now that the differentials are computed, it's time to do distance scaling.
                            //
                            // For out-of-key distance, we scale the X component by the keyboard's aspect ratio
                            // to get the actual out-of-key distance rather than proportional.
                            distX *= kbdScaleRatio;
                            // While the keys are rarely perfect squares, we map all within-key distance
                            // to a square shape.  (ALT/CMD should seem as close to SPACE as a 'B'.)
                            //
                            // For that square, we take the rowHeight as its edge lengths.
                            distX += dx * layer.rowProportionalHeight;
                            distY += dy * layer.rowProportionalHeight;
                            var distance = distX * distX + distY * distY;
                            keyDists[key.id] = distance;
                        });
                    });
                    return keyDists;
                };
                ActiveLayer.prototype.getKey = function (keyId) {
                    // Keys usually are specified in a "long form" prefixed with their layer's ID.
                    if (keyId.indexOf(this.id + '-') == 0) {
                        keyId = keyId.replace(this.id + '-', '');
                    }
                    return this.keyMap[keyId];
                };
                return ActiveLayer;
            }());
            osk.ActiveLayer = ActiveLayer;
            var ActiveLayout = /** @class */ (function () {
                function ActiveLayout() {
                }
                ActiveLayout.prototype.getLayer = function (layerId) {
                    return this.layerMap[layerId];
                };
                /**
                 *
                 * @param layout
                 * @param formFactor
                 */
                ActiveLayout.polyfill = function (layout, formFactor) {
                    if (layout == null) {
                        throw new Error("Cannot build an ActiveLayout for a null specification.");
                    }
                    // Create a separate OSK div for each OSK layer, only one of which will ever be visible
                    var n, i;
                    var layers, layer;
                    var layerMap = {};
                    var rows;
                    layers = layout['layer'];
                    // ***Delete any empty rows at the end added by compiler bug...
                    for (n = 0; n < layers.length; n++) {
                        layer = layers[n];
                        rows = layer['row'];
                        for (i = rows.length; i > 0; i--) {
                            if (rows[i - 1]['key'].length > 0) {
                                break;
                            }
                        }
                        if (i < rows.length) {
                            rows.splice(i - rows.length, rows.length - i);
                        }
                    }
                    // ...remove to here when compiler bug fixed ***
                    for (n = 0; n < layers.length; n++) {
                        ActiveLayer.polyfill(layers[n], formFactor);
                        layerMap[layers[n].id] = layers[n];
                    }
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveLayout();
                    for (var key in dummy) {
                        if (!layout.hasOwnProperty(key)) {
                            layout[key] = dummy[key];
                        }
                    }
                    var aLayout = layout;
                    aLayout.layerMap = layerMap;
                    return aLayout;
                };
                return ActiveLayout;
            }());
            osk.ActiveLayout = ActiveLayout;
        })(osk = keyman.osk || (keyman.osk = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="activeLayout.ts" />
/// <reference path="../utils/version.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_12) {
        var osk;
        (function (osk_3) {
            var Codes = com.keyman.text.Codes;
            //#region Definition of the KeyElement merger type
            var KeyData = /** @class */ (function () {
                function KeyData(keyData, keyId) {
                    this['key'] = keyData;
                    this['keyId'] = keyId;
                }
                return KeyData;
            }());
            // Many thanks to https://www.typescriptlang.org/docs/handbook/advanced-types.html for this.
            function link(elem, data) {
                var e = elem;
                // Merges all properties and methods of KeyData onto the underlying HTMLDivElement, creating a merged class.
                for (var id in data) {
                    if (!e.hasOwnProperty(id)) {
                        e[id] = data[id];
                    }
                }
                return e;
            }
            function isKey(elem) {
                return elem && ('key' in elem) && (elem['key'] instanceof OSKKey);
            }
            osk_3.isKey = isKey;
            function getKeyFrom(elem) {
                if (isKey(elem)) {
                    return elem;
                }
                else {
                    return null;
                }
            }
            osk_3.getKeyFrom = getKeyFrom;
            //#endregion
            //#region OSK key objects and construction
            var OSKKeySpec = /** @class */ (function () {
                function OSKKeySpec(id, text, width, sp, nextlayer, pad) {
                    this.id = id;
                    this.text = text;
                    this.width = width ? width : "50";
                    this.sp = sp;
                    this.nextlayer = nextlayer;
                    this.pad = pad;
                }
                return OSKKeySpec;
            }());
            osk_3.OSKKeySpec = OSKKeySpec;
            var OSKKey = /** @class */ (function () {
                function OSKKey(spec, layer, formFactor) {
                    this.spec = spec;
                    this.layer = layer;
                    this.formFactor = formFactor;
                }
                /**
                 * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
                 *
                 * @param {String} text The text to be rendered.
                 * @param {String} style The CSSStyleDeclaration for an element to measure against, without modification.
                 *
                 * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
                 * This version has been substantially modified to work for this particular application.
                 */
                OSKKey.getTextWidth = function (osk, text, style) {
                    // A final fallback - having the right font selected makes a world of difference.
                    if (!style.fontFamily) {
                        style.fontFamily = getComputedStyle(document.body).fontFamily;
                    }
                    if (!style.fontSize || style.fontSize == "") {
                        style.fontSize = '1em';
                    }
                    var fontFamily = style.fontFamily;
                    // Use of `getComputedStyle` is ideal, but in many of our use cases its preconditions are not met.
                    // The following allows us to calculate the font size in those situations.
                    var emScale = osk.getKeyEmFontSize();
                    var fontSpec = window['keyman'].util.getFontSizeStyle(style.fontSize);
                    var fontSize;
                    if (fontSpec.absolute) {
                        // We've already got an exact size - use it!
                        fontSize = fontSpec.val + 'px';
                    }
                    else {
                        fontSize = fontSpec.val * emScale + 'px';
                    }
                    // re-use canvas object for better performance
                    var canvas = OSKKey.getTextWidth['canvas'] || (OSKKey.getTextWidth['canvas'] = document.createElement("canvas"));
                    var context = canvas.getContext("2d");
                    context.font = fontSize + " " + fontFamily;
                    var metrics = context.measureText(text);
                    return metrics.width;
                };
                OSKKey.prototype.getKeyWidth = function (osk) {
                    var units = this.objectUnits(osk.isStatic);
                    if (units == 'px') {
                        // For mobile devices, we presently specify width directly in pixels.  Just use that!
                        return this.spec['widthpc'];
                    }
                    else if (units == '%') {
                        // For desktop devices, each key is given a %age of the total OSK width.  We'll need to compute an
                        // approximation for that.  `this.kbdDiv` is the element controlling the OSK's width, set in px.
                        // ... and since it's null whenever this method would be called during key construction, we simply
                        // grab it from the cookie (or its default values) instead.
                        var oskWidth = com.keyman.singleton.osk.getWidthFromCookie();
                        // This is an approximation that tends to be a bit too large, but it's close enough to be useful.
                        return Math.floor(oskWidth * this.spec['widthpc'] / 100);
                    }
                };
                OSKKey.prototype.objectUnits = function (isStatic) {
                    // Returns a unit string corresponding to how the width for each key is specified.
                    if (this.formFactor == 'desktop' || isStatic) {
                        return '%';
                    }
                    else {
                        return 'px';
                    }
                };
                /**
                 * Replace default key names by special font codes for modifier keys
                 *
                 *  @param  {string}  oldText
                 *  @return {string}
                 **/
                OSKKey.prototype.renameSpecialKey = function (oldText) {
                    var keyman = window['keyman'];
                    // If a 'special key' mapping exists for the text, replace it with its corresponding special OSK character.
                    return VisualKeyboard.specialCharacters[oldText] ?
                        String.fromCharCode(0XE000 + VisualKeyboard.specialCharacters[oldText]) :
                        oldText;
                };
                // Produces a HTMLSpanElement with the key's actual text.
                OSKKey.prototype.generateKeyText = function (osk) {
                    var util = window['keyman'].util;
                    var spec = this.spec;
                    // Add OSK key labels
                    var keyText;
                    var t = util._CreateElement('span'), ts = t.style;
                    if (spec['text'] == null || spec['text'] == '') {
                        keyText = '\xa0'; // default:  nbsp.
                        if (typeof spec['id'] == 'string') {
                            // If the ID's Unicode-based, just use that code.
                            if (/^U_[0-9A-F]{4}$/i.test(spec['id'])) {
                                keyText = String.fromCharCode(parseInt(spec['id'].substr(2), 16));
                            }
                        }
                    }
                    else {
                        keyText = spec['text'];
                    }
                    t.className = 'kmw-key-text';
                    // Use special case lookup for modifier keys
                    if (spec['sp'] == '1' || spec['sp'] == '2') {
                        // Unique layer-based transformation.
                        var tId = ((spec['text'] == '*Tab*' && this.layer == 'shift') ? '*TabLeft*' : spec['text']);
                        // Transforms our *___* special key codes into their corresponding PUA character codes for keyboard display.
                        keyText = this.renameSpecialKey(tId);
                    }
                    // Grab our default for the key's font and font size.
                    ts.fontSize = osk.fontSize; //Build 344, KMEW-90
                    //Override font spec if set for this key in the layout
                    if (typeof spec['font'] == 'string' && spec['font'] != '') {
                        ts.fontFamily = spec['font'];
                    }
                    if (typeof spec['fontsize'] == 'string' && spec['fontsize'] != '') {
                        ts.fontSize = spec['fontsize'];
                    }
                    var keyboardManager = window['keyman'].keyboardManager;
                    // For some reason, fonts will sometimes 'bug out' for the embedded iOS page if we
                    // instead assign fontFamily to the existing style 'ts'.  (Occurs in iOS 12.)
                    var styleSpec = { fontSize: ts.fontSize };
                    if (ts.fontFamily) {
                        styleSpec.fontFamily = ts.fontFamily;
                    }
                    else {
                        styleSpec.fontFamily = osk.fontFamily; // Helps with style sheet calculations.
                    }
                    // Check the key's display width - does the key visualize well?
                    var width = OSKKey.getTextWidth(osk, keyText, styleSpec);
                    if (width == 0 && keyText != '' && keyText != '\xa0') {
                        // Add the Unicode 'empty circle' as a base support for needy diacritics.
                        keyText = '\u25cc' + keyText;
                        if (keyboardManager.isRTL()) {
                            // Add the RTL marker to ensure it displays properly.
                            keyText = '\u200f' + keyText;
                        }
                        // Recompute the new width for use in autoscaling calculations below, just in case.
                        width = OSKKey.getTextWidth(osk, keyText, styleSpec);
                    }
                    var fontSpec = util.getFontSizeStyle(ts.fontSize);
                    var keyWidth = this.getKeyWidth(osk);
                    var maxProportion = 0.90;
                    var proportion = (keyWidth * maxProportion) / width; // How much of the key does the text want to take?
                    // Never upscale keys past the default - only downscale them.
                    if (proportion < 1) {
                        if (fontSpec.absolute) {
                            ts.fontSize = proportion * fontSpec.val + 'px';
                        }
                        else {
                            ts.fontSize = proportion * fontSpec.val + 'em';
                        }
                    }
                    // Finalize the key's text.
                    t.innerHTML = keyText;
                    return t;
                };
                return OSKKey;
            }());
            osk_3.OSKKey = OSKKey;
            var OSKBaseKey = /** @class */ (function (_super) {
                __extends(OSKBaseKey, _super);
                function OSKBaseKey(spec, layer, formFactor) {
                    return _super.call(this, spec, layer, formFactor) || this;
                }
                OSKBaseKey.prototype.getId = function (osk) {
                    // Define each key element id by layer id and key id (duplicate possible for SHIFT - does it matter?)
                    return this.layer + '-' + this.spec.id;
                };
                // Produces a small reference label for the corresponding physical key on a US keyboard.
                OSKBaseKey.prototype.generateKeyCapLabel = function () {
                    // Create the default key cap labels (letter keys, etc.)
                    var x = Codes.keyCodes[this.spec.id];
                    switch (x) {
                        // Converts the keyman key id code for common symbol keys into its representative ASCII code.
                        // K_COLON -> K_BKQUOTE
                        case 186:
                            x = 59;
                            break;
                        case 187:
                            x = 61;
                            break;
                        case 188:
                            x = 44;
                            break;
                        case 189:
                            x = 45;
                            break;
                        case 190:
                            x = 46;
                            break;
                        case 191:
                            x = 47;
                            break;
                        case 192:
                            x = 96;
                            break;
                        // K_LBRKT -> K_QUOTE
                        case 219:
                            x = 91;
                            break;
                        case 220:
                            x = 92;
                            break;
                        case 221:
                            x = 93;
                            break;
                        case 222:
                            x = 39;
                            break;
                        default:
                            // No other symbol character represents a base key on the standard QWERTY English layout.
                            if (x < 48 || x > 90) {
                                x = 0;
                            }
                    }
                    if (x > 0) {
                        var q = window['keyman'].util._CreateElement('div');
                        q.className = 'kmw-key-label';
                        q.innerHTML = String.fromCharCode(x);
                        return q;
                    }
                    else {
                        // Keyman-only virtual keys have no corresponding physical key.
                        return null;
                    }
                };
                OSKBaseKey.prototype.processSubkeys = function (btn) {
                    // Add reference to subkey array if defined
                    var bsn, bsk = btn['subKeys'] = this.spec['sk'];
                    // Transform any special keys into their PUA representations.
                    for (bsn = 0; bsn < bsk.length; bsn++) {
                        if (bsk[bsn]['sp'] == '1' || bsk[bsn]['sp'] == '2') {
                            var oldText = bsk[bsn]['text'];
                            bsk[bsn]['text'] = this.renameSpecialKey(oldText);
                        }
                        // If a subkey doesn't have a defined layer property, copy it from the base key's layer by default.
                        if (!bsk[bsn].layer) {
                            bsk[bsn].layer = btn.key.layer;
                        }
                    }
                    // If a subkey array is defined, add an icon
                    var skIcon = window['keyman'].util._CreateElement('div');
                    skIcon.className = 'kmw-key-popup-icon';
                    //kDiv.appendChild(skIcon);
                    btn.appendChild(skIcon);
                };
                OSKBaseKey.prototype.construct = function (osk, layout, rowStyle, totalPercent) {
                    var util = com.keyman.singleton.util;
                    var spec = this.spec;
                    var isDesktop = this.formFactor == "desktop";
                    var kDiv = util._CreateElement('div');
                    kDiv.className = 'kmw-key-square';
                    var ks = kDiv.style;
                    ks.width = this.objectGeometry(spec['widthpc'], osk.isStatic);
                    var originalPercent = totalPercent;
                    var btnEle = util._CreateElement('div');
                    var btn = link(btnEle, new KeyData(this, spec['id']));
                    // Set button class
                    osk.setButtonClass(spec, btn, layout);
                    // Set key and button positioning properties.
                    if (!isDesktop) {
                        // Regularize interkey spacing by rounding key width and padding (Build 390)
                        ks.left = this.objectGeometry(totalPercent + spec['padpc'], osk.isStatic);
                        if (!osk.isStatic) {
                            ks.bottom = rowStyle.bottom;
                        }
                        ks.height = rowStyle.height; //must be specified in px for rest of layout to work correctly
                        if (!osk.isStatic) {
                            // Set distinct phone and tablet button position properties
                            btn.style.left = ks.left;
                            btn.style.width = ks.width;
                        }
                    }
                    else {
                        ks.marginLeft = this.objectGeometry(spec['padpc'], osk.isStatic);
                    }
                    totalPercent = totalPercent + spec['padpc'] + spec['widthpc'];
                    // Add the (US English) keycap label for desktop OSK or if KDU flag is non-zero
                    if (layout.keyLabels || isDesktop) {
                        var keyCap = this.generateKeyCapLabel();
                        if (keyCap) {
                            btn.appendChild(keyCap);
                        }
                    }
                    // Define each key element id by layer id and key id (duplicate possible for SHIFT - does it matter?)
                    btn.id = this.getId(osk);
                    // Define callbacks to handle key touches: iOS and Android tablets and phones
                    // TODO: replace inline function calls??
                    if (!osk.isStatic && !osk.device.touchable) {
                        // Highlight key while mouse down or if moving back over originally selected key
                        btn.onmouseover = btn.onmousedown = osk.mouseOverMouseDownHandler; // Build 360
                        // Remove highlighting when key released or moving off selected element
                        btn.onmouseup = btn.onmouseout = osk.mouseUpMouseOutHandler; //Build 360
                    }
                    // Make sure the key text is the element's first child - processSubkeys()
                    // will add an extra element if subkeys exist, which can interfere with
                    // keyboard/language name display on the space bar!
                    btn.appendChild(this.generateKeyText(osk));
                    // Handle subkey-related tasks.
                    if (typeof (spec['sk']) != 'undefined' && spec['sk'] != null) {
                        this.processSubkeys(btn);
                    }
                    else {
                        btn['subKeys'] = null;
                    }
                    // Add text to button and button to placeholder div
                    kDiv.appendChild(btn);
                    // Prevent user selection of key captions
                    //t.style.webkitUserSelect='none';
                    // The 'return value' of this process.
                    return { element: kDiv, percent: totalPercent - originalPercent };
                };
                OSKBaseKey.prototype.objectGeometry = function (v, isStatic) {
                    var unit = this.objectUnits(isStatic);
                    if (unit == '%') {
                        return v + unit;
                    }
                    else { // unit == 'px'
                        return (Math.round(v * 100) / 100) + unit; // round to 2 decimal places, making css more readable
                    }
                };
                return OSKBaseKey;
            }(OSKKey));
            osk_3.OSKBaseKey = OSKBaseKey;
            var OSKSubKey = /** @class */ (function (_super) {
                __extends(OSKSubKey, _super);
                function OSKSubKey(spec, layer, formFactor) {
                    return _super.call(this, spec, layer, formFactor) || this;
                }
                OSKSubKey.prototype.getId = function (osk) {
                    var spec = this.spec;
                    // Create (temporarily) unique ID by prefixing 'popup-' to actual key ID
                    if (typeof (this.layer) == 'string' && this.layer != '') {
                        return 'popup-' + this.layer + '-' + spec['id'];
                    }
                    else {
                        // We only create subkeys when they're needed - the currently-active layer should be fine.
                        return 'popup-' + osk.layerId + '-' + spec['id'];
                    }
                };
                OSKSubKey.prototype.construct = function (osk, baseKey, topMargin) {
                    var spec = this.spec;
                    var kDiv = document.createElement('div');
                    var tKey = osk.getDefaultKeyObject();
                    var ks = kDiv.style;
                    for (var tp in tKey) {
                        if (typeof spec[tp] != 'string') {
                            spec[tp] = tKey[tp];
                        }
                    }
                    kDiv.className = 'kmw-key-square-ex';
                    if (topMargin) {
                        ks.marginTop = '5px';
                    }
                    if (typeof spec['width'] != 'undefined') {
                        ks.width = (parseInt(spec['width'], 10) * baseKey.offsetWidth / 100) + 'px';
                    }
                    else {
                        ks.width = baseKey.offsetWidth + 'px';
                    }
                    ks.height = baseKey.offsetHeight + 'px';
                    var btnEle = document.createElement('div');
                    var btn = link(btnEle, new KeyData(this, spec['id']));
                    osk.setButtonClass(spec, btn);
                    btn.id = this.getId(osk);
                    // Must set button size (in px) dynamically, not from CSS
                    var bs = btn.style;
                    bs.height = ks.height;
                    bs.width = ks.width;
                    // Must set position explicitly, at least for Android
                    bs.position = 'absolute';
                    btn.appendChild(this.generateKeyText(osk));
                    kDiv.appendChild(btn);
                    return kDiv;
                };
                return OSKSubKey;
            }(OSKKey));
            osk_3.OSKSubKey = OSKSubKey;
            //#endregion
            var VisualKeyboard = /** @class */ (function () {
                //#region OSK constructor and helpers
                /**
                 * @param       {Object}      PVK         Visual keyboard name
                 * @param       {Object}      Lhelp       true if OSK defined for this keyboard
                 * @param       {Object}      layout0
                 * @param       {Number}      kbdBitmask  Keyboard modifier bitmask
                 * Description  Generates the base visual keyboard element, prepping for attachment to KMW
                 */
                function VisualKeyboard(PVK, Lhelp, layout0, kbdBitmask, device, isStatic) {
                    // Do normal constructor stuff.
                    this.layerId = "default";
                    this.isStatic = false;
                    // State-related properties
                    this.ddOSK = false;
                    this.popupPending = false;
                    this.popupDelay = 500;
                    /**
                     * The main OSK touch start event handler
                     *
                     *  @param  {Event} e   touch start event object
                     *
                     */
                    this.touch = function (e) {
                        var Processor = com.keyman.singleton.textProcessor;
                        // Identify the key touched
                        var t = e.changedTouches[0].target, key = this.keyTarget(t);
                        // Save the touch point
                        this.touchX = e.changedTouches[0].pageX;
                        // Set the key for the new touch point to be current target, if defined
                        this.currentTarget = key;
                        // Clear repeated backspace if active, preventing 'sticky' behavior.
                        this.cancelDelete();
                        // Prevent multi-touch if popup displayed
                        var sk = document.getElementById('kmw-popup-keys');
                        if ((sk && sk.style.visibility == 'visible') || this.popupVisible) {
                            return;
                        }
                        // Keep track of number of active (unreleased) touch points
                        this.touchCount = e.touches.length;
                        // Get nearest key if touching a hidden key or the end of a key row
                        if ((key && (key.className.indexOf('key-hidden') >= 0))
                            || t.className.indexOf('kmw-key-row') >= 0) {
                            key = this.findNearestKey(e, t);
                        }
                        // Do not do anything if no key identified!
                        if (key == null) {
                            return;
                        }
                        // Get key name (K_...) from element ID
                        var keyName = key['keyId'];
                        // Highlight the touched key
                        this.highlightKey(key, true);
                        // Special function keys need immediate action
                        if (keyName == 'K_LOPT' || keyName == 'K_ROPT') {
                            window.setTimeout(function () {
                                Processor.clickKey(key);
                            }.bind(this), 0);
                            this.keyPending = null;
                            this.touchPending = null;
                            // Also backspace, to allow delete to repeat while key held
                        }
                        else if (keyName == 'K_BKSP') {
                            var touchProbabilities = this.getTouchProbabilities(e.changedTouches[0]);
                            // While we could inline the execution of the delete key here, we lose the ability to
                            // record the backspace key if we do so.
                            Processor.clickKey(key, e.changedTouches[0], this.layerId, touchProbabilities);
                            this.deleteKey = key;
                            this.deleting = window.setTimeout(this.repeatDelete, 500);
                            this.keyPending = null;
                            this.touchPending = null;
                        }
                        else {
                            if (this.keyPending) {
                                this.highlightKey(this.keyPending, false);
                                var touchProbabilities = this.getTouchProbabilities(this.touchPending);
                                Processor.clickKey(this.keyPending, this.touchPending, this.layerId, touchProbabilities);
                                this.clearPopup();
                                // Decrement the number of unreleased touch points to prevent
                                // sending the keystroke again when the key is actually released
                                this.touchCount--;
                            }
                            else {
                                // If this key has subkey, start timer to display subkeys after delay, set up release
                                this.touchHold(key);
                            }
                            this.keyPending = key;
                            this.touchPending = e.changedTouches[0];
                        }
                    }.bind(this);
                    /**
                     * OSK touch release event handler
                     *
                     *  @param  {Event} e   touch release event object
                     *
                     **/
                    this.release = function (e) {
                        var Processor = com.keyman.singleton.textProcessor;
                        // Prevent incorrect multi-touch behaviour if native or device popup visible
                        var sk = document.getElementById('kmw-popup-keys'), t = this.currentTarget;
                        // Clear repeated backspace if active, preventing 'sticky' behavior.
                        this.cancelDelete();
                        if ((sk && sk.style.visibility == 'visible')) {
                            // Ignore release if a multiple touch
                            if (e.touches.length > 0) {
                                return;
                            }
                            // Cancel (but do not execute) pending key if neither a popup key or the base key
                            if ((t == null) || ((t.id.indexOf('popup') < 0) && (t.id != this.popupBaseKey.id))) {
                                this.highlightKey(this.keyPending, false);
                                this.clearPopup();
                                this.keyPending = null;
                                this.touchPending = null;
                            }
                        }
                        // Only set when embedded in our Android/iOS app.  Signals that the device is handling 
                        // subkeys, so we shouldn't allow output for the base key.
                        //
                        // Note that on iOS (at least), this.release() will trigger before kmwembedded.ts's
                        // executePopupKey() function.
                        if (this.popupVisible) {
                            return;
                        }
                        // Handle menu key release event
                        if (t && t.id) {
                            this.optionKey(t, t.id, false);
                        }
                        // Test if moved off screen (effective release point must be corrected for touch point horizontal speed)
                        // This is not completely effective and needs some tweaking, especially on Android
                        var x = e.changedTouches[0].pageX;
                        var beyondEdge = ((x < 2 && this.touchX > 5) || (x > window.innerWidth - 2 && this.touchX < window.innerWidth - 5));
                        // Save then decrement current touch count
                        var tc = this.touchCount;
                        if (this.touchCount > 0) {
                            this.touchCount--;
                        }
                        // Process and clear highlighting of pending target
                        if (this.keyPending) {
                            this.highlightKey(this.keyPending, false);
                            // Output character unless moved off key
                            if (this.keyPending.className.indexOf('hidden') < 0 && tc > 0 && !beyondEdge) {
                                var touchProbabilities = this.getTouchProbabilities(e.changedTouches[0]);
                                Processor.clickKey(this.keyPending, e.changedTouches[0], this.layerId, touchProbabilities);
                            }
                            this.clearPopup();
                            this.keyPending = null;
                            this.touchPending = null;
                            // Always clear highlighting of current target on release (multi-touch)
                        }
                        else {
                            var tt = e.changedTouches[0];
                            t = this.keyTarget(tt.target);
                            if (!t) {
                                var t1 = document.elementFromPoint(tt.clientX, tt.clientY);
                                t = this.findNearestKey(e, t1);
                            }
                            this.highlightKey(t, false);
                        }
                    }.bind(this);
                    /**
                     * OSK touch move event handler
                     *
                     *  @param  {Event} e   touch move event object
                     *
                     **/
                    this.moveOver = function (e) {
                        var util = com.keyman.singleton.util;
                        e.preventDefault();
                        e.cancelBubble = true;
                        if (typeof e.stopImmediatePropagation == 'function') {
                            e.stopImmediatePropagation();
                        }
                        else if (typeof e.stopPropagation == 'function') {
                            e.stopPropagation();
                        }
                        // Shouldn't be possible, but just in case.
                        if (this.touchCount == 0) {
                            this.cancelDelete();
                            return;
                        }
                        // Get touch position
                        var x = typeof e.touches == 'object' ? e.touches[0].clientX : e.clientX, y = typeof e.touches == 'object' ? e.touches[0].clientY : e.clientY;
                        // Move target key and highlighting
                        var t = this.touchPending = e.changedTouches[0], t1 = document.elementFromPoint(x, y), key0 = this.keyPending, key1 = this.keyTarget(t1); // Not only gets base keys, but also gets popup keys!
                        // Find the nearest key to the touch point if not on a visible key
                        if ((key1 && key1.className.indexOf('key-hidden') >= 0) ||
                            (t1 && (!key1) && t1.className.indexOf('key-row') >= 0)) {
                            key1 = this.findNearestKey(e, t1);
                        }
                        // Stop repeat if no longer on BKSP key
                        if (key1 && (typeof key1.id == 'string') && (key1.id.indexOf('-K_BKSP') < 0)) {
                            this.cancelDelete();
                        }
                        // Do not attempt to support reselection of target key for overlapped keystrokes.
                        // Perform _after_ ensuring possible sticky keys have been cancelled.
                        if (e.touches.length > 1) {
                            return;
                        }
                        // Do not move over keys if device popup visible
                        if (this.popupVisible) {
                            if (key1 == null) {
                                if (key0) {
                                    this.highlightKey(key0, false);
                                }
                                this.keyPending = null;
                                this.touchPending = null;
                            }
                            else {
                                if (key1 == this.popupBaseKey) {
                                    if (!util.hasClass(key1, 'kmw-key-touched')) {
                                        this.highlightKey(key1, true);
                                    }
                                    this.keyPending = key1;
                                    this.touchPending = e.touches[0];
                                }
                                else {
                                    if (key0) {
                                        this.highlightKey(key0, false);
                                    }
                                    this.keyPending = null;
                                    this.touchPending = null;
                                }
                            }
                            return;
                        }
                        var sk = document.getElementById('kmw-popup-keys');
                        // Use the popup duplicate of the base key if a phone with a visible popup array
                        if (sk && sk.style.visibility == 'visible' && this.device.formFactor == 'phone' && key1 == this.popupBaseKey) {
                            key1 = sk.childNodes[0].firstChild;
                        }
                        // Identify current touch position (to manage off-key release)
                        this.currentTarget = key1;
                        // Clear previous key highlighting
                        if (key0 && key1 && key1 !== key0) {
                            this.highlightKey(key0, false);
                        }
                        // If popup is visible, need to move over popup, not over main keyboard
                        this.highlightSubKeys(key1, x, y);
                        if (sk && sk.style.visibility == 'visible') {
                            // Once a subkey array is displayed, do not allow changing the base key.
                            // Keep that array visible and accept no other options until the touch ends.
                            if (key1 && key1.id.indexOf('popup') < 0 && key1 != this.popupBaseKey) {
                                return;
                            }
                            // Highlight the base key on devices that do not append it to the subkey array.
                            if (key1 && key1 == this.popupBaseKey && key1.className.indexOf('kmw-key-touched') < 0) {
                                this.highlightKey(key1, true);
                            }
                            // Cancel touch if moved up and off keyboard, unless popup keys visible
                        }
                        else {
                            // _Box has (most of) the useful client values.
                            var _Box = this.kbdDiv.offsetParent; // == osk._Box
                            var height = this.kbdDiv.firstChild.offsetHeight; // firstChild == layer-group, has height info.
                            // We need to adjust the offset properties by any offsets related to the active banner.
                            var yMin = Math.max(5, this.kbdDiv.offsetTop + _Box.offsetTop - 0.25 * height);
                            if (key0 && e.touches[0].pageY < yMin) {
                                this.highlightKey(key0, false);
                                this.showKeyTip(null, false);
                                this.keyPending = null;
                                this.touchPending = null;
                            }
                        }
                        // Replace the target key, if any, by the new target key
                        // Do not replace a null target, as that indicates the key has already been released
                        if (key1 && this.keyPending) {
                            this.keyPending = key1;
                            this.touchPending = e.touches[0];
                        }
                        if (this.keyPending) {
                            if (key0 != key1 || key1.className.indexOf('kmw-key-touched') < 0) {
                                this.highlightKey(key1, true);
                            }
                        }
                        if (key0 && key1 && (key1 != key0) && (key1.id != '')) {
                            //  Display the touch-hold keys (after a pause)
                            this.touchHold(key1);
                            /*
                            // Clear and restart the popup timer
                            if(this.subkeyDelayTimer)
                            {
                              window.clearTimeout(this.subkeyDelayTimer);
                              this.subkeyDelayTimer = null;
                            }
                            if(key1.subKeys != null)
                            {
                              this.subkeyDelayTimer = window.setTimeout(
                                function()
                                {
                                  this.clearPopup();
                                  this.showSubKeys(key1);
                                }.bind(this),
                                this.popupDelay);
                            }
                            */
                        }
                    }.bind(this);
                    /**
                     *  Repeat backspace as long as the backspace key is held down
                     **/
                    this.repeatDelete = function () {
                        var Processor = com.keyman.singleton.textProcessor;
                        if (this.deleting) {
                            Processor.clickKey(this.deleteKey);
                            this.deleting = window.setTimeout(this.repeatDelete, 100);
                        }
                    }.bind(this);
                    //#region Mouse-event handling
                    /**
                     * Mouse down/mouse over event handler (desktop only)
                     *
                     * @param   {Event}  e  mouse over/mouse down event object
                     */
                    this.mouseOverMouseDownHandler = function (e) {
                        var keyman = com.keyman.singleton;
                        var util = keyman.util;
                        var t = util.eventTarget(e);
                        if (t === null || this.device.formFactor != 'desktop') {
                            return;
                        }
                        if (t.nodeName == 'SPAN') {
                            t = t.parentNode;
                        }
                        var key = this.keyTarget(t);
                        if (util.eventType(e) == 'mousedown') {
                            this.currentKey = key.id;
                            util._CancelMouse(e);
                            this.highlightKey(key, true);
                        }
                        else if (key.id == this.currentKey) {
                            this.highlightKey(key, true);
                        }
                    }.bind(this);
                    /**
                     * Mouse up/mouse out event handler (desktop only)
                     *
                     * @param   {Event}  e  mouse up/out event object
                     */
                    this.mouseUpMouseOutHandler = function (e) {
                        var keyman = com.keyman.singleton;
                        var util = keyman.util;
                        var t = util.eventTarget(e);
                        if (t === null || this.device.formFactor != 'desktop') {
                            return;
                        }
                        if (t.nodeName == 'SPAN') {
                            t = t.parentNode;
                        }
                        var key = this.keyTarget(t);
                        this.highlightKey(key, false);
                        // Process as click if mouse button released anywhere over key
                        if (util.eventType(e) == 'mouseup') {
                            if (key.id == this.currentKey) {
                                keyman.textProcessor.clickKey(key);
                            }
                            this.currentKey = '';
                        }
                    }.bind(this);
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    this.device = device = device || util.device;
                    if (isStatic) {
                        this.isStatic = isStatic;
                    }
                    var layout = layout0;
                    var Lkbd = util._CreateElement('div'), oskWidth; //s=Lkbd.style,
                    var activeKeyboard = keyman.keyboardManager.activeKeyboard;
                    // Build a layout using the default for the device
                    if (typeof layout != 'object' || layout == null) {
                        var kbdDevVersion;
                        // This CAN be called with no backing keyboard; KMW will try to force-show
                        // the OSK even without a backing keyboard on mobile, using the default
                        // layout as the OSK's base.
                        if (activeKeyboard) {
                            kbdDevVersion = new keyman_12.utils.Version(activeKeyboard['KVER']);
                        }
                        else {
                            kbdDevVersion = new keyman_12.utils.Version(keyman['version']);
                        }
                        layout = osk_3.Layouts.buildDefaultLayout(PVK, kbdDevVersion, kbdBitmask, device.formFactor);
                    }
                    // Create the collection of HTML elements from the device-dependent layout object
                    this.layout = osk_3.ActiveLayout.polyfill(layout, device.formFactor);
                    this.layers = layout['layer'];
                    // Override font if specified by keyboard
                    if ('font' in layout) {
                        this.fontFamily = layout['font'];
                    }
                    else {
                        this.fontFamily = '';
                    }
                    // Set flag to add default (US English) key label if specified by keyboard
                    if (typeof layout['displayUnderlying'] != 'undefined') {
                        layout.keyLabels = layout['displayUnderlying'] == true; // force bool
                    }
                    else {
                        layout.keyLabels = activeKeyboard && ((typeof (activeKeyboard['KDU']) != 'undefined') && activeKeyboard['KDU']);
                    }
                    var divLayerContainer = this.deviceDependentLayout(layout, device.formFactor);
                    this.ddOSK = true;
                    // Append the OSK layer group container element to the containing element
                    //osk.keyMap = divLayerContainer;
                    Lkbd.appendChild(divLayerContainer);
                    // Set base class - OS and keyboard added for Build 360
                    this.kbdHelpDiv = this.kbdDiv = Lkbd;
                    if (this.isStatic) {
                        // The 'documentation' format uses the base element's child as the actual display base.
                        Lkbd.childNodes[0].className = device.formFactor + '-static kmw-osk-inner-frame';
                    }
                    else {
                        Lkbd.className = device.formFactor + ' kmw-osk-inner-frame';
                    }
                }
                /**
                 * Returns the default properties for a key object, used to construct
                 * both a base keyboard key and popup keys
                 *
                 * @return    {Object}    An object that contains default key properties
                 */
                VisualKeyboard.prototype.getDefaultKeyObject = function () {
                    return new OSKKeySpec(undefined, '', osk_3.ActiveKey.DEFAULT_KEY.width, osk_3.ActiveKey.DEFAULT_KEY.sp, null, osk_3.ActiveKey.DEFAULT_KEY.pad);
                };
                ;
                /**
                 * Create the OSK for a particular keyboard and device
                 *
                 * @param       {Object}              layout      OSK layout definition
                 * @param       {string}              formFactor  layout form factor
                 * @return      {Object}                          fully formatted OSK object
                 */
                VisualKeyboard.prototype.deviceDependentLayout = function (layout, formFactor) {
                    var util = com.keyman.singleton.util;
                    var oskManager = com.keyman.singleton.osk;
                    var rowsPercent = 100;
                    var lDiv = util._CreateElement('div'), ls = lDiv.style, totalHeight = 0;
                    // Set OSK box default style
                    lDiv.className = 'kmw-key-layer-group';
                    // Adjust OSK height for mobile and tablet devices TODO move outside this function???
                    switch (formFactor) {
                        case 'phone':
                        case 'tablet':
                            totalHeight = oskManager.getHeight();
                            ls.height = totalHeight + 'px';
                            rowsPercent = Math.round(100 * oskManager.getKeyboardHeight() / totalHeight);
                            break;
                    }
                    // Return empty DIV if no layout defined
                    if (layout == null) {
                        return lDiv;
                    }
                    // Set default OSK font size (Build 344, KMEW-90)
                    var layoutFS = layout['fontsize'];
                    if (typeof layoutFS == 'undefined' || layoutFS == null || layoutFS == '') {
                        ls.fontSize = '1em';
                    }
                    else {
                        ls.fontSize = layout['fontsize'];
                    }
                    this.fontSize = ls.fontSize; //TODO: move outside function*********
                    // Create a separate OSK div for each OSK layer, only one of which will ever be visible
                    var n, i, j;
                    var layers, gDiv;
                    var rowHeight, rDiv;
                    var keys, key, rs, gs;
                    layers = layout['layer'];
                    // Set key default attributes (must use exportable names!)
                    var tKey = this.getDefaultKeyObject();
                    tKey['fontsize'] = ls.fontSize;
                    // Identify key labels (e.g. *Shift*) that require the special OSK font
                    var specialLabel = /\*\w+\*/;
                    // ***Delete any empty rows at the end added by compiler bug...
                    for (n = 0; n < layers.length; n++) {
                        var layer = layers[n];
                        var rows = layer['row'];
                        for (i = rows.length; i > 0; i--) {
                            if (rows[i - 1]['key'].length > 0) {
                                break;
                            }
                        }
                        if (i < rows.length) {
                            rows.splice(i - rows.length, rows.length - i);
                        }
                    }
                    // ...remove to here when compiler bug fixed ***
                    // Set the OSK row height, **assuming all layers have the same number of rows**
                    // Calculate default row height
                    rowHeight = rowsPercent / layers[0].row.length;
                    // For desktop OSK, use a percentage of the OSK height
                    if (formFactor == 'desktop') {
                        rowHeight = rowsPercent / layers[0].row.length;
                    }
                    // Get the actual available document width and scale factor according to device type
                    var objectWidth;
                    if (formFactor == 'desktop' || this.isStatic) {
                        objectWidth = 100;
                    }
                    else {
                        objectWidth = oskManager.getWidth();
                    }
                    if (!this.isStatic && this.device.touchable) { //  /*&& ('ontouchstart' in window)*/ // Except Chrome emulation doesn't set this.
                        // Not to mention, it's rather redundant.
                        lDiv.addEventListener('touchstart', this.touch, true);
                        // The listener below fails to capture when performing automated testing checks in Chrome emulation unless 'true'.
                        lDiv.addEventListener('touchend', this.release, true);
                        lDiv.addEventListener('touchmove', this.moveOver, false);
                        //lDiv.addEventListener('touchcancel', osk.cancel,false); //event never generated by iOS
                    }
                    for (n = 0; n < layers.length; n++) {
                        var layer = layers[n];
                        gDiv = util._CreateElement('div'), gs = gDiv.style;
                        gDiv.className = 'kmw-key-layer';
                        // Always make the first layer visible
                        gs.display = (n == 0 ? 'block' : 'none');
                        gs.height = ls.height;
                        // Set font for layer if defined in layout
                        if ('font' in layout)
                            gs.fontFamily = layout['font'];
                        else
                            gs.fontFamily = '';
                        gDiv['layer'] = gDiv['nextLayer'] = layer['id'];
                        if (typeof layer['nextlayer'] == 'string')
                            gDiv['nextLayer'] = layer['nextlayer'];
                        // Create a DIV for each row of the group
                        var rows = layer['row'];
                        for (i = 0; i < rows.length; i++) {
                            rDiv = util._CreateElement('div');
                            rDiv.className = 'kmw-key-row';
                            // The following event trap is needed to prevent loss of focus in IE9 when clicking on a key gap.
                            // Unclear why normal _CreateElement prevention of loss of focus does not seem to work here.
                            // Appending handler to event handler chain does not work (other event handling remains active).
                            rDiv.onmousedown = util.mouseDownPreventDefaultHandler; // Build 360
                            //util.attachDOMEvent(rDiv,'mousedown',function(e){if(e)e.preventDefault();
                            var row = rows[i];
                            rs = rDiv.style;
                            // Set row height. (Phone and tablet heights are later recalculated
                            // and set in px, allowing for viewport scaling.)
                            rs.maxHeight = rs.height = rowHeight + '%';
                            // Apply defaults, setting the width and other undefined properties for each key
                            keys = row['key'];
                            // Calculate actual key widths by multiplying by the OSK's width and rounding appropriately,
                            // adjusting the width of the last key to make the total exactly 100%.
                            // Overwrite the previously-computed percent.
                            // NB: the 'percent' suffix is historical, units are percent on desktop devices, but pixels on touch devices
                            // All key widths and paddings are rounded for uniformity
                            var keyPercent, padPercent, totalPercent = 0;
                            for (j = 0; j < keys.length - 1; j++) {
                                keyPercent = keys[j]['widthpc'] * objectWidth;
                                keys[j]['widthpc'] = keyPercent;
                                padPercent = keys[j]['padpc'] * objectWidth;
                                keys[j]['padpc'] = padPercent;
                                // Recompute center's x-coord with exact, in-browser values.
                                keys[j].proportionalX = (totalPercent + padPercent + (keyPercent / 2)) / objectWidth;
                                keys[j].proportionalWidth = keyPercent / objectWidth;
                                totalPercent += padPercent + keyPercent;
                            }
                            // Allow for right OSK margin (15 layout units)
                            var rightMargin = osk_3.ActiveKey.DEFAULT_RIGHT_MARGIN * objectWidth / layer.totalWidth;
                            totalPercent += rightMargin;
                            // If a single key, and padding is negative, add padding to right align the key
                            if (keys.length == 1 && parseInt(keys[0]['pad'], 10) < 0) {
                                keyPercent = keys[0]['widthpc'] * objectWidth;
                                keys[0]['widthpc'] = keyPercent;
                                totalPercent += keyPercent;
                                keys[0]['padpc'] = (objectWidth - totalPercent);
                                // Recompute center's x-coord with exact, in-browser values.
                                keys[0].proportionalX = (totalPercent - rightMargin - keyPercent / 2) / objectWidth;
                                keys[0].proportionalWidth = keyPercent / objectWidth;
                            }
                            else if (keys.length > 0) {
                                j = keys.length - 1;
                                padPercent = keys[j]['padpc'] * objectWidth;
                                keys[j]['padpc'] = padPercent;
                                totalPercent += padPercent;
                                keys[j]['widthpc'] = keyPercent = (objectWidth - totalPercent);
                                // Recompute center's x-coord with exact, in-browser values.
                                keys[j].proportionalX = (objectWidth - rightMargin - keyPercent / 2) / objectWidth;
                                keys[j].proportionalWidth = keyPercent / objectWidth;
                            }
                            //Create the key square (an outer DIV) for each key element with padding, and an inner DIV for the button (btn)
                            totalPercent = 0;
                            for (j = 0; j < keys.length; j++) {
                                key = keys[j];
                                var keyGenerator = new OSKBaseKey(key, layer['id'], formFactor);
                                var keyTuple = keyGenerator.construct(this, layout, rs, totalPercent);
                                rDiv.appendChild(keyTuple.element);
                                totalPercent += keyTuple.percent;
                            }
                            // Add row to layer
                            gDiv.appendChild(rDiv);
                        }
                        // Add layer to group
                        lDiv.appendChild(gDiv);
                    }
                    return lDiv;
                };
                //#endregion
                //#region OSK touch handlers
                VisualKeyboard.prototype.getTouchCoordinatesOnKeyboard = function (touch) {
                    var keyman = com.keyman.singleton;
                    // We need to compute the 'local', keyboard-based coordinates for the touch.
                    var kbdCoords = keyman.util.getAbsolute(this.kbdDiv.firstChild);
                    var offsetCoords = { x: touch.pageX - kbdCoords.x, y: touch.pageY - kbdCoords.y };
                    var layerGroup = this.kbdDiv.firstChild; // Always has proper dimensions, unlike kbdDiv itself.
                    offsetCoords.x /= layerGroup.offsetWidth;
                    offsetCoords.y /= layerGroup.offsetHeight;
                    return offsetCoords;
                };
                VisualKeyboard.prototype.getTouchProbabilities = function (touch) {
                    var keyman = com.keyman.singleton;
                    if (!keyman.modelManager.mayCorrect) {
                        return null;
                    }
                    var touchKbdPos = this.getTouchCoordinatesOnKeyboard(touch);
                    var layerGroup = this.kbdDiv.firstChild; // Always has proper dimensions, unlike kbdDiv itself.
                    return this.layout.layer[this.layerIndex].getTouchProbabilities(touchKbdPos, layerGroup.offsetWidth / layerGroup.offsetHeight);
                };
                /**
                 * Get the current key target from the touch point element within the key
                 *
                 * @param   {Object}  t   element at touch point
                 * @return  {Object}      the key element (or null)
                 **/
                VisualKeyboard.prototype.keyTarget = function (target) {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    var t = target;
                    try {
                        if (t) {
                            if (util.hasClass(t, 'kmw-key')) {
                                return getKeyFrom(t);
                            }
                            if (t.parentNode && util.hasClass(t.parentNode, 'kmw-key')) {
                                return getKeyFrom(t.parentNode);
                            }
                            if (t.firstChild && util.hasClass(t.firstChild, 'kmw-key')) {
                                return getKeyFrom(t.firstChild);
                            }
                        }
                    }
                    catch (ex) { }
                    return null;
                };
                /**
                 * Identify the key nearest to the touch point if at the end of a key row,
                 * but return null more than about 0.6 key width from the nearest key.
                 *
                 *  @param  {Event}   e   touch event
                 *  @param  {Object}  t   HTML object at touch point
                 *  @return {Object}      nearest key to touch point
                 *
                 **/
                VisualKeyboard.prototype.findNearestKey = function (e, t) {
                    if ((!e) || (typeof e.changedTouches == 'undefined')
                        || (e.changedTouches.length == 0)) {
                        return null;
                    }
                    // Get touch point on screen
                    var x = e.changedTouches[0].pageX;
                    // Get key-row beneath touch point
                    while (t && t.className !== undefined && t.className.indexOf('key-row') < 0) {
                        t = t.parentNode;
                    }
                    if (!t) {
                        return null;
                    }
                    // Find minimum distance from any key
                    var k, k0 = 0, dx, dxMax = 24, dxMin = 100000, x1, x2;
                    for (k = 0; k < t.childNodes.length; k++) {
                        var childNode = t.childNodes[k];
                        if (childNode.className !== undefined && childNode.className.indexOf('key-hidden') >= 0) {
                            continue;
                        }
                        x1 = childNode.offsetLeft;
                        x2 = x1 + childNode.offsetWidth;
                        if (x >= x1 && x <= x2) {
                            // Within the key square
                            return childNode.firstChild;
                        }
                        dx = x1 - x;
                        if (dx >= 0 && dx < dxMin) {
                            // To right of key
                            k0 = k;
                            dxMin = dx;
                        }
                        dx = x - x2;
                        if (dx >= 0 && dx < dxMin) {
                            // To left of key
                            k0 = k;
                            dxMin = dx;
                        }
                    }
                    if (dxMin < 100000) {
                        t = t.childNodes[k0];
                        x1 = t.offsetLeft;
                        x2 = x1 + t.offsetWidth;
                        // Limit extended touch area to the larger of 0.6 of key width and 24 px
                        if (t.offsetWidth > 40) {
                            dxMax = 0.6 * t.offsetWidth;
                        }
                        if (((x1 - x) >= 0 && (x1 - x) < dxMax) || ((x - x2) >= 0 && (x - x2) < dxMax)) {
                            return t.firstChild;
                        }
                    }
                    return null;
                };
                /**
                 * Cancels any active repeatDelete() timeouts, ensuring that
                 * repeating backspace operations are properly terminated.
                 */
                VisualKeyboard.prototype.cancelDelete = function () {
                    // Clears the delete-repeating timeout.
                    if (this.deleting) {
                        window.clearTimeout(this.deleting);
                    }
                    this.deleting = 0;
                };
                //#endregion
                // cancel = function(e) {} //cancel event is never generated by iOS
                /**
                 * Function     findKeyElement
                 * Scope        Private
                 * @param       {string}   layerId
                 * @param       {string}   keyId
                 * Description  Finds the DOM element associated with the specified key, if it exists.
                 */
                VisualKeyboard.prototype.findKeyElement = function (layerId, keyId) {
                    var layerGroup = this.kbdDiv.firstChild;
                    for (var i = 0; i < layerGroup.childElementCount; i++) {
                        // TODO:  At some point, our OSK construction should 'link' a TS metadata type to this, 
                        // like with OSKKey / KeyElement for keys.
                        var layer = layerGroup.childNodes[i];
                        // row -> key-square -> actual KeyElement.
                        var currentLayerId = layer.firstChild.firstChild.firstChild.key.layer;
                        if (currentLayerId == layerId) {
                            // Layer identified!  Now to find the key.  First - iterate over rows.
                            for (var r = 0; r < layer.childElementCount; r++) {
                                var row = layer.childNodes[r];
                                for (var k = 0; k < row.childElementCount; k++) {
                                    var key = row.childNodes[k].firstChild;
                                    if (key.keyId == keyId) {
                                        return key;
                                    }
                                }
                            }
                        }
                    }
                    return null;
                };
                /**
                 * Function     _UpdateVKShiftStyle
                 * Scope        Private
                 * @param       {string=}   layerId
                 * Description  Updates the OSK's visual style for any toggled state keys
                 */
                VisualKeyboard.prototype._UpdateVKShiftStyle = function (layerId) {
                    var i, n, layer = null, layerElement = null;
                    var Processor = com.keyman.singleton.textProcessor;
                    if (layerId) {
                        for (n = 0; n < this.layers.length; n++) {
                            if (this.layers[n]['id'] == this.layerId) {
                                break;
                            }
                        }
                        return; // Failed to find the requested layer.
                    }
                    else {
                        n = this.layerIndex;
                        layerId = this.layers[n]['id'];
                    }
                    layer = this.layers[n];
                    // Set the on/off state of any visible state keys.
                    var states = ['K_CAPS', 'K_NUMLOCK', 'K_SCROLL'];
                    var keys = [layer.capsKey, layer.numKey, layer.scrollKey];
                    for (i = 0; i < keys.length; i++) {
                        // Skip any keys not in the OSK!
                        if (keys[i] == null) {
                            continue;
                        }
                        keys[i]['sp'] = Processor.stateKeys[states[i]] ? osk_3.Layouts.buttonClasses['SHIFT-ON'] : osk_3.Layouts.buttonClasses['SHIFT'];
                        var keyId = layerId + '-' + states[i];
                        var btn = document.getElementById(keyId);
                        if (btn == null) {
                            //This can happen when using BuildDocumentationKeyboard, as the OSK isn't yet in the
                            //document hierarchy.  Sometimes.  (It's weird.)
                            btn = this.findKeyElement(layerId, states[i]);
                        }
                        if (btn != null) {
                            this.setButtonClass(keys[i], btn, this.layout);
                        }
                        else {
                            console.warn("Could not find key to apply style: \"" + keyId + "\"");
                        }
                    }
                };
                /**
                 * Attach appropriate class to each key button, according to the layout
                 *
                 * @param       {Object}    key     key object
                 * @param       {Object}    btn     button object
                 * @param       {Object=}   layout  source layout description (optional, sometimes)
                 */
                VisualKeyboard.prototype.setButtonClass = function (key, btn, layout) {
                    var keyman = com.keyman.singleton;
                    var n = 0, keyTypes = ['default', 'shift', 'shift-on', 'special', 'special-on', '', '', '', 'deadkey', 'blank', 'hidden'];
                    if (typeof key['dk'] == 'string' && key['dk'] == '1') {
                        n = 8;
                    }
                    if (typeof key['sp'] == 'string') {
                        n = parseInt(key['sp'], 10);
                    }
                    if (n < 0 || n > 10) {
                        n = 0;
                    }
                    layout = layout || this.layout;
                    // Apply an overriding class for 5-row layouts
                    var nRows = layout['layer'][0]['row'].length;
                    if (nRows > 4 && this.device.formFactor == 'phone') {
                        btn.className = 'kmw-key kmw-5rows kmw-key-' + keyTypes[n];
                    }
                    else {
                        btn.className = 'kmw-key kmw-key-' + keyTypes[n];
                    }
                };
                VisualKeyboard.prototype.clearPopup = function () {
                    var oskManager = com.keyman.singleton.osk;
                    // Remove the displayed subkey array, if any, and cancel popup request
                    var sk = document.getElementById('kmw-popup-keys');
                    if (sk != null) {
                        if (sk.shim) {
                            oskManager._Box.removeChild(sk.shim);
                        }
                        sk.parentNode.removeChild(sk);
                    }
                    if (this.popupCallout) {
                        oskManager._Box.removeChild(this.popupCallout);
                    }
                    this.popupCallout = null;
                    if (this.subkeyDelayTimer) {
                        window.clearTimeout(this.subkeyDelayTimer);
                        this.subkeyDelayTimer = null;
                    }
                    this.popupBaseKey = null;
                };
                //#region 'native'-mode subkey handling
                /**
                 * Display touch-hold array of 'sub-keys' above the currently touched key
                 * @param       {Object}    e      primary key element
                 */
                VisualKeyboard.prototype.showSubKeys = function (e) {
                    // Do not show subkeys if key already released
                    if (this.keyPending == null) {
                        return;
                    }
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    var device = this.device;
                    // A tag we directly set on a key element during its construction.
                    var subKeySpec = e['subKeys'];
                    // Create holder DIV for subkey array, and set styles.
                    // A subkey array for Shift will only appear if extra layers exist
                    // The holder is position:fixed, but the keys do not need to be, as no scrolling
                    // is possible while the array is visible.  So it is simplest to let the keys have
                    // position:static and display:inline-block
                    var subKeys = document.createElement('DIV'), i;
                    var tKey = this.getDefaultKeyObject();
                    subKeys.id = 'kmw-popup-keys';
                    this.popupBaseKey = e;
                    // Does the popup array include the base key?   *** condition for phone only ***
                    if (device.formFactor == 'phone') {
                        this.prependBaseKey(e);
                    }
                    // Must set position dynamically, not in CSS
                    var ss = subKeys.style;
                    ss.bottom = (parseInt(e.style.bottom, 10) + parseInt(e.style.height, 10) + 4) + 'px';
                    // Set key font according to layout, or defaulting to OSK font
                    // (copied, not inherited, since OSK is not a parent of popup keys)
                    ss.fontFamily = this.fontFamily;
                    // Copy the font size from the parent key, allowing for style inheritance
                    ss.fontSize = keyman.util.getStyleValue(e, 'font-size');
                    ss.visibility = 'hidden';
                    var nKeys = subKeySpec.length, nRow, nRows, nCols;
                    nRows = Math.min(Math.ceil(nKeys / 9), 2);
                    nCols = Math.ceil(nKeys / nRows);
                    if (nRows > 1) {
                        ss.width = (nCols * e.offsetWidth + nCols * 5) + 'px';
                    }
                    // Add nested button elements for each sub-key
                    for (i = 0; i < nKeys; i++) {
                        var needsTopMargin = false;
                        var nRow_1 = Math.floor(i / nCols);
                        if (nRows > 1 && nRow_1 > 0) {
                            needsTopMargin = true;
                        }
                        var keyGenerator = new com.keyman.osk.OSKSubKey(subKeySpec[i], e['key'].layer, device.formFactor);
                        var kDiv = keyGenerator.construct(this, e, needsTopMargin);
                        subKeys.appendChild(kDiv);
                    }
                    // Clear key preview if any
                    this.showKeyTip(null, false);
                    // Otherwise append the touch-hold (subkey) array to the OSK
                    keyman.osk._Box.appendChild(subKeys);
                    // And correct its position with respect to that element
                    ss = subKeys.style;
                    var x = keyman_12.dom.Utils.getAbsoluteX(e) + 0.5 * (e.offsetWidth - subKeys.offsetWidth), y, xMax = (util.landscapeView() ? screen.height : screen.width) - subKeys.offsetWidth;
                    if (x > xMax) {
                        x = xMax;
                    }
                    if (x < 0) {
                        x = 0;
                    }
                    ss.left = x + 'px';
                    // Make the popup keys visible
                    ss.visibility = 'visible';
                    // For now, should only be true (in production) when keyman.isEmbedded == true.
                    var constrainPopup = keyman.isEmbedded;
                    var cs = getComputedStyle(subKeys);
                    var oskHeight = keyman.osk.getHeight();
                    var bottomY = parseInt(cs.bottom, 10);
                    var popupHeight = parseInt(cs.height, 10);
                    var delta = 0;
                    if (popupHeight + bottomY > oskHeight && constrainPopup) {
                        delta = popupHeight + bottomY - oskHeight;
                        ss.bottom = (bottomY - delta) + 'px';
                    }
                    // Add the callout
                    this.popupCallout = this.addCallout(e, delta);
                    // And add a filter to fade main keyboard
                    subKeys.shim = document.createElement('DIV');
                    subKeys.shim.id = 'kmw-popup-shim';
                    keyman.osk._Box.appendChild(subKeys.shim);
                    // Highlight the duplicated base key (if a phone)
                    if (device.formFactor == 'phone') {
                        var bk = subKeys.childNodes[0].firstChild;
                        this.keyPending = bk;
                        this.highlightKey(bk, true); //bk.className = bk.className+' kmw-key-touched';
                    }
                };
                /**
                 * Prepend the base key to the touch-hold key array (for phones)
                 *
                 * @param {Object}  e   base key object
                 */
                VisualKeyboard.prototype.prependBaseKey = function (e) {
                    // This is a tag we set on the key element during its construction.
                    var subKeys = e['subKeys'];
                    var keyman = com.keyman.singleton;
                    if (e && typeof (e.id) != 'undefined') {
                        //TODO: refactor this, it's pretty messy...
                        var i, idx = e.id.split('-'), baseId = e['keyId'], layer = e['key'].spec['layer'], sp = e['key'].spec['sp'], nextlayer = e['key'].spec['nextlayer'];
                        if (typeof subKeys != 'undefined' && subKeys.length > 0 && (subKeys[0].id != baseId || subKeys[0].layer != layer)) {
                            var eCopy = new OSKKeySpec(baseId, '', undefined, sp, nextlayer); // {'id':baseId,'layer':'','key':undefined};
                            if (layer != '') {
                                eCopy['layer'] = layer;
                            }
                            for (i = 0; i < e.childNodes.length; i++) {
                                if (keyman.util.hasClass(e.childNodes[i], 'kmw-key-text')) {
                                    break;
                                }
                            }
                            if (i < e.childNodes.length) {
                                eCopy['text'] = e.childNodes[i].textContent;
                            }
                            subKeys.splice(0, 0, eCopy);
                        }
                    }
                };
                //#endregion
                /**
                 * Indicate the current language and keyboard on the space bar
                 **/
                VisualKeyboard.prototype.showLanguage = function () {
                    var keyman = com.keyman.singleton;
                    var lgName = '', kbdName = '';
                    var activeStub = keyman.keyboardManager.activeStub;
                    if (activeStub) {
                        lgName = activeStub['KL'];
                        kbdName = activeStub['KN'];
                    }
                    else if (keyman.getActiveLanguage(true)) {
                        lgName = keyman.getActiveLanguage(true);
                    }
                    else {
                        lgName = 'English';
                    }
                    try {
                        var t = this.spaceBar.firstChild;
                        var tParent = t.parentNode;
                        if (typeof (tParent.className) == 'undefined' || tParent.className == '') {
                            tParent.className = 'kmw-spacebar';
                        }
                        else if (tParent.className.indexOf('kmw-spacebar') == -1) {
                            tParent.className += ' kmw-spacebar';
                        }
                        t.className = 'kmw-spacebar-caption';
                        kbdName = kbdName.replace(/\s*keyboard\s*/i, '');
                        // We use a separate variable here to keep down on MutationObserver messages in keymanweb.js code.
                        var keyboardName = "";
                        if (kbdName == lgName) {
                            keyboardName = lgName;
                        }
                        else {
                            keyboardName = lgName + ' (' + kbdName + ')';
                        }
                        // It sounds redundant, but this dramatically cuts down on browser DOM processing.
                        if (t.innerHTML != keyboardName) {
                            t.innerHTML = keyboardName;
                        }
                    }
                    catch (ex) { }
                };
                /**
                 *  Add or remove a class from a keyboard key (when touched or clicked)
                 *  or add a key preview for phone devices
                 *
                 *  @param    {Object}    key   key affected
                 *  @param    {boolean}   on    add or remove highlighting
                 **/
                VisualKeyboard.prototype.highlightKey = function (key, on) {
                    // Do not change element class unless a key
                    if (!key || (key.className == '') || (key.className.indexOf('kmw-key-row') >= 0))
                        return;
                    var classes = key.className, cs = ' kmw-key-touched';
                    // For phones, use key preview rather than highlighting the key,
                    // except for space, bksp, enter, shift and popup keys
                    var usePreview = ((this.keytip != null)
                        && (classes.indexOf('kmw-key-shift') < 0)
                        && (classes.indexOf('kmw-spacebar') < 0)
                        && (key.id.indexOf('popup') < 0));
                    if (usePreview) {
                        this.showKeyTip(key, on);
                    }
                    else {
                        if (on && classes.indexOf(cs) < 0) {
                            key.className = classes + cs;
                            this.showKeyTip(null, false); // Moved here by Serkan
                        }
                        else {
                            key.className = classes.replace(cs, '');
                        }
                    }
                };
                //#endregion
                VisualKeyboard.prototype.getKeyEmFontSize = function () {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    if (this.device.formFactor == 'desktop') {
                        var kbdFontSize = this.getFontSizeFromCookie();
                        var keySquareScale = 0.8; // Set in kmwosk.css, is relative.
                        return kbdFontSize * keySquareScale;
                    }
                    else {
                        var emSizeStr = getComputedStyle(document.body).fontSize;
                        var emSize = util.getFontSizeStyle(emSizeStr).val;
                        var emScale = 1;
                        if (!this.isStatic) {
                            // Reading this requires the OSK to be active, so we filter out
                            // BuildVisualKeyboard calls here.
                            emScale = util.getFontSizeStyle(keyman.osk._Box).val;
                        }
                        return emSize * emScale;
                    }
                };
                VisualKeyboard.prototype.getFontSizeFromCookie = function () {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    var c = util.loadCookie('KeymanWeb_OnScreenKeyboard');
                    if (typeof (c) == 'undefined' || c == null) {
                        return 16;
                    }
                    var newHeight = util.toNumber(c['height'], 0.15 * screen.height);
                    if (newHeight > 0.5 * screen.height) {
                        newHeight = 0.5 * screen.height;
                    }
                    return (newHeight / 8);
                };
                /**
             *  Set the reference to a special function key for the
             *  currently visible OSK layer
             *
             *  @param    {number}  nLayer  Index of visible layer
             *  @param    {string}  keyId   key identifier
             *  @return   {Object}          Reference to key
             */
                VisualKeyboard.prototype.getSpecialKey = function (nLayer, keyId) {
                    var layers = this.kbdDiv.childNodes[0].childNodes;
                    if (nLayer >= 0 && nLayer < layers.length) {
                        // Special function keys will always be in bottom row (must modify code if not)
                        var rows = layers[nLayer].childNodes;
                        var keys = rows[rows.length - 1].childNodes;
                        for (var k = 0; k < keys.length; k++) {
                            var key = getKeyFrom(keys[k].firstChild);
                            if (key && key['keyId'] == keyId) {
                                return key;
                            }
                        }
                    }
                    return null;
                };
                VisualKeyboard.prototype.show = function () {
                    var device = this.device;
                    var n, nLayer = -1, b = this.kbdDiv.childNodes[0].childNodes;
                    for (n = 0; n < b.length; n++) {
                        var layerElement = b[n];
                        if (layerElement['layer'] == this.layerId) {
                            layerElement.style.display = 'block';
                            //b[n].style.visibility='visible';
                            this.nextLayer = this.layerId;
                            this.layerIndex = nLayer = n;
                            if (typeof this.layers[n]['nextlayer'] == 'string') {
                                this.nextLayer = this.layers[n]['nextlayer'];
                            }
                            // If osk._Show has been called, there's probably been a change in modifier or state key state.  Keep it updated!
                            this._UpdateVKShiftStyle();
                        }
                        else {
                            layerElement.style.display = 'none';
                            //layerElement.style.visibility='hidden';
                        }
                    }
                    if (device.touchable) {
                        // Identify and save references to the language key, hide keyboard key, and space bar
                        this.lgKey = this.getSpecialKey(nLayer, 'K_LOPT'); //TODO: should be saved with layer
                        this.hkKey = this.getSpecialKey(nLayer, 'K_ROPT');
                        // Always adjust screen height if iPhone or iPod, to take account of viewport changes
                        if (device.OS == 'iOS' && device.formFactor == 'phone') {
                            this.adjustHeights();
                        }
                    }
                    // Define for both desktop and touchable OSK
                    this.spaceBar = this.getSpecialKey(nLayer, 'K_SPACE'); //TODO: should be saved with layer
                };
                /**
                 * Function     showLayer
                 * Scope        Private
                 * @param       {string}      id      ID of the layer to show
                 * @return      {boolean}             true if the layer is shown, or false if it cannot be found
                 * Description  Shows the layer identified by 'id' in the on screen keyboard
                 */
                VisualKeyboard.prototype.showLayer = function (id) {
                    var keyman = com.keyman.singleton;
                    // Do not change layer unless needed (27/08/2015)
                    if (id == this.layerId && this.device.formFactor != 'desktop') {
                        // The layer's already shown, so report success.
                        return true;
                    }
                    if (keyman.keyboardManager.activeKeyboard) {
                        for (var i = 0; i < this.layers.length; i++) {
                            if (this.layers[i].id == id) {
                                this.layerId = id;
                                keyman.osk._Show();
                                return true;
                            }
                        }
                    }
                    return false;
                };
                /**
                 * Adjust the absolute height of each keyboard element after a rotation
                 *
                 **/
                VisualKeyboard.prototype.adjustHeights = function () {
                    var keyman = com.keyman.singleton;
                    var _Box = keyman.osk._Box;
                    var device = this.device;
                    if (!_Box || !this.kbdDiv || !this.kbdDiv.firstChild || !this.kbdDiv.firstChild.firstChild.childNodes) {
                        return false;
                    }
                    var fs = 1.0;
                    // TODO: Logically, this should be needed for Android, too - may need to be changed for the next version!
                    if (device.OS == 'iOS' && !keyman.isEmbedded) {
                        fs = fs / keyman.util.getViewportScale();
                    }
                    var oskHeight = this.computedAdjustedOskHeight();
                    var b = _Box, bs = b.style;
                    bs.height = bs.maxHeight = oskHeight + 'px';
                    b = this.kbdDiv.firstChild;
                    bs = b.style;
                    // Sets the layer group to the correct height.
                    bs.height = bs.maxHeight = oskHeight + 'px';
                    bs.fontSize = fs + 'em';
                    this.adjustLayerHeights(oskHeight);
                    return true;
                };
                VisualKeyboard.prototype.computedAdjustedOskHeight = function () {
                    var oskManager = com.keyman.singleton.osk;
                    var device = this.device;
                    var layers = this.kbdDiv.firstChild.childNodes;
                    var kbdHeight = oskManager.getKeyboardHeight();
                    var oskHeight = 0;
                    // In case the keyboard's layers have differing row counts, we check them all for the maximum needed oskHeight.
                    for (var i = 0; i < layers.length; i++) {
                        var nRows = layers[i].childNodes.length;
                        var rowHeight = Math.floor(kbdHeight / (nRows == 0 ? 1 : nRows));
                        var layerHeight = nRows * rowHeight;
                        if (layerHeight > oskHeight) {
                            oskHeight = layerHeight;
                        }
                    }
                    // This isn't set anywhere else; it's a legacy part of the original methods.
                    var oskPad = 0;
                    var oskPaddedHeight = oskHeight + oskPad;
                    if (device.OS == 'Android' && 'devicePixelRatio' in window) {
                        oskPaddedHeight /= window.devicePixelRatio;
                    }
                    return oskPaddedHeight;
                };
                VisualKeyboard.prototype.adjustLayerHeights = function (oskHeight) {
                    var oskManager = com.keyman.singleton.osk;
                    var device = this.device;
                    var layers = this.kbdDiv.firstChild.childNodes;
                    for (var nLayer = 0; nLayer < layers.length; nLayer++) {
                        // Check the heights of each row, in case different layers have different row counts.
                        var layer = layers[nLayer];
                        var nRows = layers[nLayer].childNodes.length;
                        layers[nLayer].style.height = (oskHeight) + 'px';
                        var rowHeight = Math.floor(oskManager.getKeyboardHeight() / (nRows == 0 ? 1 : nRows));
                        if (device.OS == 'Android' && 'devicePixelRatio' in window) {
                            layer.style.height = layer.style.maxHeight = oskHeight + 'px';
                            rowHeight /= window.devicePixelRatio;
                        }
                        // Sets the layers to the correct height
                        var rowPad = Math.round(0.15 * rowHeight);
                        for (var nRow = 0; nRow < nRows; nRow++) {
                            var rs = layers[nLayer].childNodes[nRow].style;
                            var bottom = (nRows - nRow - 1) * rowHeight + 1;
                            if (!this.isStatic) {
                                rs.bottom = bottom + 'px';
                            }
                            rs.maxHeight = rs.height = rowHeight + 'px';
                            // Calculate the exact vertical coordinate of the row's center.
                            this.layout.layer[nLayer].row[nRow].proportionalY = ((oskHeight - bottom) - rowHeight / 2) / oskHeight;
                            var keys = layers[nLayer].childNodes[nRow].childNodes;
                            this.adjustRowHeights(keys, rowHeight, bottom, rowPad);
                        }
                    }
                };
                VisualKeyboard.prototype.adjustRowHeights = function (keys, rowHeight, bottom, pad) {
                    var util = com.keyman.singleton.util;
                    var device = this.device;
                    var resizeLabels = (device.OS == 'iOS' && device.formFactor == 'phone' && util.landscapeView());
                    var nKeys = keys.length;
                    for (var nKey = 0; nKey < nKeys; nKey++) {
                        var key = keys[nKey];
                        //key.style.marginTop = (device.formFactor == 'phone' ? pad : 4)+'px';
                        //**no longer needed if base key label and popup icon are within btn, not container**
                        // Must set the height of the btn DIV, not the label (if any)
                        var j;
                        for (j = 0; j < key.childNodes.length; j++) {
                            if (util.hasClass(key.childNodes[j], 'kmw-key')) {
                                break;
                            }
                        }
                        // Set the kmw-key-square position
                        var ks = key.style;
                        if (!this.isStatic) {
                            ks.bottom = (bottom - pad / 2) + 'px';
                        }
                        ks.height = ks.minHeight = (rowHeight) + 'px';
                        // Set the kmw-key position
                        ks = key.childNodes[j].style;
                        if (!this.isStatic) {
                            ks.bottom = bottom + 'px';
                        }
                        ks.height = ks.minHeight = (rowHeight - pad) + 'px';
                        // Rescale keycap labels on iPhone (iOS 7)
                        if (resizeLabels && (j > 0)) {
                            key.childNodes[0].style.fontSize = '6px';
                        }
                    }
                };
                // /**
                //  * Function     _VKeyGetTarget
                //  * Scope        Private
                //  * @param       {Object}    e     OSK event
                //  * @return      {Object}          Target element for key in OSK
                //  * Description  Identify the OSK key clicked
                //  */
                // _VKeyGetTarget(e: Event) {
                //   var Ltarg;
                //   e = keymanweb._GetEventObject(e);   // I2404 - Manage IE events in IFRAMEs
                //   Ltarg = util.eventTarget(e);
                //   if (Ltarg == null) {
                //     return null;
                //   }
                //   if (Ltarg.nodeType == 3) { // defeat Safari bug
                //     Ltarg = Ltarg.parentNode;
                //   }
                //   if (Ltarg.tagName == 'SPAN') {
                //     Ltarg = Ltarg.parentNode;
                //   }
                //   return Ltarg;
                // }
                /**
                 *  Append a style sheet for the current keyboard if needed for specifying an embedded font
                 *  or to re-apply the default element font
                 *
                 **/
                VisualKeyboard.prototype.appendStyleSheet = function () {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    var activeKeyboard = keymanweb.keyboardManager.activeKeyboard;
                    var activeStub = keymanweb.keyboardManager.activeStub;
                    // Do not do anything if a null stub
                    if (activeStub == null) {
                        return;
                    }
                    // First remove any existing keyboard style sheet
                    if (this.styleSheet) {
                        util.removeStyleSheet(this.styleSheet);
                    }
                    var i, kfd = activeStub['KFont'], ofd = activeStub['KOskFont'];
                    // Add style sheets for embedded fonts if necessary (each font-face style will only be added once)
                    util.addFontFaceStyleSheet(kfd);
                    util.addFontFaceStyleSheet(ofd);
                    // Temporarily hide duplicated elements on non-desktop browsers
                    keymanweb.hideInputs();
                    // Build the style string and append (or replace) the font style sheet
                    // Note: Some browsers do not download the font-face font until it is applied,
                    //       so must apply style before testing for font availability
                    // Extended to allow keyboard-specific custom styles for Build 360
                    var customStyle = this.addFontStyle(kfd, ofd);
                    if (activeKeyboard != null && typeof (activeKeyboard['KCSS']) == 'string') // KMEW-129
                        customStyle = customStyle + activeKeyboard['KCSS'];
                    this.styleSheet = util.addStyleSheet(customStyle); //Build 360
                    // Wait until font is loaded then align duplicated input elements with page elements
                    if (this.waitForFonts(kfd, ofd)) {
                        keymanweb.alignInputs();
                    }
                };
                /**
                 *  Add or replace the style sheet used to set the font for input elements and OSK
                 *
                 *  @param  {Object}  kfd   KFont font descriptor
                 *  @param  {Object}  ofd   OSK font descriptor (if any)
                 *  @return {string}
                 *
                 **/
                VisualKeyboard.prototype.addFontStyle = function (kfd, ofd) {
                    var keymanweb = com.keyman.singleton;
                    // Get name of font to be applied
                    var fn = keymanweb.baseFont;
                    if (typeof (kfd) != 'undefined' && typeof (kfd['family']) != 'undefined') {
                        fn = kfd['family'];
                    }
                    // Unquote font name in base font (if quoted)
                    fn = fn.replace(/\u0022/g, '');
                    // Set font family chain for mapped elements and remove any double quotes
                    var rx = new RegExp('\\s?' + fn + ',?'), ff = keymanweb.appliedFont.replace(/\u0022/g, '');
                    // Remove base font name from chain if present
                    ff = ff.replace(rx, '');
                    ff = ff.replace(/,$/, '');
                    // Then replace it at the head of the chain
                    if (ff == '') {
                        ff = fn;
                    }
                    else {
                        ff = fn + ',' + ff;
                    }
                    // Re-insert quotes around individual font names
                    ff = '"' + ff.replace(/\,\s?/g, '","') + '"';
                    // Add to the stylesheet, quoted, and with !important to override any explicit style
                    var s = '.keymanweb-font{\nfont-family:' + ff + ' !important;\n}\n';
                    // Set font family for OSK text
                    if (typeof (ofd) != 'undefined') {
                        s = s + '.kmw-key-text{\nfont-family:"' + ofd['family'].replace(/\u0022/g, '').replace(/,/g, '","') + '";\n}\n';
                    }
                    else if (typeof (kfd) != 'undefined') {
                        s = s + '.kmw-key-text{\nfont-family:"' + kfd['family'].replace(/\u0022/g, '').replace(/,/g, '","') + '";\n}\n';
                    }
                    // Store the current font chain (with quote-delimited font names)
                    keymanweb.appliedFont = ff;
                    // Return the style string
                    return s;
                };
                /**
                 * Create copy of the OSK that can be used for embedding in documentation or help
                 * The currently active keyboard will be returned if PInternalName is null
                 *
                 *  @param  {string}          PInternalName   internal name of keyboard, with or without Keyboard_ prefix
                 *  @param  {number}          Pstatic         static keyboard flag  (unselectable elements)
                 *  @param  {string=}         argFormFactor   layout form factor, defaulting to 'desktop'
                 *  @param  {(string|number)=}  argLayerId    name or index of layer to show, defaulting to 'default'
                 *  @return {Object}                          DIV object with filled keyboard layer content
                 */
                VisualKeyboard.buildDocumentationKeyboard = function (PInternalName, Pstatic, argFormFactor, argLayerId) {
                    var keymanweb = com.keyman.singleton;
                    var PKbd = keymanweb.keyboardManager.activeKeyboard, Ln, formFactor = (typeof (argFormFactor) == 'undefined' ? 'desktop' : argFormFactor), layerId = (typeof (argLayerId) == 'undefined' ? 'default' : argLayerId), device = new keyman_12.Device();
                    // Device emulation for target documentation.
                    device.formFactor = formFactor;
                    if (formFactor != 'desktop') {
                        device.OS = 'iOS';
                    }
                    var keyboardsList = keymanweb.keyboardManager.keyboards;
                    if (PInternalName != null) {
                        var p = PInternalName.toLowerCase().replace('keyboard_', '');
                        for (Ln = 0; Ln < keyboardsList.length; Ln++) {
                            if (p == keyboardsList[Ln]['KI'].toLowerCase().replace('keyboard_', '')) {
                                PKbd = keyboardsList[Ln];
                                break;
                            }
                        }
                    }
                    if (!PKbd) {
                        return null;
                    }
                    var layouts = PKbd['KVKL'], layout = null, PVK = PKbd['KV'];
                    // Get the layout defined in the keyboard, or its nearest equivalent
                    if (typeof layouts == 'object') {
                        if (typeof (layouts[formFactor]) == 'object' && layouts[formFactor] != null) {
                            layout = layouts[formFactor];
                        }
                        else if (formFactor == 'phone' && typeof (layouts['tablet']) == 'object' && layouts['tablet'] != null) {
                            layout = layouts['tablet'];
                        }
                        else if (formFactor == 'tablet' && typeof (layouts['phone']) == 'object' && layouts['phone'] != null) {
                            layout = layouts['phone'];
                        }
                        else if (typeof (layouts['desktop']) == 'object' && layouts['desktop'] != null) {
                            layout = layouts['desktop'];
                        }
                    }
                    // Else get a default layout for the device for this keyboard
                    if (layout == null && PVK != null) {
                        var kbdDevVersion = new keyman_12.utils.Version(PKbd['KVER']);
                        layout = osk_3.Layouts.buildDefaultLayout(PVK, kbdDevVersion, keymanweb.keyboardManager.getKeyboardModifierBitmask(PKbd), formFactor);
                    }
                    // Cannot create an OSK if no layout defined, just return empty DIV
                    if (layout != null) {
                        if (typeof layout['displayUnderlying'] != 'undefined') {
                            layout.keyLabels = layout['displayUnderlying'] == true; // force bool
                        }
                        else {
                            layout.keyLabels = typeof (PKbd['KDU']) != 'undefined' && PKbd['KDU'];
                        }
                    }
                    var kbdObj = new VisualKeyboard(PVK, null, layout, keymanweb.keyboardManager.getKeyboardModifierBitmask(), device, true);
                    var kbd = kbdObj.kbdDiv.childNodes[0]; // Gets the layer group.
                    // Select the layer to display, and adjust sizes
                    if (layout != null) {
                        kbdObj.layerId = layerId;
                        kbdObj.show();
                        kbdObj.adjustHeights(); // Necessary for the row heights to be properly set!
                        // Relocates the font size definition from the main VisualKeyboard wrapper, since we don't return the whole thing.
                        kbd.style.fontSize = kbdObj.kbdDiv.style.fontSize;
                    }
                    else {
                        kbd.innerHTML = "<p style='color:#c40; font-size:0.5em;margin:10px;'>No " + formFactor + " layout is defined for " + PKbd['KN'] + ".</p>";
                    }
                    // Add a faint border
                    kbd.style.border = '1px solid #ccc';
                    return kbd;
                };
                VisualKeyboard.prototype.onHide = function () {
                    // Remove highlighting from hide keyboard key, if applied
                    if (this.hkKey) {
                        this.highlightKey(this.hkKey, false);
                    }
                };
                /**
               * Touch hold key display management
               *
               * @param   {Object}  key   base key object
               */
                VisualKeyboard.prototype.touchHold = function (key) {
                    // Clear and restart the popup timer
                    if (this.subkeyDelayTimer) {
                        window.clearTimeout(this.subkeyDelayTimer);
                        this.subkeyDelayTimer = null;
                    }
                    if (typeof key['subKeys'] != 'undefined' && key['subKeys'] != null) {
                        this.subkeyDelayTimer = window.setTimeout(function () {
                            this.clearPopup();
                            this.showSubKeys(key);
                        }.bind(this), this.popupDelay);
                    }
                };
                ;
                VisualKeyboard.prototype.optionKey = function (e, keyName, keyDown) {
                    var keyman = com.keyman.singleton;
                    var oskManager = keyman.osk;
                    if (keyDown) {
                        if (keyName.indexOf('K_LOPT') >= 0) {
                            oskManager.showLanguageMenu();
                        }
                        else if (keyName.indexOf('K_ROPT') >= 0) {
                            keyman.uiManager.setActivatingUI(false);
                            oskManager._Hide(true);
                            var active = keyman.domManager.getActiveElement();
                            if (keyman_12.dom.Utils.instanceof(active, "TouchAliasElement")) {
                                active.hideCaret();
                            }
                            keyman.domManager.clearLastActiveElement();
                        }
                    }
                };
                ;
                // Manage popup key highlighting
                VisualKeyboard.prototype.highlightSubKeys = function (k, x, y) {
                    var util = com.keyman.singleton.util;
                    // Test for subkey array, return if none
                    // (JH 2/4/19) So, if a subkey is passed in, we return immediately?
                    if (k == null || k['subKeys'] == null) {
                        return;
                    }
                    // Highlight key at touch position (and clear other highlighting)
                    var i, sk, x0, y0, x1, y1, onKey, skBox = document.getElementById('kmw-popup-keys');
                    //#region This section fills a different role than the method name would suggest.
                    // Might correspond better to a 'checkInstantSubkeys' or something.
                    // Show popup keys immediately if touch moved up towards key array (KMEW-100, Build 353)
                    if ((this.touchY - y > 5) && skBox == null) {
                        if (this.subkeyDelayTimer) {
                            window.clearTimeout(this.subkeyDelayTimer);
                        }
                        this.showSubKeys(k);
                        skBox = document.getElementById('kmw-popup-keys');
                    }
                    //#endregion
                    /* (JH 2/4/19) Because of that earlier note, in KMW 12 alpha (and probably 11),
                     * the following code is effectively impotent and could be deleted with no effect.
                     * Note that this probably results from VisualKeyboard.keyTarget finding the
                     * subkey first... which is necessary anyway to support subkey output.
                     */
                    for (i = 0; i < k['subKeys'].length; i++) {
                        try {
                            sk = skBox.childNodes[i].firstChild;
                            x0 = keyman_12.dom.Utils.getAbsoluteX(sk);
                            y0 = keyman_12.dom.Utils.getAbsoluteY(sk); //-document.body.scrollTop;
                            x1 = x0 + sk.offsetWidth;
                            y1 = y0 + sk.offsetHeight;
                            onKey = (x > x0 && x < x1 && y > y0 && y < y1);
                            this.highlightKey(sk, onKey);
                            if (onKey) {
                                this.highlightKey(k, false);
                            }
                        }
                        catch (ex) { }
                    }
                };
                ;
                /**
                 * Add (or remove) the keytip preview (if KeymanWeb on a phone device)
                 *
                 * @param   {Object}  key   HTML key element
                 * @param   {boolean} on    show or hide
                 */
                VisualKeyboard.prototype.showKeyTip = function (key, on) {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    var oskManager = keyman.osk;
                    var tip = this.keytip;
                    // Do not change the key preview unless key or state has changed
                    if (tip == null || (key == tip.key && on == tip.state)) {
                        return;
                    }
                    var sk = document.getElementById('kmw-popup-keys'), popup = (sk && sk.style.visibility == 'visible');
                    // Create and display the preview
                    if (on && !popup) {
                        var y0 = keyman_12.dom.Utils.getAbsoluteY(oskManager._Box), h0 = oskManager._Box.offsetHeight, xLeft = keyman_12.dom.Utils.getAbsoluteX(key), xTop = keyman_12.dom.Utils.getAbsoluteY(key), xWidth = key.offsetWidth, xHeight = key.offsetHeight, kc = key.firstChild, kcs = kc.style, kts = tip.element.style, ktLabel = tip.element.childNodes[1], ktls = ktLabel.style, edge = 0, canvas = tip.element.firstChild, previewFontScale = 1.8;
                        // Find key text element
                        for (var i = 0; i < key.childNodes.length; i++) {
                            kc = key.childNodes[i];
                            if (util.hasClass(kc, 'kmw-key-text')) {
                                break;
                            }
                        }
                        // Canvas dimensions must be set explicitly to prevent clipping
                        canvas.width = 1.6 * xWidth;
                        canvas.height = 2.3 * xHeight;
                        kts.top = 'auto';
                        kts.bottom = (y0 + h0 - xTop - xHeight) + 'px';
                        kts.textAlign = 'center';
                        kts.overflow = 'visible';
                        kts.fontFamily = util.getStyleValue(kc, 'font-family');
                        kts.width = canvas.width + 'px';
                        kts.height = canvas.height + 'px';
                        var px = util.getStyleInt(kc, 'font-size');
                        if (px != 0) {
                            var popupFS = previewFontScale * px;
                            kts.fontSize = popupFS + 'px';
                            var textWidth = com.keyman.osk.OSKKey.getTextWidth(this, ktLabel.textContent, kts);
                            // We use a factor of 0.9 to serve as a buffer in case of mild measurement error.
                            var proportion = canvas.width * 0.9 / (textWidth);
                            // Prevent the preview from overrunning its display area.
                            if (proportion < 1) {
                                kts.fontSize = (popupFS * proportion) + 'px';
                            }
                        }
                        ktLabel.textContent = kc.textContent;
                        ktls.display = 'block';
                        ktls.position = 'absolute';
                        ktls.textAlign = 'center';
                        ktls.width = '100%';
                        ktls.top = '2%';
                        ktls.bottom = 'auto';
                        // Adjust canvas shape if at edges
                        var xOverflow = (canvas.width - xWidth) / 2;
                        if (xLeft < xOverflow) {
                            edge = -1;
                            xLeft += xOverflow;
                        }
                        else if (xLeft > window.innerWidth - xWidth - xOverflow) {
                            edge = 1;
                            xLeft -= xOverflow;
                        }
                        // For now, should only be true (in production) when keyman.isEmbedded == true.
                        var constrainPopup = keyman.isEmbedded;
                        var cs = getComputedStyle(tip.element);
                        var oskHeight = keyman.osk.getHeight();
                        var bottomY = parseInt(cs.bottom, 10);
                        var tipHeight = parseInt(cs.height, 10);
                        var delta = 0;
                        if (tipHeight + bottomY > oskHeight && constrainPopup) {
                            delta = tipHeight + bottomY - oskHeight;
                            canvas.height = canvas.height - delta;
                            kts.height = canvas.height + 'px';
                        }
                        this.drawPreview(canvas, xWidth, xHeight, edge, delta);
                        kts.left = (xLeft - xOverflow) + 'px';
                        kts.display = 'block';
                    }
                    else { // Hide the key preview
                        tip.element.style.display = 'none';
                    }
                    // Save the key preview state
                    tip.key = key;
                    tip.state = on;
                };
                ;
                /**
                 * Draw key preview in element using CANVAS
                 *  @param  {Object}  canvas CANVAS element
                 *  @param  {number}  w width of touched key, px
                 *  @param  {number}  h height of touched key, px
                 *  @param  {number}  edge  -1 left edge, 1 right edge, else 0
                 */
                VisualKeyboard.prototype.drawPreview = function (canvas, w, h, edge, delta) {
                    var util = com.keyman.singleton.util;
                    var device = util.device;
                    delta = delta || 0;
                    var ctx = canvas.getContext('2d'), dx = (canvas.width - w) / 2, hMax = canvas.height + delta, w0 = 0, w1 = dx, w2 = w + dx, w3 = w + 2 * dx, h1 = 0.5 * hMax, h2 = 0.6 * hMax, h3 = hMax, r = 8;
                    var hBoundedMax = canvas.height;
                    h2 = h2 > hBoundedMax ? hBoundedMax : h2;
                    h3 = hMax > hBoundedMax ? hBoundedMax : h3;
                    if (device.OS == 'Android') {
                        r = 3;
                    }
                    // Adjust the preview shape at the edge of the keyboard
                    switch (edge) {
                        case -1:
                            w1 -= dx;
                            w2 -= dx;
                            break;
                        case 1:
                            w1 += dx;
                            w2 += dx;
                            break;
                    }
                    // Clear the canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    // Define appearance of preview (cannot be done directly in CSS)
                    if (device.OS == 'Android') {
                        var wx = (w1 + w2) / 2;
                        w1 = w2 = wx;
                    }
                    ctx.fillStyle = device.styles.popupCanvasBackgroundColor;
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#cccccc';
                    // Draw outline
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(w0 + r, 0);
                    ctx.arcTo(w3, 0, w3, r, r);
                    if (device.OS == 'Android') {
                        ctx.arcTo(w3, h1, w2, h2, r);
                        ctx.arcTo(w2, h2, w1, h2, r);
                    }
                    else {
                        var lowerR = 0;
                        if (h3 > h2) {
                            lowerR = h3 - h2 > r ? r : h3 - h2;
                        }
                        ctx.arcTo(w3, h1, w2, h2, r);
                        ctx.arcTo(w2, h2, w2 - lowerR, h3, lowerR);
                        ctx.arcTo(w2, h3, w1, h3, lowerR);
                        ctx.arcTo(w1, h3, w1, h2 - lowerR, lowerR);
                    }
                    ctx.arcTo(w1, h2, w0, h1 - r, r);
                    ctx.arcTo(w0, h1, w0, r, r);
                    ctx.arcTo(w0, 0, w0 + r, 0, r);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                };
                ;
                /**
                 *  Create a key preview element for phone devices
                 */
                VisualKeyboard.prototype.createKeyTip = function () {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    if (keyman.util.device.formFactor == 'phone') {
                        if (this.keytip == null) {
                            this.keytip = {
                                key: null,
                                state: false
                            };
                            var tipElement = this.keytip.element = util._CreateElement('div');
                            tipElement.className = 'kmw-keytip';
                            tipElement.id = 'kmw-keytip';
                            // The following style is critical, so do not rely on external CSS
                            tipElement.style.pointerEvents = 'none';
                            // Add CANVAS element for outline and SPAN for key label
                            tipElement.appendChild(util._CreateElement('canvas'));
                            tipElement.appendChild(util._CreateElement('span'));
                        }
                        // Always append to _Box (since cleared during OSK Load) 
                        keyman.osk._Box.appendChild(this.keytip.element);
                    }
                };
                ;
                /**
                 * Add a callout for popup keys (if KeymanWeb on a phone device)
                 *
                 * @param   {Object}  key   HTML key element
                 * @return  {Object}        callout object
                 */
                VisualKeyboard.prototype.addCallout = function (key, delta) {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    if (util.device.formFactor != 'phone' || util.device.OS != 'iOS') {
                        return null;
                    }
                    delta = delta || 0;
                    var calloutHeight = key.offsetHeight - delta;
                    if (calloutHeight > 0) {
                        var cc = util._CreateElement('div'), ccs = cc.style;
                        cc.id = 'kmw-popup-callout';
                        keyman.osk._Box.appendChild(cc);
                        // Create the callout
                        var xLeft = key.offsetLeft, xTop = key.offsetTop + delta, xWidth = key.offsetWidth, xHeight = calloutHeight;
                        // Set position and style 
                        ccs.top = (xTop - 6) + 'px';
                        ccs.left = xLeft + 'px';
                        ccs.width = xWidth + 'px';
                        ccs.height = (xHeight + 6) + 'px';
                        // Return callout element, to allow removal later
                        return cc;
                    }
                    else {
                        return null;
                    }
                };
                /**
                 * Wait until font is loaded before applying stylesheet - test each 100 ms
                 * @param   {Object}  kfd   main font descriptor
                 * @param   {Object}  ofd   secondary font descriptor (OSK only)
                 * @return  {boolean}
                 */
                VisualKeyboard.prototype.waitForFonts = function (kfd, ofd) {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    if (typeof (kfd) == 'undefined' && typeof (ofd) == 'undefined') {
                        return true;
                    }
                    if (typeof (kfd['files']) == 'undefined' && typeof (ofd['files']) == 'undefined') {
                        return true;
                    }
                    var kReady = util.checkFontDescriptor(kfd), oReady = util.checkFontDescriptor(ofd);
                    if (kReady && oReady) {
                        return true;
                    }
                    keymanweb.fontCheckTimer = window.setInterval(function () {
                        if (util.checkFontDescriptor(kfd) && util.checkFontDescriptor(ofd)) {
                            window.clearInterval(keymanweb.fontCheckTimer);
                            keymanweb.fontCheckTimer = null;
                            keymanweb.alignInputs();
                        }
                    }, 100);
                    // Align anyway as best as can if font appears to remain uninstalled after 5 seconds   
                    window.setTimeout(function () {
                        if (keymanweb.fontCheckTimer) {
                            window.clearInterval(keymanweb.fontCheckTimer);
                            keymanweb.fontCheckTimer = null;
                            keymanweb.alignInputs();
                            // Don't notify - this is a management issue, not anything the user needs to deal with
                            // TODO: Consider having an icon in the OSK with a bubble that indicates missing font
                            //util.alert('Unable to download the font normally used with '+ks['KN']+'.');
                        }
                    }, 5000);
                    return false;
                };
                ;
                // Defines the PUA code mapping for the various 'special' modifier/control keys on keyboards.
                VisualKeyboard.specialCharacters = {
                    '*Shift*': 8,
                    '*Enter*': 5,
                    '*Tab*': 6,
                    '*BkSp*': 4,
                    '*Menu*': 11,
                    '*Hide*': 10,
                    '*Alt*': 25,
                    '*Ctrl*': 1,
                    '*Caps*': 3,
                    '*ABC*': 16,
                    '*abc*': 17,
                    '*123*': 19,
                    '*Symbol*': 21,
                    '*Currency*': 20,
                    '*Shifted*': 8,
                    '*AltGr*': 2,
                    '*TabLeft*': 7,
                    '*LAlt*': 0x56,
                    '*RAlt*': 0x57,
                    '*LCtrl*': 0x58,
                    '*RCtrl*': 0x59,
                    '*LAltCtrl*': 0x60,
                    '*RAltCtrl*': 0x61,
                    '*LAltCtrlShift*': 0x62,
                    '*RAltCtrlShift*': 0x63,
                    '*AltShift*': 0x64,
                    '*CtrlShift*': 0x65,
                    '*AltCtrlShift*': 0x66,
                    '*LAltShift*': 0x67,
                    '*RAltShift*': 0x68,
                    '*LCtrlShift*': 0x69,
                    '*RCtrlShift*': 0x70
                };
                return VisualKeyboard;
            }());
            osk_3.VisualKeyboard = VisualKeyboard;
        })(osk = keyman_12.osk || (keyman_12.osk = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman_13) {
        var dom;
        (function (dom) {
            /**
             * This class was added to facilitate scroll handling for overflow-x elements, though it could
             * be extended in the future to accept overflow-y if needed.
             *
             * This is necessary because of the OSK's need to use `.preventDefault()` for stability; that
             * same method blocks native handling of overflow scrolling for touch browsers.
             */
            var ScrollState = /** @class */ (function () {
                function ScrollState(touch) {
                    this.totalLength = 0;
                    this.x = touch.pageX;
                    this.totalLength = 0;
                }
                ScrollState.prototype.updateTo = function (touch) {
                    var x = this.x;
                    this.x = touch.pageX;
                    var deltas = { deltaX: this.x - x };
                    this.totalLength += Math.abs(deltas.deltaX);
                    return deltas;
                };
                Object.defineProperty(ScrollState.prototype, "hasScrolled", {
                    get: function () {
                        // Allow an accidental fudge-factor for overflow element noise during a touch, but not much.
                        return this.totalLength > ScrollState.HAS_SCROLLED_FUDGE_FACTOR;
                    },
                    enumerable: true,
                    configurable: true
                });
                // The amount of coordinate 'noise' allowed during a scroll-enabled touch allowed
                // before interpreting the currently-ongoing touch command as having scrolled.
                ScrollState.HAS_SCROLLED_FUDGE_FACTOR = 10;
                return ScrollState;
            }());
            var UITouchHandlerBase = /** @class */ (function () {
                function UITouchHandlerBase(baseElement, rowClassMatch, selectedTargetMatch) {
                    this.baseElement = baseElement;
                    this.rowClassMatch = rowClassMatch;
                    this.selectedTargetMatch = selectedTargetMatch;
                }
                /**
                 * Identify the key nearest to (but NOT under) the touch point if at the end of a key row,
                 * but return null more than about 0.6 key width from the nearest key.
                 *
                 *  @param  {Event}   e   touch event
                 *  @param  {Object}  t   HTML object at touch point
                 *  @param  {boolean} omitCurrent  Omits any target directly under the touch point.
                 *  @return {Object}      nearest key to touch point
                 *
                 **/
                UITouchHandlerBase.prototype.findTargetFromTouch = function (e, t, forMove) {
                    var touchList = forMove ? e.touches : e.changedTouches;
                    if ((!e) || (typeof touchList == 'undefined')
                        || (touchList.length == 0)) {
                        return null;
                    }
                    // Get touch point on screen
                    var x = touchList[0].pageX;
                    // Get the UI row beneath touch point (SuggestionBanner div, 'kmw-key-row' if OSK, ...)
                    while (t && t.className !== undefined && t.className.indexOf(this.rowClassMatch) < 0) {
                        t = t.parentNode;
                    }
                    if (!t) {
                        return null;
                    }
                    // Find minimum distance from any key
                    var k, bestMatch = 0, dxMax = 24, dxMin = 100000, x1, x2;
                    for (k = 0; k < t.childNodes.length; k++) {
                        var childNode = t.childNodes[k];
                        if (this.isInvalidTarget(this.findTargetFrom(childNode))) {
                            continue;
                        }
                        x1 = childNode.offsetLeft;
                        x2 = x1 + childNode.offsetWidth;
                        // If it lies completely to the right and is the closest so far
                        var dxRight = x1 - x;
                        if (dxRight >= 0 && dxRight < dxMin) {
                            bestMatch = k;
                            dxMin = dxRight;
                        }
                        // If it lies completely to the left and is the closest so far
                        var dxLeft = x - x2;
                        if (dxLeft >= 0 && dxLeft < dxMin) {
                            bestMatch = k;
                            dxMin = dxLeft;
                        }
                        // If it is neither completely to the left nor completely to the right,
                        // it's under the cursor.  Stop the search!
                        if (dxLeft < 0 && dxRight < 0) {
                            return this.findTargetFrom(childNode);
                        }
                    }
                    if (dxMin < 100000) {
                        t = t.childNodes[bestMatch];
                        x1 = t.offsetLeft;
                        x2 = x1 + t.offsetWidth;
                        // Limit extended touch area to the larger of 0.6 of the potential target's width and 24 px
                        if (t.offsetWidth > 40) {
                            dxMax = 0.6 * t.offsetWidth;
                        }
                        if (((x1 - x) >= 0 && (x1 - x) < dxMax) || ((x - x2) >= 0 && (x - x2) < dxMax)) {
                            return this.findTargetFrom(t);
                        }
                    }
                    return null;
                };
                UITouchHandlerBase.prototype.findBestTarget = function (e, forMove) {
                    var eventTarget;
                    if (forMove) {
                        eventTarget = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
                    }
                    else {
                        eventTarget = e.changedTouches[0].target;
                    }
                    var target = this.findTargetFrom(eventTarget);
                    // Should refactor this multi-check a bit for more overall reliability.
                    if (!target) {
                        // We didn't find a direct target, so we should look for the closest possible one.
                        // Filters out invalid targets.
                        target = this.findTargetFromTouch(e, eventTarget, forMove);
                    }
                    return target;
                };
                /**
                 * Reports whether or not a `Target` should be considered invalid.  Needed by the OSK for
                 * hidden keys.
                 * @param target A `Target` element to be validated.
                 */
                UITouchHandlerBase.prototype.isInvalidTarget = function (target) {
                    return false;
                };
                UITouchHandlerBase.prototype.touchStart = function (e) {
                    // Determine the selected Target, manage state.
                    //this.currentTarget = this.findTargetFrom(e.changedTouches[0].target as HTMLElement);
                    this.currentTarget = this.findBestTarget(e);
                    this.touchX = e.changedTouches[0].pageX;
                    this.touchY = e.changedTouches[0].pageY;
                    // If popup stuff, immediately return. 
                    this.touchCount = e.touches.length;
                    if (!this.currentTarget) {
                        return;
                    }
                    // Establish scroll tracking.
                    var shouldScroll = (this.currentTarget.clientWidth < this.currentTarget.scrollWidth);
                    this.scrollTouchState = shouldScroll ? new ScrollState(e.changedTouches[0]) : null;
                    // Alright, Target acquired!  Now to use it:
                    // Highlight the touched key
                    this.highlight(this.currentTarget, true);
                    // If used by the OSK, the special function keys need immediate action
                    // Add a `checkForImmediates()` to facilitate this.
                    if (this.pendingTarget) {
                        this.highlight(this.pendingTarget, false);
                        this.select(this.pendingTarget);
                        this.clearHolds();
                        // Decrement the number of unreleased touch points to prevent
                        // sending the keystroke again when the key is actually released
                        this.touchCount--;
                    }
                    else {
                        // If this key has subkey, start timer to display subkeys after delay, set up release
                        this.hold(this.currentTarget);
                    }
                    this.pendingTarget = this.currentTarget;
                };
                UITouchHandlerBase.prototype.touchEnd = function (e) {
                    // Prevent incorrect multi-touch behaviour if native or device popup visible
                    var t = this.currentTarget;
                    if (this.isSubmenuActive() || this.hasModalPopup()) {
                        // Ignore release if a multiple touch
                        if (e.touches.length > 0) {
                            return;
                        }
                        // Cancel (but do not execute) pending key if neither a popup key or the base key
                        if ((t == null) || ((t.id.indexOf('popup') < 0) && (t.id != this.popupBaseTarget.id))) {
                            this.highlight(this.pendingTarget, false);
                            this.clearHolds();
                            this.pendingTarget = null;
                        }
                    }
                    // Test if moved off screen (effective release point must be corrected for touch point horizontal speed)
                    // This is not completely effective and needs some tweaking, especially on Android
                    var x = e.changedTouches[0].pageX;
                    var beyondEdge = ((x < 2 && this.touchX > 5) || (x > window.innerWidth - 2 && this.touchX < window.innerWidth - 5));
                    if (this.scrollTouchState) {
                        beyondEdge = beyondEdge || this.scrollTouchState.hasScrolled;
                    }
                    // Save then decrement current touch count
                    var tc = this.touchCount;
                    if (this.touchCount > 0) {
                        this.touchCount--;
                    }
                    // Process and clear highlighting of pending target
                    if (this.pendingTarget) {
                        this.highlight(this.pendingTarget, false);
                        // Output character unless moved off key
                        if (this.pendingTarget.className.indexOf('hidden') < 0 && tc > 0 && !beyondEdge) {
                            this.select(this.pendingTarget);
                        }
                        this.clearHolds();
                        this.pendingTarget = null;
                        // Always clear highlighting of current target on release (multi-touch)
                    }
                    else {
                        t = this.findBestTarget(e);
                        if (t) {
                            this.highlight(t, false);
                        }
                    }
                };
                /**
                 * OSK touch move event handler
                 *
                 *  @param  {Event} e   touch move event object
                 *
                 **/
                UITouchHandlerBase.prototype.touchMove = function (e) {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    e.preventDefault();
                    e.cancelBubble = true;
                    if (typeof e.stopImmediatePropagation == 'function') {
                        e.stopImmediatePropagation();
                    }
                    else if (typeof e.stopPropagation == 'function') {
                        e.stopPropagation();
                    }
                    // Do not attempt to support reselection of target key for overlapped keystrokes
                    if (e.touches.length > 1 || this.touchCount == 0) {
                        return;
                    }
                    if (this.currentTarget && this.scrollTouchState != null) {
                        var deltaX = this.scrollTouchState.updateTo(e.changedTouches[0]).deltaX;
                        this.currentTarget.scrollLeft -= window.devicePixelRatio * deltaX;
                        return;
                    }
                    // Get touch position
                    var y = typeof e.touches == 'object' ? e.touches[0].clientY : e.clientY;
                    // Move target key and highlighting
                    var key0 = this.pendingTarget, key1 = this.findBestTarget(e, true); // For the OSK, this ALSO gets subkeys.
                    // If option should not be selectable, how do we re-target?
                    // Do not move over keys if device popup visible
                    if (this.hasModalPopup()) {
                        if (key1 == null) {
                            if (key0) {
                                this.highlight(key0, false);
                            }
                            this.pendingTarget = null;
                        }
                        else {
                            if (key1 == this.popupBaseTarget) {
                                if (!util.hasClass(key1, this.selectedTargetMatch)) {
                                    this.highlight(key1, true);
                                }
                                this.pendingTarget = key1;
                            }
                            else {
                                if (key0) {
                                    this.highlight(key0, false);
                                }
                                this.pendingTarget = null;
                            }
                        }
                        return;
                    }
                    // Use the popup duplicate of the base key if a phone with a visible popup array
                    key1 = this.dealiasSubTarget(key1);
                    // Identify current touch position (to manage off-key release)
                    this.currentTarget = key1;
                    // Clear previous key highlighting
                    if (key0 && key1 && key1 !== key0) {
                        this.highlight(key0, false);
                    }
                    // Code below directly related to subkeys should only be triggered within 'native' mode.
                    // The embedded version instead passes info to the apps to produce their own subkeys in-app.
                    // If popup is visible, need to move over popup, not over main keyboard
                    if (key1 && this.hasSubmenu(key1)) {
                        //this.highlightSubKeys(key1,x,y);
                        // Native-mode: show popup keys immediately if touch moved up towards key array (KMEW-100, Build 353)
                        if (!keyman.isEmbedded && (this.touchY - y > 5) && !this.isSubmenuActive()) {
                            // Instantly show the submenu.
                            this.displaySubmenuFor(key1);
                        }
                        // Once a subkey array is displayed, do not allow changing the base key.
                        // Keep that array visible and accept no other options until the touch ends.
                        if (key1 && key1.id.indexOf('popup') < 0 && key1 != this.popupBaseTarget) { // TODO:  reliant on 'popup' in .id
                            return;
                        }
                        // Highlight the base key on devices that do not append it to the subkey array.
                        if (key1 && key1 == this.popupBaseTarget && key1.className.indexOf(this.selectedTargetMatch) < 0) {
                            this.highlight(key1, true);
                        }
                        // Cancel touch if moved up and off keyboard, unless popup keys visible
                    }
                    else {
                        var base = this.baseElement;
                        var top_1 = base.offsetParent.offsetTop + base.offsetTop;
                        var height = base.offsetHeight;
                        var yMin = Math.max(5, top_1 - 0.25 * height);
                        var yMax = (top_1 + height) + 0.25 * height;
                        if (key0 && (e.touches[0].pageY < yMin || e.touches[0].pageY > yMax)) {
                            this.highlight(key0, false);
                            this.clearHolds();
                            this.pendingTarget = null;
                        }
                    }
                    // Replace the target key, if any, by the new target key
                    // Do not replace a null target, as that indicates the key has already been released
                    if (key1 && this.pendingTarget) {
                        this.pendingTarget = key1;
                    }
                    if (this.pendingTarget) {
                        if (key1 && (key0 != key1 || key1.className.indexOf(this.selectedTargetMatch) < 0)) {
                            this.highlight(key1, true);
                        }
                    }
                    if (key0 && key1 && (key1 != key0) && (key1.id != '')) {
                        //  Display the touch-hold keys (after a pause)
                        this.hold(key1);
                    }
                };
                return UITouchHandlerBase;
            }());
            dom.UITouchHandlerBase = UITouchHandlerBase;
        })(dom = keyman_13.dom || (keyman_13.dom = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
///<reference path="visualKeyboard.ts" />
///<reference path="../dom/uiTouchHandlerBase.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_14) {
        var osk;
        (function (osk) {
            // Base class for a banner above the keyboard in the OSK
            var Banner = /** @class */ (function () {
                function Banner(height) {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    var d = util._CreateElement('div');
                    d.id = Banner.BANNER_ID;
                    d.className = Banner.BANNER_CLASS;
                    this.div = d;
                    this.height = height;
                    this.update();
                }
                Object.defineProperty(Banner.prototype, "height", {
                    /**
                     * Function     height
                     * Scope        Public
                     * @returns     {number} height in pixels
                     * Description  Returns the height of the banner in pixels
                     */
                    get: function () {
                        return this._height;
                    },
                    /**
                     * Function     height
                     * Scope        Public
                     * @param       {number} height   the height in pixels
                     * Description  Sets the height of the banner in pixels. If a negative
                     *              height is given, set height to 0 pixels.
                     *              Also updates the banner styling.
                     */
                    set: function (height) {
                        this._height = (height > 0) ? height : 0;
                        this.update();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Function      update
                 * @return       {boolean}   true if the banner styling changed
                 * Description   Update the height and display styling of the banner
                 */
                Banner.prototype.update = function () {
                    var ds = this.div.style;
                    var currentHeightStyle = ds.height;
                    var currentDisplayStyle = ds.display;
                    if (this._height > 0) {
                        ds.height = this._height + 'px';
                        ds.display = 'block';
                    }
                    else {
                        ds.height = '0px';
                        ds.display = 'none';
                    }
                    return (!(currentHeightStyle === ds.height) ||
                        !(currentDisplayStyle === ds.display));
                };
                Banner.prototype.appendStyleSheet = function () {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    // TODO: add stylesheets
                };
                /**
                 * Function     getDiv
                 * Scope        Public
                 * @returns     {HTMLElement} Base element of the banner
                 * Description  Returns the HTMLElelemnt of the banner
                 */
                Banner.prototype.getDiv = function () {
                    return this.div;
                };
                /**
                 * Function     activate
                 * Scope        Public
                 * Description  Adds any relevant event listeners needed by this banner type.
                 */
                Banner.prototype.activate = function () {
                    // Default implementation - no listeners.
                };
                /**
                 * Function     activate
                 * Scope        Public
                 * Description  Removes any relevant event listeners previously added by this banner.
                 */
                Banner.prototype.deactivate = function () {
                    // Default implementation - no listeners.
                };
                Banner.DEFAULT_HEIGHT = 37; // pixels; embedded apps can modify
                Banner.BANNER_CLASS = 'kmw-banner-bar';
                Banner.BANNER_ID = 'kmw-banner-bar';
                return Banner;
            }());
            osk.Banner = Banner;
            /**
             * Function       BlankBanner
             * Description    A banner of height 0 that should not be shown
             */
            var BlankBanner = /** @class */ (function (_super) {
                __extends(BlankBanner, _super);
                function BlankBanner() {
                    return _super.call(this, 0) || this;
                }
                return BlankBanner;
            }(Banner));
            osk.BlankBanner = BlankBanner;
            /**
             * Function       ImageBanner
             * @param         {string}        imagePath   Path of image to display in the banner
             * @param         {number}        height      If provided, the height of the banner in pixels
             * Description    Display an image in the banner
             */
            var ImageBanner = /** @class */ (function (_super) {
                __extends(ImageBanner, _super);
                function ImageBanner(imagePath, height) {
                    var _this_1 = this;
                    if (imagePath.length > 0) {
                        _this_1 = _super.call(this) || this;
                        if (height) {
                            _this_1.height = height;
                        }
                    }
                    else {
                        _this_1 = _super.call(this, 0) || this;
                    }
                    if (imagePath.indexOf('base64') >= 0) {
                        console.log("Loading img from base64 data");
                    }
                    else {
                        console.log("Loading img with src '" + imagePath + "'");
                    }
                    _this_1.img = document.createElement('img');
                    _this_1.img.setAttribute('src', imagePath);
                    var ds = _this_1.img.style;
                    ds.width = '100%';
                    ds.height = '100%';
                    _this_1.getDiv().appendChild(_this_1.img);
                    console.log("Image loaded.");
                    return _this_1;
                }
                /**
                 * Function     setImagePath
                 * Scope        Public
                 * @param       {string}     imagePath   Path of image to display in the banner
                 * Description  Update the image in the banner
                 */
                ImageBanner.prototype.setImagePath = function (imagePath) {
                    if (this.img) {
                        this.img.setAttribute('src', imagePath);
                    }
                };
                return ImageBanner;
            }(Banner));
            osk.ImageBanner = ImageBanner;
            var BannerSuggestion = /** @class */ (function () {
                function BannerSuggestion(index) {
                    this._applyFunctor = null;
                    var keyman = com.keyman.singleton;
                    this.index = index;
                    this.constructRoot();
                    // Provides an empty, base SPAN for text display.  We'll swap these out regularly;
                    // `Suggestion`s will have varying length and may need different styling.
                    var display = this.display = keyman.util._CreateElement('span');
                    this.div.appendChild(display);
                }
                BannerSuggestion.prototype.constructRoot = function () {
                    var keyman = com.keyman.singleton;
                    // Add OSK suggestion labels
                    var div = this.div = keyman.util._CreateElement('div'), ds = div.style;
                    div.className = "kmw-suggest-option";
                    div.id = BannerSuggestion.BASE_ID + this.index;
                    var kbdDetails = keyman.keyboardManager.activeStub;
                    if (kbdDetails) {
                        if (kbdDetails['KLC']) {
                            div.lang = kbdDetails['KLC'];
                        }
                        // Establish base font settings
                        var font = kbdDetails['KFont'];
                        if (font && font.family && font.family != '') {
                            ds.fontFamily = this.fontFamily = font.family;
                        }
                    }
                    // Ensures that a reasonable width % is set.
                    var usableWidth = 100 - SuggestionBanner.MARGIN * (SuggestionBanner.SUGGESTION_LIMIT - 1);
                    var widthpc = usableWidth / SuggestionBanner.SUGGESTION_LIMIT;
                    ds.width = widthpc + '%';
                    this.div['suggestion'] = this;
                };
                Object.defineProperty(BannerSuggestion.prototype, "suggestion", {
                    get: function () {
                        return this._suggestion;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Function update
                 * @param {string}     id           Element ID for the suggestion span
                 * @param {Suggestion} suggestion   Suggestion from the lexical model
                 * Description  Update the ID and text of the BannerSuggestionSpec
                 */
                BannerSuggestion.prototype.update = function (suggestion, applyFunctor) {
                    this._suggestion = suggestion;
                    this._applyFunctor = applyFunctor || null;
                    this.updateText();
                };
                BannerSuggestion.prototype.updateText = function () {
                    var display = this.generateSuggestionText();
                    this.div.replaceChild(display, this.display);
                    this.display = display;
                };
                /**
                 * Function apply
                 * @param target (Optional) The OutputTarget to which the `Suggestion` ought be applied.
                 * Description  Applies the predictive `Suggestion` represented by this `BannerSuggestion`.
                 */
                BannerSuggestion.prototype.apply = function (target) {
                    var keyman = com.keyman.singleton;
                    if (this.isEmpty()) {
                        return [null, null];
                    }
                    else if (this._applyFunctor) {
                        this._applyFunctor();
                        return [null, null];
                    }
                    // Find the state of the context at the time the prediction-triggering keystroke was applied.
                    var original = keyman.modelManager.getPredictionState(this._suggestion.transformId);
                    if (!original) {
                        console.warn("Could not apply the Suggestion!");
                        return [null, null];
                    }
                    else {
                        if (!target) {
                            /* Assume it's the currently-active `OutputTarget`.  We should probably invalidate
                             * everything if/when the active `OutputTarget` changes, though we haven't gotten that
                             * far in implementation yet.
                             */
                            target = keyman_14.text.Processor.getOutputTarget();
                        }
                        // Apply the Suggestion!
                        // Step 1:  determine the final output text
                        var final = keyman_14.text.Mock.from(original.preInput);
                        final.apply(this._suggestion.transform);
                        // Step 2:  build a final, master Transform that will produce the desired results from the CURRENT state.
                        // In embedded mode, both Android and iOS are best served by calculating this transform and applying its
                        // values as needed for use with their IME interfaces.
                        var transform = final.buildTransformFrom(target);
                        var wordbreakPromise = keyman.modelManager.wordbreak(target); // Also build the display string for the reversion.
                        target.apply(transform);
                        // Signal the necessary text changes to the embedding app, if it exists.
                        if (keyman['oninserttext'] && keyman.isEmbedded) {
                            keyman['oninserttext'](transform.deleteLeft, transform.insert, transform.deleteRight);
                        }
                        // Build a 'reversion' Transcription that can be used to undo this apply() if needed.
                        var preApply = keyman_14.text.Mock.from(original.preInput);
                        preApply.apply(original.transform);
                        return [preApply.buildTranscriptionFrom(target, null), wordbreakPromise];
                    }
                };
                BannerSuggestion.prototype.isEmpty = function () {
                    return !this._suggestion;
                };
                /**
                 * Function generateSuggestionText
                 * @return {HTMLSpanElement}  Span element of the suggestion
                 * Description   Produces a HTMLSpanElement with the key's actual text.
                 */
                //
                BannerSuggestion.prototype.generateSuggestionText = function () {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    var suggestion = this._suggestion;
                    var suggestionText;
                    var s = util._CreateElement('span');
                    s.className = 'kmw-suggestion-text';
                    if (suggestion == null) {
                        return s;
                    }
                    if (suggestion.displayAs == null || suggestion.displayAs == '') {
                        suggestionText = '\xa0'; // default:  nbsp.
                    }
                    else {
                        // Default the LTR ordering to match that of the active keyboard.
                        var rtl = keyman.keyboardManager.isRTL();
                        var orderCode = rtl ? 0x202e /* RTL */ : 0x202d /* LTR */;
                        suggestionText = String.fromCharCode(orderCode) + suggestion.displayAs;
                    }
                    // TODO:  Dynamic suggestion text resizing.  (Refer to OSKKey.getTextWidth in visualKeyboard.ts.)
                    // Finalize the suggestion text
                    s.innerHTML = suggestionText;
                    return s;
                };
                BannerSuggestion.BASE_ID = 'kmw-suggestion-';
                return BannerSuggestion;
            }());
            osk.BannerSuggestion = BannerSuggestion;
            /**
             * Function     SuggestionBanner
             * Scope        Public
             * @param {number} height - If provided, the height of the banner in pixels
             * Description  Display lexical model suggestions in the banner
             */
            var SuggestionBanner = /** @class */ (function (_super) {
                __extends(SuggestionBanner, _super);
                function SuggestionBanner(height) {
                    var _this_1 = _super.call(this, height || Banner.DEFAULT_HEIGHT) || this;
                    _this_1.getDiv().className = _this_1.getDiv().className + ' ' + SuggestionBanner.BANNER_CLASS;
                    _this_1.options = new Array();
                    for (var i = 0; i < SuggestionBanner.SUGGESTION_LIMIT; i++) {
                        var d = new BannerSuggestion(i);
                        _this_1.options[i] = d;
                    }
                    /* LTR behavior:  the default (index 0) suggestion should be at the left
                     * RTL behavior:  the default (index 0) suggestion should be at the right
                     *
                     * The cleanest way to make it work - simply invert the order in which
                     * the elements are inserted for RTL.  This allows the banner to be RTL
                     * for visuals/UI while still being internally LTR.
                     */
                    var rtl = com.keyman.singleton.keyboardManager.isRTL();
                    for (var i = 0; i < SuggestionBanner.SUGGESTION_LIMIT; i++) {
                        var indexToInsert = rtl ? SuggestionBanner.SUGGESTION_LIMIT - i - 1 : i;
                        _this_1.getDiv().appendChild(_this_1.options[indexToInsert].div);
                        if (i != SuggestionBanner.SUGGESTION_LIMIT) {
                            // Adds a 'separator' div element for UI purposes.
                            var separatorDiv = com.keyman.singleton.util._CreateElement('div');
                            separatorDiv.className = 'kmw-banner-separator';
                            var ds = separatorDiv.style;
                            ds.marginLeft = (SuggestionBanner.MARGIN / 2) + '%';
                            ds.marginRight = (SuggestionBanner.MARGIN / 2) + '%';
                            _this_1.getDiv().appendChild(separatorDiv);
                        }
                    }
                    _this_1.manager = new SuggestionManager(_this_1.getDiv(), _this_1.options);
                    _this_1.setupTouchHandling();
                    return _this_1;
                }
                SuggestionBanner.prototype.setupTouchHandling = function () {
                    var keyman = com.keyman.singleton;
                    var div = this.getDiv();
                    var th = this.manager;
                    if (keyman.util.device.touchable) { //  /*&& ('ontouchstart' in window)*/ // Except Chrome emulation doesn't set this.
                        // Not to mention, it's rather redundant.
                        div.addEventListener('touchstart', function (e) {
                            th.touchStart(e);
                        }, true);
                        // The listener below fails to capture when performing automated testing checks in Chrome emulation unless 'true'.
                        div.addEventListener('touchend', function (e) {
                            th.touchEnd(e);
                        }, true);
                        div.addEventListener('touchmove', function (e) {
                            th.touchMove(e);
                        }, false);
                        //lDiv.addEventListener('touchcancel', osk.cancel,false); //event never generated by iOS
                    }
                };
                SuggestionBanner.prototype.activate = function () {
                    var keyman = com.keyman.singleton;
                    var manager = this.manager;
                    keyman.modelManager['addEventListener']('invalidatesuggestions', manager.invalidateSuggestions);
                    keyman.modelManager['addEventListener']('suggestionsready', manager.updateSuggestions);
                    keyman.modelManager['addEventListener']('tryaccept', manager.tryAccept);
                    keyman.modelManager['addEventListener']('tryrevert', manager.tryRevert);
                    // Trigger a null-based initial prediction to kick things off.
                    keyman.modelManager.predict();
                };
                SuggestionBanner.prototype.deactivate = function () {
                    var keyman = com.keyman.singleton;
                    var manager = this.manager;
                    keyman.modelManager['removeEventListener']('invalidatesuggestions', manager.invalidateSuggestions);
                    keyman.modelManager['removeEventListener']('suggestionsready', manager.updateSuggestions);
                    keyman.modelManager['removeEventListener']('tryaccept', manager.tryAccept);
                    keyman.modelManager['removeEventListener']('tryrevert', manager.tryRevert);
                };
                SuggestionBanner.prototype.rotateSuggestions = function () {
                    this.manager.rotateSuggestions();
                };
                SuggestionBanner.SUGGESTION_LIMIT = 3;
                SuggestionBanner.MARGIN = 1;
                SuggestionBanner.TOUCHED_CLASS = 'kmw-suggest-touched';
                SuggestionBanner.BANNER_CLASS = 'kmw-suggest-banner';
                return SuggestionBanner;
            }(Banner));
            osk.SuggestionBanner = SuggestionBanner;
            var SuggestionManager = /** @class */ (function (_super) {
                __extends(SuggestionManager, _super);
                function SuggestionManager(div, options) {
                    var _this_1 = 
                    // TODO:  Determine appropriate CSS styling names, etc.
                    _super.call(this, div, Banner.BANNER_CLASS, SuggestionBanner.TOUCHED_CLASS) || this;
                    _this_1.initNewContext = true;
                    _this_1.currentSuggestions = [];
                    _this_1.recentAccept = false;
                    _this_1.preAccept = null;
                    _this_1.swallowPrediction = false;
                    _this_1.doRevert = false;
                    _this_1.recentRevert = false;
                    _this_1.rejectedSuggestions = [];
                    _this_1._applyReversion = function () {
                        var keyman = com.keyman.singleton;
                        var current = keyman_14.text.Processor.getOutputTarget();
                        var priorState = this.preAccept;
                        // Step 1:  construct the reverted state.
                        var target = keyman_14.text.Mock.from(priorState.preInput);
                        target.apply(priorState.transform);
                        // Step 2:  build a final, master Transform that will produce the desired results from the CURRENT state.
                        // In embedded mode, both Android and iOS are best served by calculating this transform and applying its
                        // values as needed for use with their IME interfaces.
                        var transform = target.buildTransformFrom(current);
                        current.apply(transform);
                        // Signal the necessary text changes to the embedding app, if it exists.
                        if (keyman['oninserttext'] && keyman.isEmbedded) {
                            keyman['oninserttext'](transform.deleteLeft, transform.insert, transform.deleteRight);
                        }
                        this.currentSuggestions = this.previousSuggestions; // Restore to the previous state's Suggestion list.
                        this.currentTranscriptionID = this.previousTranscriptionID;
                        var rejectIndex = this.currentSuggestions.indexOf(this.recentAccepted);
                        if (rejectIndex != -1) {
                            // Denote the previous suggestion as rejected and update the 'valid' suggestion list accordingly.
                            this.rejectedSuggestions.push(this.recentAccepted);
                            this.currentSuggestions.splice(rejectIndex, 1); // removes this.recentAccepted from this.currentSuggestions.
                        }
                        // Other state maintenance
                        this.recentAccept = false;
                        this.doRevert = false;
                        this.recentRevert = true;
                        this.doUpdate();
                    }.bind(_this_1);
                    /**
                     * Receives messages from the keyboard that the 'accept' keystroke has been entered.
                     * Should return 'false' if the current state allows accepting a suggestion and act accordingly.
                     * Otherwise, return true.
                     */
                    _this_1.tryAccept = function (source) {
                        if (!this.recentAccept && this.selected) {
                            this.doAccept(this.selected);
                            return false;
                        }
                        else if (this.recentAccept && source == 'space') {
                            this.recentAccept = false;
                            return false; // Swallows a single space post-accept.
                        }
                        return true; // Not yet implemented
                    }.bind(_this_1);
                    /**
                     * Receives messages from the keyboard that the 'revert' keystroke has been entered.
                     * Should return 'false' if the current state allows reverting a recently-applied suggestion and act accordingly.
                     * Otherwise, return true.
                     */
                    _this_1.tryRevert = function () {
                        // Has the revert keystroke (BKSP) already been sent once since the last accept?
                        if (this.doRevert) {
                            // If so, clear the 'revert' option and start doing normal predictions again.
                            this.doRevert = false;
                            this.recentAccept = false;
                            // Otherwise, did we just accept something before the revert signal was received?
                        }
                        else if (this.recentAccept) {
                            this.showRevert();
                            this.swallowPrediction = true;
                        }
                        return true;
                    }.bind(_this_1);
                    /**
                     * Function invalidateSuggestions
                     * Scope        Public
                     * Description  Clears the suggestions in the suggestion banner
                     */
                    _this_1.invalidateSuggestions = function (source) {
                        // By default, we assume that the context is the same until we notice otherwise.
                        this.initNewContext = false;
                        if (!this.swallowPrediction || source == 'context') {
                            this.recentAccept = false;
                            this.doRevert = false;
                            this.recentRevert = false;
                            this.rejectedSuggestions = [];
                            if (source == 'context') {
                                this.swallowPrediction = false;
                                this.initNewContext = true;
                            }
                        }
                        this.options.forEach(function (option) {
                            option.update(null);
                        });
                    }.bind(_this_1);
                    /**
                     * Function updateSuggestions
                     * Scope       Public
                     * @param {Suggestion[]}  suggestions   Array of suggestions from the lexical model.
                     * Description    Update the displayed suggestions in the SuggestionBanner
                     */
                    _this_1.updateSuggestions = function (prediction) {
                        var suggestions = prediction.suggestions;
                        this.currentSuggestions = suggestions;
                        this.currentTranscriptionID = prediction.transcriptionID;
                        // Do we have a keep suggestion?  If so, remove it from the list so that we can control its display position
                        // and prevent it from being hidden after reversion operations.
                        for (var _i = 0, suggestions_1 = suggestions; _i < suggestions_1.length; _i++) {
                            var s = suggestions_1[_i];
                            if (s.tag == 'keep') {
                                this.keepSuggestion = s;
                            }
                        }
                        if (this.keepSuggestion) {
                            this.currentSuggestions.splice(this.currentSuggestions.indexOf(this.keepSuggestion), 1);
                        }
                        // If we've gotten an update request like this, it's almost always user-triggered and means the context has shifted.
                        if (!this.swallowPrediction) {
                            this.recentAccept = false;
                            this.doRevert = false;
                            this.recentRevert = false;
                            this.rejectedSuggestions = [];
                        }
                        else { // This prediction was triggered by a recent 'accept.'  Now that it's fulfilled, we clear the flag.
                            this.swallowPrediction = false;
                        }
                        // The rest is the same, whether from input or from "self-updating" after a reversion to provide new suggestions.
                        this.doUpdate();
                    }.bind(_this_1);
                    _this_1.options = options;
                    return _this_1;
                }
                //#region Touch handling implementation
                SuggestionManager.prototype.findTargetFrom = function (e) {
                    var keyman = com.keyman.singleton;
                    var util = keyman.util;
                    try {
                        if (e) {
                            if (util.hasClass(e, 'kmw-suggest-option')) {
                                return e;
                            }
                            if (e.parentNode && util.hasClass(e.parentNode, 'kmw-suggest-option')) {
                                return e.parentNode;
                            }
                            // if(e.firstChild && util.hasClass(<HTMLElement> e.firstChild,'kmw-suggest-option')) {
                            //   return e.firstChild as HTMLDivElement;
                            // }
                        }
                    }
                    catch (ex) { }
                    return null;
                };
                SuggestionManager.prototype.highlight = function (t, on) {
                    var classes = t.className;
                    var cs = ' ' + SuggestionBanner.TOUCHED_CLASS;
                    if (t.id.indexOf(BannerSuggestion.BASE_ID) == -1) {
                        console.warn("Cannot find BannerSuggestion object for element to highlight!");
                    }
                    else {
                        // Never highlight an empty suggestion button.
                        var suggestion = this.selected = t['suggestion'];
                        if (suggestion.isEmpty()) {
                            on = false;
                            this.selected = null;
                        }
                    }
                    if (on && classes.indexOf(cs) < 0) {
                        t.className = classes + cs;
                    }
                    else {
                        t.className = classes.replace(cs, '');
                    }
                };
                SuggestionManager.prototype.select = function (t) {
                    this.doAccept(t['suggestion']);
                };
                //#region Long-press support
                SuggestionManager.prototype.hold = function (t) {
                    var suggestionObj = t['suggestion'];
                    // Is this the <keep> suggestion?  It's never in this.currentSuggestions, so check against that.
                    var isCustom = this.currentSuggestions.indexOf(suggestionObj.suggestion) == -1;
                    if (this.platformHold) {
                        // Implemented separately for native + embedded mode branches.
                        // Embedded mode should pass any info needed to show a submenu IMMEDIATELY.
                        this.platformHold(suggestionObj, isCustom); // No implementation yet for native.
                    }
                };
                SuggestionManager.prototype.clearHolds = function () {
                    // Temp, pending implementation of suggestion longpress submenus
                    // - nothing to clear without them -
                    // only really used in native-KMW
                };
                SuggestionManager.prototype.hasModalPopup = function () {
                    // Utilized by the mobile apps; allows them to 'take over' touch handling,
                    // blocking it within KMW when the apps are already managing an ongoing touch-hold.
                    var keyman = com.keyman.singleton;
                    return keyman['osk'].vkbd.popupVisible;
                };
                SuggestionManager.prototype.dealiasSubTarget = function (target) {
                    return target;
                };
                SuggestionManager.prototype.hasSubmenu = function (t) {
                    // Temp, pending implementation of suggestion longpress submenus
                    // Only really used by native-KMW - see kmwnative's highlightSubKeys func.
                    return false;
                };
                SuggestionManager.prototype.isSubmenuActive = function () {
                    // Temp, pending implementation of suggestion longpress submenus
                    // Utilized only by native-KMW - it parallels hasModalPopup() in purpose.
                    return false;
                };
                SuggestionManager.prototype.displaySubmenuFor = function (target) {
                    // Utilized only by native-KMW to show submenus.
                    throw new Error("Method not implemented.");
                };
                SuggestionManager.prototype.doAccept = function (suggestion) {
                    var _a = suggestion.apply(), revert = _a[0], revertText = _a[1];
                    var _this = this;
                    if (revert) {
                        this.preAccept = revert;
                        revertText.then(function (text) {
                            _this.preAcceptText = text;
                        });
                    }
                    else {
                        // If null, it's a blank option; we should effectively never 'accept' it.
                        return;
                    }
                    this.selected = null;
                    this.recentAccept = true;
                    this.doRevert = false;
                    this.recentRevert = false;
                    this.recentAccepted = suggestion.suggestion;
                    this.previousSuggestions = this.currentSuggestions;
                    this.previousTranscriptionID = this.currentTranscriptionID;
                    // Request a 'new' prediction based on current context with a nil Transform.
                    var keyman = com.keyman.singleton;
                    this.swallowPrediction = true;
                    keyman.modelManager.predict();
                };
                SuggestionManager.prototype.showRevert = function () {
                    // Construct a 'revert suggestion' to facilitate a reversion UI component.
                    this.revertSuggestion = {
                        transform: null,
                        displayAs: '"' + this.preAcceptText + '"'
                    };
                    this.doRevert = true;
                    this.doUpdate();
                };
                SuggestionManager.prototype.activateKeep = function () {
                    return !this.recentAccept && !this.recentRevert && !this.initNewContext;
                };
                SuggestionManager.prototype.doUpdate = function () {
                    var _this_1 = this;
                    var keyman = com.keyman.singleton;
                    var suggestions = [];
                    // Insert 'current text' if/when valid as the leading option.
                    if (this.activateKeep() && this.keepSuggestion) {
                        suggestions.push(this.keepSuggestion);
                    }
                    else if (this.doRevert) {
                        suggestions.push(this.revertSuggestion);
                    }
                    suggestions = suggestions.concat(this.currentSuggestions);
                    this.options.forEach(function (option, i) {
                        if (i < suggestions.length) {
                            var revertFlag = (i == 0 && _this_1.doRevert);
                            option.update(suggestions[i], revertFlag ? _this_1._applyReversion : null);
                        }
                        else {
                            option.update(null);
                        }
                    });
                };
                SuggestionManager.prototype.rotateSuggestions = function () {
                    if (this.currentSuggestions.length > 0) {
                        var replaceCount = SuggestionBanner.SUGGESTION_LIMIT - (this.activateKeep() ? 1 : 0);
                        var rotating = this.currentSuggestions.splice(0, replaceCount);
                        this.rejectedSuggestions = this.rejectedSuggestions.concat(rotating);
                    }
                    // If we just removed the last available suggestions, it's time to refresh the list.
                    if (this.currentSuggestions.length == 0) {
                        this.currentSuggestions = this.rejectedSuggestions;
                        this.rejectedSuggestions = [];
                    }
                    this.doUpdate();
                };
                return SuggestionManager;
            }(keyman_14.dom.UITouchHandlerBase));
            osk.SuggestionManager = SuggestionManager;
        })(osk = keyman_14.osk || (keyman_14.osk = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="banner.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_15) {
        var osk;
        (function (osk) {
            /**
             * The `BannerManager` module is designed to serve as a manager for the
             * different `Banner` types.
             * To facilitate this, it will provide a root element property that serves
             * as a container for any active `Banner`, helping KMW to avoid needless
             * DOM element shuffling.
             *
             * Goals for the `BannerManager`:
             *
             * * It will be exposed as `keyman.osk.banner` and will provide the following API:
             *   * `getOptions`, `setOptions` - refer to the `BannerOptions` class for details.
             *   * This provides a persistent point that the web page designers and our
             *     model apps can utilize and can communicate with.
             *   * These API functions are designed for live use and will allow
             *     _hot-swapping_ the `Banner` instance; they're not initialization-only.
             * * Disabling the `Banner` (even for suggestions) outright with
             *   `enablePredictions == false` will auto-unload any loaded predictive model
             *   from `ModelManager` and setting it to `true` will revert this.
             *   * This should help to avoid wasting computational resources.
             * * It will listen to ModelManager events and automatically swap Banner
             *   instances as appropriate:
             *   * The option `persistentBanner == true` is designed to replicate current
             *     iOS system keyboard behavior.
             *     * When true, an `ImageBanner` will be displayed.
             *     * If false, it will be replaced with a `BlankBanner` of zero height,
             *       corresponding to our current default lack of banner.
             *   * It will not automatically set `persistentBanner == true`;
             *     this must be set by the iOS app, and only under the following conditions:
             *     * `keyman.isEmbedded == true`
             *     * `device.OS == 'ios'`
             *     * Keyman is being used as the system keyboard within an app that
             *       needs to reserve this space (i.e: Keyman for iOS),
             *       rather than as its standalone app.
             */
            var BannerManager = /** @class */ (function () {
                function BannerManager() {
                    this._options = {};
                    this.imagePath = "";
                    // Step 1 - establish the container element.  Must come before this.setOptions.
                    this.constructContainer();
                    // Initialize with the default options - 
                    // any 'manually set' options come post-construction.
                    // This will also automatically set the default banner in place.
                    this.setOptions(BannerManager.DEFAULT_OPTIONS);
                    // Register a listener for model change events so that we can hot-swap the banner as needed.
                    var keyman = com.keyman.singleton;
                    keyman.modelManager['addEventListener']('modelchange', this.selectBanner.bind(this));
                }
                /**
                 * Constructs the <div> element used to contain hot-swapped `Banner` instances.
                 */
                BannerManager.prototype.constructContainer = function () {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    var d = util._CreateElement('div');
                    d.id = "keymanweb_banner_container";
                    d.className = "kmw-banner-container";
                    return this.bannerContainer = d;
                };
                Object.defineProperty(BannerManager.prototype, "element", {
                    /**
                     * Returns the `Banner`-containing div element used to facilitate hot-swapping.
                     */
                    get: function () {
                        return this.bannerContainer;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * This function corresponds to `keyman.osk.banner.getOptions`.
                 *
                 * Gets the current control settings in use by `BannerManager`.
                 */
                BannerManager.prototype.getOptions = function () {
                    var retObj = {};
                    for (var key in this._options) {
                        retObj[key] = this._options[key];
                    }
                    return retObj;
                };
                /**
                 * This function corresponds to `keyman.osk.banner.setOptions`.
                 *
                 * Sets options used to tweak the automatic `Banner`
                 * control logic used by `BannerManager`.
                 * @param optionSpec An object specifying one or more of the following options:
                 * * `persistentBanner` (boolean) When `true`, ensures that a `Banner`
                 *   is always displayed, even when no predictive model exists
                 *   for the active language.
                 *
                 *   Default: `false`
                 * * `imagePath` (URL string) Specifies the file path to use for an
                 *   `ImageBanner` when `persistentBanner` is `true` and no predictive model exists.
                 *
                 *   Default: `''`.
                 * * `enablePredictions` (boolean) Turns KMW predictions
                 *   on (when `true`) and off (when `false`).
                 *
                 *   Default:  `true`.
                 */
                BannerManager.prototype.setOptions = function (optionSpec) {
                    var keyman = com.keyman.singleton;
                    for (var key in optionSpec) {
                        switch (key) {
                            // Each defined option may require specialized handling.
                            case 'alwaysShow':
                                // Determines the banner type to activate.
                                this.alwaysShow = optionSpec[key];
                                break;
                            case 'mayPredict':
                                keyman.modelManager.mayPredict = optionSpec[key];
                                break;
                            case 'mayCorrect':
                                keyman.modelManager.mayCorrect = optionSpec[key];
                                break;
                            case 'imagePath':
                                // Determines the image file to use for ImageBanners.
                                this.imagePath = optionSpec[key];
                                break;
                            default:
                            // Invalid option specified!
                        }
                        this._options[key] = optionSpec[key];
                    }
                    this.selectBanner();
                };
                /**
                 * Applies any stylesheets needed by specific `Banner` instances.
                 */
                BannerManager.prototype.appendStyles = function () {
                    if (this.activeBanner) {
                        this.activeBanner.appendStyleSheet();
                    }
                };
                /**
                 * Sets the active `Banner` to the specified type, regardless of
                 * existing management logic settings.
                 *
                 * @param type `'blank' | 'image' | 'suggestion'` - A plain-text string
                 *        representing the type of `Banner` to set active.
                 * @param height - Optional banner height in pixels.
                 */
                BannerManager.prototype.setBanner = function (type, height) {
                    var banner;
                    switch (type) {
                        case 'blank':
                            banner = new osk.BlankBanner();
                            break;
                        case 'image':
                            banner = new osk.ImageBanner(this.imagePath, osk.Banner.DEFAULT_HEIGHT);
                            break;
                        case 'suggestion':
                            banner = new osk.SuggestionBanner(height);
                            break;
                        default:
                            throw new Error("Invalid type specified for the banner!");
                    }
                    this._activeType = type;
                    if (banner) {
                        this._setBanner(banner);
                        banner.activate();
                    }
                };
                /**
                 * Handles `ModelManager`'s `'modelchange'` events,
                 * allowing logic to automatically hot-swap `Banner`s as needed.
                 * @param state
                 */
                BannerManager.prototype.selectBanner = function (state) {
                    var keyman = com.keyman.singleton;
                    // Only display a SuggestionBanner when the current 
                    // language has an active predictive model.
                    // ModelManager will never have an active model 
                    // when predictions are disabled.
                    if (keyman.modelManager.activeModel) {
                        this.setBanner('suggestion');
                    }
                    else if (this.alwaysShow) {
                        this.setBanner('image');
                    }
                    else {
                        this.setBanner('blank');
                    }
                };
                /**
                 * Internal method used by the public API `setBanner`.  `setBanner`
                 * translates the string parameter into a new instance consumed by this method.
                 * @param banner The `Banner` instance to set as active.
                 */
                BannerManager.prototype._setBanner = function (banner) {
                    if (this.activeBanner) {
                        if (banner == this.activeBanner) {
                            return;
                        }
                        else {
                            var prevBanner = this.activeBanner;
                            prevBanner.deactivate();
                            this.bannerContainer.replaceChild(banner.getDiv(), prevBanner.getDiv());
                        }
                    }
                    this.activeBanner = banner;
                    this.bannerContainer.appendChild(banner.getDiv());
                    // Don't forget to adjust the OSK in case we're now using a blank Banner!
                    var keyman = com.keyman.singleton;
                    keyman['osk']._Show();
                };
                Object.defineProperty(BannerManager.prototype, "activeType", {
                    get: function () {
                        return this._activeType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BannerManager.prototype, "height", {
                    /**
                     * Gets the height (in pixels) of the active `Banner` instance.
                     */
                    get: function () {
                        if (this.activeBanner) {
                            return this.activeBanner.height;
                        }
                        else {
                            return 0;
                        }
                    },
                    /**
                     * Sets the height (in pixels) of the active 'Banner' instance.
                     */
                    set: function (h) {
                        if (this.activeBanner) {
                            this.activeBanner.height = h;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                BannerManager.DEFAULT_OPTIONS = {
                    alwaysShow: false,
                    mayPredict: true,
                    mayCorrect: true,
                    imagePath: ""
                };
                return BannerManager;
            }());
            osk.BannerManager = BannerManager;
        })(osk = keyman_15.osk || (keyman_15.osk = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="../kmwexthtml.ts" />  // Includes KMW-added property declaration extensions for HTML elements.
// Includes KMW string extension declarations.
/// <reference path="../text/kmwstring.ts" /> 
// Includes the default layout specification.
/// <reference path="defaultLayouts.ts" /> 
// Includes the touch-mode language picker UI.
/// <reference path="languageMenu.ts" />
// Includes the banner
/// <reference path="./bannerManager.ts" />
// Generates the visual keyboard specific to each keyboard.  (class="kmw-osk-inner-frame")
/// <reference path="visualKeyboard.ts" />
/***
   KeymanWeb 10.0
   Copyright 2017 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var osk;
        (function (osk) {
            var OSKManager = /** @class */ (function () {
                function OSKManager() {
                    this.ready = false;
                    this.loadRetry = 0;
                    // OSK state fields
                    this._Visible = false;
                    this._Enabled = true;
                    this.vpScale = 1;
                    // OSK positioning fields
                    this.userPositioned = false;
                    this.noDrag = false;
                    // Key code definition aliases for legacy keyboards  (They expect window['keyman']['osk'].___)
                    this.modifierCodes = keyman.text.Codes.modifierCodes;
                    this.modifierBitmasks = keyman.text.Codes.modifierBitmasks;
                    this.stateBitmasks = keyman.text.Codes.stateBitmasks;
                    this.keyCodes = keyman.text.Codes.keyCodes;
                    /**
                     * Move OSK back to default position
                     */
                    this.restorePosition = function () {
                        if (this._Visible) {
                            com.keyman.singleton.domManager.focusLastActiveElement(); // I2036 - OSK does not unpin to correct location
                            this.loadCookie();
                            this.userPositioned = false;
                            this.saveCookie();
                            this._Show();
                            this.doResizeMove(); //allow the UI to respond to OSK movements
                        }
                        if (this.pinImg) {
                            this.pinImg.style.display = 'none';
                        }
                        if (window.event) {
                            window.event.returnValue = false;
                        }
                    }.bind(this);
                    /**
                     * Function     _VKbdMouseOver
                     * Scope        Private
                     * @param       {Object}      e      event
                     * Description  Activate the KMW UI on mouse over
                     */
                    this._VKbdMouseOver = function (e) {
                        com.keyman.singleton.uiManager.setActivatingUI(true);
                    }.bind(this);
                    /**
                     * Function     _VKbdMouseOut
                     * Scope        Private
                     * @param       {Object}      e      event
                     * Description  Cancel activation of KMW UI on mouse out
                     */
                    this._VKbdMouseOut = function (e) {
                        com.keyman.singleton.uiManager.setActivatingUI(false);
                    }.bind(this);
                    /**
                     * Function     _VResizeMouseOver, _VResizeMouseOut
                     * Scope        Private
                     * @param       {Object}      e      event
                     * Description  Process end of resizing of KMW UI
                     */
                    this._VResizeMouseOut = function (e) {
                        e = com.keyman.singleton._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                        if (!e) {
                            return false;
                        }
                        if (e && e.preventDefault) {
                            e.preventDefault();
                        }
                        var r = this.getRect();
                        this.width = r.width;
                        this.height = r.height;
                        e.cancelBubble = true;
                        return false;
                    }.bind(this);
                    this._VResizeMouseOver = this._VResizeMouseOut;
                    /**
                     * Function     _VResizeMouseDown
                     * Scope        Private
                     * @param       {Object}      e      event
                     * Description  Process resizing of KMW UI
                     */
                    this._VResizeMouseDown = function (e) {
                        var keymanweb = com.keyman.singleton;
                        keymanweb.uiManager.justActivated = true;
                        e = keymanweb._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                        if (!e) {
                            return true;
                        }
                        this.resizing = true;
                        var Lposx, Lposy;
                        if (e.pageX) {
                            Lposx = e.pageX;
                            Lposy = e.pageY;
                        }
                        else if (e.clientX) {
                            Lposx = e.clientX + document.body.scrollLeft;
                            Lposy = e.clientY + document.body.scrollTop;
                        }
                        this._ResizeMouseX = Lposx;
                        this._ResizeMouseY = Lposy;
                        if (document.onmousemove != this._VResizeMouseMove && document.onmousemove != this._VMoveMouseMove) { // I1472 - Dragging off edge of browser window causes muckup
                            this._VPreviousMouseMove = document.onmousemove;
                            this._VPreviousMouseUp = document.onmouseup;
                        }
                        this._VPreviousCursor = document.body.style.cursor;
                        this._VPreviousMouseButton = (typeof (e.which) == 'undefined' ? e.button : e.which);
                        this._VOriginalWidth = this.vkbd.kbdDiv.offsetWidth;
                        this._VOriginalHeight = this.vkbd.kbdDiv.offsetHeight;
                        document.onmousemove = this._VResizeMouseMove;
                        document.onmouseup = this._VResizeMoveMouseUp;
                        if (document.body.style.cursor) {
                            document.body.style.cursor = 'se-resize';
                        }
                        if (e && e.preventDefault) {
                            e.preventDefault();
                        }
                        e.cancelBubble = true;
                        return false;
                    }.bind(this);
                    /**
                     * Function     _VResizeMouseMove
                     * Scope        Private
                     * @param       {Object}      e      event
                     * Description  Process mouse movement during resizing of OSK
                     */
                    this._VResizeMouseMove = function (e) {
                        var Lposx, Lposy;
                        e = com.keyman.singleton._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                        if (!e) {
                            return true;
                        }
                        this.resizing = true;
                        if (this._VPreviousMouseButton != (typeof (e.which) == 'undefined' ? e.button : e.which)) { // I1472 - Dragging off edge of browser window causes muckup
                            return this._VResizeMoveMouseUp(e);
                        }
                        else {
                            if (e.pageX) {
                                Lposx = e.pageX;
                                Lposy = e.pageY;
                            }
                            else if (e.clientX) {
                                Lposx = e.clientX + document.body.scrollLeft;
                                Lposy = e.clientY + document.body.scrollTop;
                            }
                            var newWidth = (this._VOriginalWidth + Lposx - this._ResizeMouseX), newHeight = (this._VOriginalHeight + Lposy - this._ResizeMouseY);
                            // Set the smallest and largest OSK size
                            if (newWidth < 0.2 * screen.width) {
                                newWidth = 0.2 * screen.width;
                            }
                            if (newHeight < 0.1 * screen.height) {
                                newHeight = 0.1 * screen.height;
                            }
                            if (newWidth > 0.9 * screen.width) {
                                newWidth = 0.9 * screen.width;
                            }
                            if (newHeight > 0.5 * screen.height) {
                                newWidth = 0.5 * screen.height;
                            }
                            // Set OSK width
                            this.vkbd.kbdDiv.style.width = newWidth + 'px';
                            // Explicitly change OSK height and font size - cannot safely rely on scaling from font
                            this.vkbd.kbdDiv.style.height = newHeight + 'px';
                            this.vkbd.kbdDiv.style.fontSize = (newHeight / 8) + 'px';
                            if (e && e.preventDefault) {
                                e.preventDefault();
                            }
                            e.cancelBubble = true;
                            return false;
                        }
                    }.bind(this);
                    /**
                     * Function     _VMoveMouseDown
                     * Scope        Private
                     * @param       {Object}      e      event
                     * Description  Process mouse down on OSK
                     */
                    this._VMoveMouseDown = function (e) {
                        var keymanweb = com.keyman.singleton;
                        var Lposx, Lposy;
                        keymanweb.uiManager.justActivated = true;
                        e = keymanweb._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                        if (!e) {
                            return true;
                        }
                        this.resizing = true;
                        if (e.pageX) {
                            Lposx = e.pageX;
                            Lposy = e.pageY;
                        }
                        else if (e.clientX) {
                            Lposx = e.clientX + document.body.scrollLeft;
                            Lposy = e.clientY + document.body.scrollTop;
                        }
                        if (document.onmousemove != this._VResizeMouseMove && document.onmousemove != this._VMoveMouseMove) { // I1472 - Dragging off edge of browser window causes muckup
                            this._VPreviousMouseMove = document.onmousemove;
                            this._VPreviousMouseUp = document.onmouseup;
                        }
                        this._VPreviousCursor = document.body.style.cursor;
                        this._VPreviousMouseButton = (typeof (e.which) == 'undefined' ? e.button : e.which);
                        this._VMoveX = Lposx - this._Box.offsetLeft;
                        this._VMoveY = Lposy - this._Box.offsetTop;
                        if (keymanweb.keyboardManager.isCJK()) {
                            this.pinImg.style.left = '15px';
                        }
                        document.onmousemove = this._VMoveMouseMove;
                        document.onmouseup = this._VResizeMoveMouseUp;
                        if (document.body.style.cursor) {
                            document.body.style.cursor = 'move';
                        }
                        if (e && e.preventDefault) {
                            e.preventDefault();
                        }
                        e.cancelBubble = true;
                        return false;
                    }.bind(this);
                    /**
                     * Process mouse drag on OSK
                     *
                     * @param       {Object}      e      event
                     */
                    this._VMoveMouseMove = function (e) {
                        var keymanweb = com.keyman.singleton;
                        var Lposx, Lposy;
                        e = keymanweb._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                        if (!e) {
                            return true;
                        }
                        if (this.noDrag) {
                            return true;
                        }
                        this.resizing = true;
                        this.userPositioned = true;
                        this.pinImg.style.display = 'block';
                        if (this._VPreviousMouseButton != (typeof (e.which) == 'undefined' ? e.button : e.which)) { // I1472 - Dragging off edge of browser window causes muckup
                            return this._VResizeMoveMouseUp(e);
                        }
                        else {
                            if (e.pageX) {
                                Lposx = e.pageX;
                                Lposy = e.pageY;
                            }
                            else if (e.clientX) {
                                Lposx = e.clientX + document.body.scrollLeft;
                                Lposy = e.clientY + document.body.scrollTop;
                            }
                            this._Box.style.left = (Lposx - this._VMoveX) + 'px';
                            this._Box.style.top = (Lposy - this._VMoveY) + 'px';
                            if (e && e.preventDefault) {
                                e.preventDefault();
                            }
                            var r = this.getRect();
                            this.width = r.width;
                            this.height = r.height;
                            e.cancelBubble = true;
                            return false;
                        }
                    }.bind(this);
                    /**
                     * Function     _VResizeMoveMouseUp
                     * Scope        Private
                     * @param       {Object}      e      event
                     * Description  Process mouse up during resizing of KMW UI
                     */
                    this._VResizeMoveMouseUp = function (e) {
                        var keymanweb = com.keyman.singleton;
                        e = keymanweb._GetEventObject(e); // I2404 - Manage IE events in IFRAMEs
                        if (!e) {
                            return true;
                        }
                        this.resizing = false;
                        if (this.vkbd) {
                            this.vkbd.currentKey = null;
                        }
                        document.onmousemove = this._VPreviousMouseMove;
                        document.onmouseup = this._VPreviousMouseUp;
                        if (document.body.style.cursor) {
                            document.body.style.cursor = this._VPreviousCursor;
                        }
                        keymanweb.domManager.focusLastActiveElement();
                        if (e && e.preventDefault) {
                            e.preventDefault();
                        }
                        keymanweb.uiManager.justActivated = false;
                        keymanweb.uiManager.setActivatingUI(false);
                        if (this.vkbd) {
                            this._VOriginalWidth = this.vkbd.kbdDiv.offsetWidth;
                            this._VOriginalHeight = this.vkbd.kbdDiv.offsetHeight;
                        }
                        this.doResizeMove();
                        e.cancelBubble = true;
                        this.saveCookie();
                        return false;
                    }.bind(this);
                    /**
                 * Function     hideNow
                 * Scope        Private
                 * Description  Hide the OSK unconditionally and immediately, cancel any pending transition
                 */
                    this.hideNow = function () {
                        this._Box.removeEventListener('transitionend', this.hideNow, false);
                        this._Box.removeEventListener('webkitTransitionEnd', this.hideNow, false);
                        if (document.body.className.indexOf('osk-always-visible') >= 0) {
                            return;
                        }
                        var os = this._Box.style;
                        os.display = 'none';
                        os.opacity = '1';
                        this._Visible = false;
                        os.transition = os.msTransition = os.MozTransition = os.WebkitTransition = '';
                        if (this.vkbd) {
                            this.vkbd.onHide();
                        }
                    }.bind(this);
                }
                // First time initialization of OSK
                OSKManager.prototype.prepare = function () {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    // Defer loading the OSK until KMW code initialization complete
                    if (!keymanweb['initialized']) {
                        window.setTimeout(this.prepare.bind(this), 200);
                        return;
                    }
                    // OSK initialization - create DIV and set default styles
                    if (!this.ready) {
                        this._Box = util._CreateElement('div'); // Container for OSK (Help DIV, displayed when user clicks Help icon)
                        document.body.appendChild(this._Box);
                        // Install the default OSK stylesheet
                        util.linkStyleSheet(keymanweb.getStyleSheetPath('kmwosk.css'));
                        // For mouse click to prevent loss of focus
                        util.attachDOMEvent(this._Box, 'mousedown', function (obj) {
                            keymanweb.uiManager.setActivatingUI(true);
                            return false;
                        });
                        // And to prevent touch event default behaviour on mobile devices
                        // TODO: are these needed, or do they interfere with other OSK event handling ????
                        if (util.device.touchable) { // I3363 (Build 301)
                            var cancelEventFunc = function (e) {
                                if (e.cancelable) {
                                    e.preventDefault();
                                }
                                e.stopPropagation();
                                return false;
                            };
                            util.attachDOMEvent(this._Box, 'touchstart', function (e) {
                                keymanweb.uiManager.setActivatingUI(true);
                                return cancelEventFunc(e);
                            });
                            util.attachDOMEvent(this._Box, 'touchend', cancelEventFunc);
                            util.attachDOMEvent(this._Box, 'touchmove', cancelEventFunc);
                            util.attachDOMEvent(this._Box, 'touchcancel', cancelEventFunc);
                            // Can only get (initial) viewport scale factor after page is fully loaded!
                            this.vpScale = util.getViewportScale();
                        }
                    }
                    this.loadCookie();
                    this.banner = new osk.BannerManager();
                    this.ready = true;
                };
                /**
                 * Function     _Unload
                 * Scope        Private
                 * Description  Clears OSK variables prior to exit (JMD 1.9.1 - relocation of local variables 3/9/10)
                 */
                OSKManager.prototype._Unload = function () {
                    this.vkbd = null;
                    this.banner = null;
                    this._Box = null;
                };
                /**
                 * Function     _Load
                 * Scope        Private
                 * Description  OSK initialization when keyboard selected
                 */
                OSKManager.prototype._Load = function () {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    var device = util.device;
                    var activeKeyboard = keymanweb.keyboardManager.activeKeyboard;
                    // If _Load called before OSK is ready, must wait and call again
                    if (this._Box == null) {
                        if (this.loadRetry >= 99) {
                            return; // fail silently, but should not happen
                        }
                        window.setTimeout(this._Load.bind(this), 100);
                        this.loadRetry++;
                        return;
                    }
                    this.loadRetry = 0;
                    if (keymanweb._TitleElement) {
                        keymanweb._TitleElement.innerHTML = 'KeymanWeb'; // I1972
                    }
                    this._Visible = false; // I3363 (Build 301)
                    var s = this._Box.style;
                    s.zIndex = '9999';
                    s.display = 'none';
                    s.width = device.touchable ? '100%' : 'auto';
                    s.position = (device.formFactor == 'desktop' ? 'absolute' : 'fixed');
                    // Use smaller base font size for mobile devices
                    //if(screen.availHeight < 500) s.fontSize='10pt';
                    //else if(screen.availHeight < 800) s.fontSize='11pt';
                    //else s.fontSize='12pt';
                    // Set scaling for mobile devices here.
                    if (device.touchable) {
                        var fontScale = 1;
                        if (device.formFactor == 'phone') {
                            fontScale = 1.6 * (keymanweb.isEmbedded ? 0.65 : 0.6) * 1.2; // Combines original scaling factor with one previously applied to the layer group.
                        }
                        else {
                            // The following is a *temporary* fix for small format tablets, e.g. PendoPad
                            var pixelRatio = 1;
                            if (device.OS == 'Android' && 'devicePixelRatio' in window) {
                                pixelRatio = window.devicePixelRatio;
                            }
                            if (device.OS == 'Android' && device.formFactor == 'tablet' && this.getHeight() < 300 * pixelRatio) {
                                fontScale *= 1.2;
                            }
                            else {
                                fontScale *= 2; //'2.5em';
                            }
                        }
                        // Finalize the font size parameter.
                        s.fontSize = fontScale + 'em';
                    }
                    this.vkbd = null;
                    // TODO:  Consider a 'vkbd.release()' method?
                    // Instantly resets the OSK container, erasing / delinking the previously-loaded keyboard.
                    this._Box.innerHTML = '';
                    this._Box.onmouseover = this._VKbdMouseOver;
                    this._Box.onmouseout = this._VKbdMouseOut;
                    // TODO: find out and document why this should not be done for touch devices!!
                    // (Probably to avoid having a null keyboard. But maybe that *is* an option, if there remains a way to get the language menu,
                    //  such as a minimized menu button?)
                    if (activeKeyboard == null && !device.touchable) {
                        var Ldiv = util._CreateElement('div');
                        Ldiv.className = "kmw-title-bar";
                        Ldiv.appendChild(this._TitleBarInterior());
                        Ldiv.onmousedown = this._VMoveMouseDown;
                        this._Box.appendChild(Ldiv);
                        Ldiv = util._CreateElement('div');
                        Ldiv.className = 'kmw-osk-none';
                        this._Box.appendChild(Ldiv);
                    }
                    else {
                        var Lviskbd = null, layouts = null, layout = null, Lhelp = '';
                        this._Box.className = "";
                        if (activeKeyboard != null) {
                            Lviskbd = activeKeyboard['KV'];
                            Lhelp = activeKeyboard['KH'];
                            // Check if dynamic layout is defined within keyboard
                            layouts = activeKeyboard['KVKL'];
                            // If any keyboard layout file is provided, use that to override the generated layout
                            if (typeof layouts != 'undefined' && layouts != null) {
                                layout = layouts[device.formFactor];
                                // Use the layout for the device, if defined, otherwise use the desktop (default) layout
                                if (typeof layout == 'undefined' || layout == null) {
                                    if (device.formFactor == 'phone') {
                                        layout = layouts['tablet'];
                                    }
                                    else if (device.formFactor == 'tablet') {
                                        layout = layouts['phone'];
                                    }
                                    if (typeof layout == 'undefined' || layout == null) {
                                        layout = layouts['desktop'];
                                    }
                                }
                            }
                        }
                        // Test if Visual keyboard is simply a place holder, set to null if so
                        if (Lviskbd != null && Lviskbd['BK'] != null) {
                            var keyCaps = Lviskbd['BK'], noKeyCaps = true;
                            for (var i = 0; i < keyCaps.length; i++) {
                                if (keyCaps[i].length > 0) {
                                    noKeyCaps = false;
                                    break;
                                }
                            }
                            if (noKeyCaps) {
                                Lviskbd = null;
                            }
                        }
                        // Generate a visual keyboard from the layout (or layout default)
                        // TODO: this should probably be unconditional now
                        if (Lviskbd != null || Lhelp == '' || device.touchable) { // I3363 (Build 301)
                            // TODO: May want to define a default BK array here as well
                            if (Lviskbd == null) {
                                Lviskbd = { 'F': 'Tahoma', 'BK': osk.Layouts.dfltText }; //DDOSK
                            }
                            this._GenerateVisualKeyboard(Lviskbd, Lhelp, layout, keymanweb.keyboardManager.getKeyboardModifierBitmask());
                        }
                        else { //The following code applies only to preformatted 'help' such as European Latin
                            //osk.ddOSK = false;
                            Ldiv = util._CreateElement('div');
                            Ldiv.className = "kmw-title-bar";
                            Ldiv.appendChild(this._TitleBarInterior());
                            Ldiv.onmousedown = this._VMoveMouseDown;
                            this._Box.appendChild(Ldiv);
                            //Add content
                            var Ldiv = util._CreateElement('div');
                            Ldiv.className = 'kmw-osk-static';
                            Ldiv.innerHTML = Lhelp;
                            this._Box.appendChild(Ldiv);
                            if (activeKeyboard['KHF']) {
                                activeKeyboard['KHF'](this._Box);
                            }
                        }
                        if (keymanweb._TitleElement) {
                            keymanweb._TitleElement.innerHTML = "<span style='font-weight:bold'>"
                                + activeKeyboard['KN'] + '</span> - ' + keymanweb._TitleElement.innerHTML; // I1972  // I2186
                            keymanweb._TitleElement.className = '';
                            keymanweb._TitleElement.style.color = '#fff';
                        }
                    }
                    // Correct the classname for the (inner) OSK frame (Build 360)
                    var kbdID = (activeKeyboard ? activeKeyboard['KI'].replace('Keyboard_', '') : '');
                    if (keymanweb.isEmbedded && kbdID.indexOf('::') != -1) {
                        // De-namespaces the ID for use with CSS classes.
                        // Keyboard IDs may not contain the ':' symbol, so this is safe.
                        kbdID = kbdID.substring(kbdID.indexOf('::') + 2);
                    }
                    var innerFrame = this._Box.firstChild, kbdClass = ' kmw-keyboard-' + kbdID;
                    if (innerFrame.id == 'keymanweb_title_bar') {
                        // Desktop order is title_bar, banner_container, inner-frame
                        innerFrame = innerFrame.nextSibling.nextSibling;
                    }
                    else if (innerFrame.id == 'keymanweb_banner_container') {
                        innerFrame = innerFrame.nextSibling;
                    }
                    innerFrame.className = 'kmw-osk-inner-frame' + kbdClass;
                    this.banner.appendStyles();
                    if (this.vkbd) {
                        // Create the key preview (for phones)
                        this.vkbd.createKeyTip();
                        // Append a stylesheet for this keyboard for keyboard specific styles
                        // or if needed to specify an embedded font
                        this.vkbd.appendStyleSheet();
                    }
                    if (this._Enabled) {
                        this._Show();
                    }
                };
                /**
                 * Function     _GenerateVisualKeyboard
                 * Scope        Private
                 * @param       {Object}      PVK         Visual keyboard name
                 * @param       {Object}      Lhelp       true if OSK defined for this keyboard
                 * @param       {Object}      layout0
                 * @param       {Number}      kbdBitmask  Keyboard modifier bitmask
                 * Description  Generates the visual keyboard element and attaches it to KMW
                 */
                OSKManager.prototype._GenerateVisualKeyboard = function (PVK, Lhelp, layout0, kbdBitmask) {
                    this.vkbd = new com.keyman.osk.VisualKeyboard(PVK, Lhelp, layout0, kbdBitmask);
                    var util = com.keyman.singleton.util;
                    // Set box class - OS and keyboard added for Build 360
                    this._Box.className = util.device.formFactor + ' ' + util.device.OS.toLowerCase() + ' kmw-osk-frame';
                    // Add header element to OSK only for desktop browsers
                    if (util.device.formFactor == 'desktop') {
                        this._Box.appendChild(this.controlBar());
                    }
                    // Add suggestion banner bar to OSK
                    if (this.banner) {
                        this._Box.appendChild(this.banner.element);
                    }
                    // Add primary keyboard element to OSK
                    this._Box.appendChild(this.vkbd.kbdDiv);
                    // Add footer element to OSK only for desktop browsers
                    if (util.device.formFactor == 'desktop') {
                        this._Box.appendChild(this.resizeBar());
                        // For other devices, adjust the object heights, allowing for viewport scaling
                    }
                    else {
                        this.vkbd.adjustHeights();
                    }
                };
                /**
                 * Create a control bar with title and buttons for the desktop OSK
                 */
                OSKManager.prototype.controlBar = function () {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    var bar = util._CreateElement('div'), title = '';
                    bar.id = 'keymanweb_title_bar';
                    bar.className = 'kmw-title-bar';
                    bar.onmousedown = this._VMoveMouseDown;
                    if (keymanweb.keyboardManager.activeKeyboard) {
                        title = keymanweb.keyboardManager.activeKeyboard['KN'];
                    }
                    var Ltitle = util._CreateElement('span');
                    Ltitle.className = 'kmw-title-bar-caption';
                    Ltitle.innerHTML = title;
                    bar.appendChild(Ltitle);
                    var Limg = this.closeButton = util._CreateElement('div');
                    Limg.id = 'kmw-close-button';
                    Limg.className = 'kmw-title-bar-image';
                    Limg.onmousedown = util._CancelMouse;
                    Limg.onclick = function () {
                        this._Hide(true);
                    }.bind(this);
                    bar.appendChild(Limg);
                    Limg = this.helpImg = util._CreateElement('div');
                    Limg.id = 'kmw-help-image';
                    Limg.className = 'kmw-title-bar-image';
                    Limg.title = 'KeymanWeb Help';
                    Limg.onclick = function () {
                        var p = {};
                        util.callEvent('osk.helpclick', p);
                        if (window.event) {
                            window.event.returnValue = false;
                        }
                        return false;
                    };
                    Limg.onmousedown = util._CancelMouse;
                    bar.appendChild(Limg);
                    Limg = this.configImg = util._CreateElement('div');
                    Limg.id = 'kmw-config-image';
                    Limg.className = 'kmw-title-bar-image';
                    Limg.title = 'KeymanWeb Configuration Options';
                    Limg.onclick = function () {
                        var p = {};
                        util.callEvent('osk.configclick', p);
                        if (window.event) {
                            window.event.returnValue = false;
                        }
                        return false;
                    };
                    Limg.onmousedown = util._CancelMouse;
                    bar.appendChild(Limg);
                    Limg = this.pinImg = util._CreateElement('div'); //I2186
                    Limg.id = 'kmw-pin-image';
                    Limg.className = 'kmw-title-bar-image';
                    Limg.title = 'Pin the On Screen Keyboard to its default location on the active text box';
                    Limg.onclick = function () {
                        this.loadCookie();
                        this.userPositioned = false;
                        this.saveCookie();
                        this._Show();
                        this.doResizeMove(); //allow the UI to respond to OSK movements
                        if (this.pinImg) {
                            this.pinImg.style.display = 'none';
                        }
                        if (window.event) {
                            window.event.returnValue = false;
                        }
                        return false;
                    }.bind(this);
                    Limg.onmousedown = util._CancelMouse;
                    bar.appendChild(Limg);
                    return bar;
                };
                /**
                 * Create a bottom bar with a resizing icon for the desktop OSK
                 */
                OSKManager.prototype.resizeBar = function () {
                    var util = com.keyman.singleton.util;
                    var bar = util._CreateElement('div');
                    bar.className = 'kmw-footer';
                    bar.onmousedown = util._CancelMouse;
                    // Add caption
                    var Ltitle = util._CreateElement('div');
                    Ltitle.className = 'kmw-footer-caption';
                    Ltitle.innerHTML = '<a href="https://keyman.com/developer/keymanweb/">KeymanWeb</a>';
                    Ltitle.id = 'keymanweb-osk-footer-caption';
                    // Display build number on shift+double click
                    util.attachDOMEvent(Ltitle, 'dblclick', function (e) {
                        if (e && e.shiftKey) {
                            this.showBuild();
                        }
                        return false;
                    }.bind(this), false);
                    // Prevent selection of caption (IE - set by class for other browsers)
                    if ('onselectstart' in Ltitle)
                        Ltitle.onselectstart = util.selectStartHandler; //IE (Build 360)
                    bar.appendChild(Ltitle);
                    var Limg = util._CreateElement('div');
                    Limg.className = 'kmw-footer-resize';
                    Limg.onmousedown = this._VResizeMouseDown;
                    Limg.onmouseover = Limg.onmouseout = this._VResizeMouseOut;
                    bar.appendChild(Limg);
                    this.resizeIcon = Limg;
                    //TODO: the image never appears in IE8, have no idea why!
                    return bar;
                };
                /**
                 * Display build number
                 */
                OSKManager.prototype.showBuild = function () {
                    var keymanweb = com.keyman.singleton;
                    keymanweb.util.alert('KeymanWeb Version ' + keymanweb['version'] + '.' + keymanweb['build'] + '<br /><br />'
                        + '<span style="font-size:0.8em">Copyright &copy; 2017 SIL International</span>');
                };
                /**
                 * Function     _TitleBarInterior
                 * Scope        Private
                 * Description  Title bar interior formatting and element event handling
                 */
                OSKManager.prototype._TitleBarInterior = function () {
                    var keymanweb = com.keyman.singleton;
                    var util = keymanweb.util;
                    var Ldiv = util._CreateElement('div');
                    var Ls = Ldiv.style;
                    Ls.paddingLeft = '2px';
                    Ls.cursor = 'move';
                    Ls.background = '#ad4a28';
                    Ls.font = '8pt Tahoma,Arial,sans-serif'; //I2186
                    // Add container for buttons, handle mousedown event
                    var LdivButtons = util._CreateElement('div');
                    LdivButtons.className = 'kmw-title-bar-actions';
                    LdivButtons.onmousedown = util._CancelMouse;
                    // Add close button, handle click and mousedown events
                    var Limg = util._CreateElement('div');
                    Limg.className = 'kmw-close-button';
                    Limg.onmousedown = util._CancelMouse;
                    Limg.onclick = function () {
                        this._Hide(true);
                    }.bind(this);
                    this.closeButton = Limg;
                    LdivButtons.appendChild(Limg);
                    // Add 'Unpin' button for restoring OSK to default location, handle mousedown and click events
                    Limg = this.pinImg = util._CreateElement('div'); //I2186
                    Limg.className = 'kmw-pin-image';
                    Limg.title = 'Pin the On Screen Keyboard to its default location on the active text box';
                    Limg.onclick = this.restorePosition;
                    Limg.onmousedown = util._CancelMouse;
                    Limg.style.display = 'none';
                    // Do not use Unpin button on touch screens (OSK location fixed)
                    if (!util.device.touchable) {
                        LdivButtons.appendChild(Limg); // I3363 (Build 301)
                    }
                    // Attach button container to title bar
                    Ldiv.appendChild(LdivButtons);
                    // Add title bar caption
                    var Lcap = keymanweb._TitleElement = util._CreateElement('span'); // I1972
                    Lcap.className = 'kmw-title-bar-caption';
                    Lcap.innerHTML = 'KeymanWeb';
                    Ldiv.appendChild(Lcap);
                    return Ldiv;
                };
                // End of TitleBarInterior
                /**
                 * Function     enabled
                 * Scope        Public
                 * @return      {boolean|number}    True if KMW OSK enabled
                 * Description  Test if KMW OSK is enabled
                 */
                OSKManager.prototype['isEnabled'] = function () {
                    return this._Enabled;
                };
                /**
                 * Function     isVisible
                 * Scope        Public
                 * @return      {boolean|number}    True if KMW OSK visible
                 * Description  Test if KMW OSK is actually visible
                 * Note that this will usually return false after any UI event that results in (temporary) loss of input focus
                 */
                OSKManager.prototype['isVisible'] = function () {
                    return this._Visible;
                };
                /**
                 * Save size, position, font size and visibility of OSK
                 */
                OSKManager.prototype.saveCookie = function () {
                    var util = com.keyman.singleton.util;
                    var c = util.loadCookie('KeymanWeb_OnScreenKeyboard');
                    var p = this.getPos();
                    c['visible'] = this._Enabled ? 1 : 0;
                    c['userSet'] = this.userPositioned ? 1 : 0;
                    c['left'] = p.left;
                    c['top'] = p.top;
                    if (this.vkbd) {
                        c['width'] = this.width;
                        c['height'] = this.height;
                    }
                    util.saveCookie('KeymanWeb_OnScreenKeyboard', c);
                };
                /**
                 * Restore size, position, font size and visibility of desktop OSK
                 *
                 *  @return {boolean}
                 */
                OSKManager.prototype.loadCookie = function () {
                    var util = com.keyman.singleton.util;
                    var c = util.loadCookie('KeymanWeb_OnScreenKeyboard');
                    if (typeof (c) == 'undefined' || c == null) {
                        this.userPositioned = false;
                        return false;
                    }
                    this._Enabled = util.toNumber(c['visible'], 1) == 1;
                    this.userPositioned = util.toNumber(c['userSet'], 0) == 1;
                    this.x = util.toNumber(c['left'], -1);
                    this.y = util.toNumber(c['top'], -1);
                    // Restore OSK size - font size now fixed in relation to OSK height, unless overridden (in em) by keyboard
                    var dfltWidth = 0.3 * screen.width;
                    //if(util.toNumber(c['width'],0) == 0) dfltWidth=0.5*screen.width;
                    var newWidth = util.toNumber(c['width'], dfltWidth), newHeight = util.toNumber(c['height'], 0.15 * screen.height);
                    // Limit the OSK dimensions to reasonable values
                    if (newWidth < 0.2 * screen.width) {
                        newWidth = 0.2 * screen.width;
                    }
                    if (newHeight < 0.1 * screen.height) {
                        newHeight = 0.1 * screen.height;
                    }
                    if (newWidth > 0.9 * screen.width) {
                        newWidth = 0.9 * screen.width;
                    }
                    if (newHeight > 0.5 * screen.height) {
                        newHeight = 0.5 * screen.height;
                    }
                    if (this.vkbd) {
                        this.vkbd.kbdDiv.style.width = newWidth + 'px';
                        this.vkbd.kbdDiv.style.height = newHeight + 'px';
                        this.vkbd.kbdDiv.style.fontSize = (newHeight / 8) + 'px';
                    }
                    // and OSK position if user located
                    if (this.x == -1 || this.y == -1 || (!this._Box)) {
                        this.userPositioned = false;
                    }
                    if (this.x < window.pageXOffset - 0.8 * newWidth) {
                        this.x = window.pageXOffset - 0.8 * newWidth;
                    }
                    if (this.y < 0) {
                        this.x = -1;
                        this.y = -1;
                        this.userPositioned = false;
                    }
                    if (this.userPositioned && this._Box) {
                        this.setPos({ 'left': this.x, 'top': this.y });
                    }
                    return true;
                };
                OSKManager.prototype.getWidthFromCookie = function () {
                    var util = com.keyman.singleton.util;
                    var c = util.loadCookie('KeymanWeb_OnScreenKeyboard');
                    if (typeof (c) == 'undefined' || c == null) {
                        return screen.width * 0.3;
                    }
                    // Restore OSK size - font size now fixed in relation to OSK height, unless overridden (in em) by keyboard
                    var newWidth = util.toNumber(c['width'], 0.3 * screen.width); // Default - 30% of screen's width.
                    if (newWidth < 0.2 * screen.width) {
                        newWidth = 0.2 * screen.width;
                    }
                    else if (newWidth > 0.9 * screen.width) {
                        newWidth = 0.9 * screen.width;
                    }
                    return newWidth;
                };
                /**
                 * Get the wanted height of the banner (does not include the keyboard)
                 *  @return   {number}    height in pixels
                 */
                OSKManager.prototype.getBannerHeight = function () {
                    return (this.banner != null) ? this.banner.height : 0;
                };
                /**
                 * Get the wanted height of the OSK for touch devices (does not include banner height)
                 *  @return   {number}    height in pixels
                 **/
                OSKManager.prototype.getKeyboardHeight = function () {
                    var keymanweb = com.keyman.singleton;
                    var device = keymanweb.util.device;
                    // KeymanTouch - get OSK height from device
                    if (typeof (keymanweb['getOskHeight']) == 'function') {
                        return keymanweb['getOskHeight']();
                    }
                    var oskHeightLandscapeView = Math.floor(Math.min(screen.availHeight, screen.availWidth) / 2), height = oskHeightLandscapeView;
                    if (device.formFactor == 'phone') {
                        var sx = Math.min(screen.height, screen.width), sy = Math.max(screen.height, screen.width);
                        if (keymanweb.util.portraitView())
                            height = Math.floor(Math.max(screen.availHeight, screen.availWidth) / 3);
                        else
                            height = height * (sy / sx) / 1.6; //adjust for aspect ratio, increase slightly for iPhone 5
                    }
                    // Correct for viewport scaling (iOS - Android 4.2 does not want this, at least on Galaxy Tab 3))
                    if (device.OS == 'iOS') {
                        height = height / keymanweb.util.getViewportScale();
                    }
                    // Correct for devicePixelratio - needed on Android 4.1.2 phones,
                    // for Opera, Chrome and Firefox, but not for native browser!   Exclude native browser for Build 344.
                    if (device.OS == 'Android' && device.formFactor == 'phone' && 'devicePixelRatio' in window) {
                        var bMatch = /Firefox|Chrome|OPR/;
                        if (bMatch.test(navigator.userAgent)) {
                            height = height * window.devicePixelRatio;
                        }
                    }
                    return height;
                };
                /**
                 * Get the wanted height of the OSK for touch devices (banner height + rows of keys)
                 *  @return   {number}    height in pixels
                 **/
                OSKManager.prototype.getHeight = function () {
                    return this.getBannerHeight() + this.getKeyboardHeight();
                };
                /**
                 * Get the wanted width of the OSK for touch devices
                 *
                 *  @return   {number}    height in pixels
                 **/
                OSKManager.prototype.getWidth = function () {
                    var keymanweb = com.keyman.singleton;
                    var device = keymanweb.util.device;
                    // KeymanTouch - get OSK height from device
                    if (typeof (keymanweb['getOskWidth']) == 'function') {
                        return keymanweb['getOskWidth']();
                    }
                    var width;
                    if (device.OS == 'iOS') {
                        // iOS does not interchange these values when the orientation changes!
                        //width = util.portraitView() ? screen.width : screen.height;
                        width = window.innerWidth;
                    }
                    else if (device.OS == 'Android') {
                        try {
                            width = document.documentElement.clientWidth;
                        }
                        catch (ex) {
                            width = screen.availWidth;
                        }
                    }
                    else {
                        width = screen.width;
                    }
                    return width;
                };
                /**
                 * Allow UI to update OSK position and properties
                 *
                 * @param       {Object=}     p       object with coordinates and userdefined flag
                 *
                 */
                OSKManager.prototype.doResizeMove = function (p) {
                    return com.keyman.singleton.util.callEvent('osk.resizemove', p);
                };
                /**
                 * Function     getRect //TODO:  This is probably not correct, anyway!!!!!
                 * Scope        Public
                 * @return      {Object.<string,number>}   Array object with position and size of OSK container
                 * Description  Get rectangle containing KMW Virtual Keyboard
                 */
                OSKManager.prototype['getRect'] = function () {
                    var util = com.keyman.singleton.util;
                    var p = {};
                    if (this.vkbd) {
                        p['left'] = p.left = keyman.dom.Utils.getAbsoluteX(this.vkbd.kbdDiv);
                        p['top'] = p.top = keyman.dom.Utils.getAbsoluteY(this.vkbd.kbdDiv);
                        p['width'] = p.width = keyman.dom.Utils.getAbsoluteX(this.vkbd.kbdHelpDiv) -
                            keyman.dom.Utils.getAbsoluteX(this.vkbd.kbdDiv) + this.vkbd.kbdHelpDiv.offsetWidth;
                        p['height'] = p.height = keyman.dom.Utils.getAbsoluteY(this.vkbd.kbdHelpDiv) -
                            keyman.dom.Utils.getAbsoluteY(this.vkbd.kbdDiv) + this.vkbd.kbdHelpDiv.offsetHeight;
                    }
                    else {
                        p['left'] = p.left = keyman.dom.Utils.getAbsoluteX(this._Box);
                        p['top'] = p.top = keyman.dom.Utils.getAbsoluteY(this._Box);
                        p['width'] = p.width = keyman.dom.Utils.getAbsoluteX(this._Box) + this._Box.offsetWidth;
                        p['height'] = p.height = keyman.dom.Utils.getAbsoluteY(this._Box) + this._Box.offsetHeight;
                    }
                    return p;
                };
                /**
                 * Allow the UI or page to set the position and size of the OSK
                 * and (optionally) override user repositioning or sizing
                 *
                 * @param       {Object.<string,number>}   p  Array object with position and size of OSK container
                **/
                OSKManager.prototype['setRect'] = function (p) {
                    var util = com.keyman.singleton.util;
                    if (this._Box == null || util.device.formFactor != 'desktop') {
                        return;
                    }
                    var b = this._Box, bs = b.style;
                    if ('left' in p) {
                        bs.left = (p['left'] - keyman.dom.Utils.getAbsoluteX(b) + b.offsetLeft) + 'px';
                        this.dfltX = bs.left;
                    }
                    if ('top' in p) {
                        bs.top = (p['top'] - keyman.dom.Utils.getAbsoluteY(b) + b.offsetTop) + 'px';
                        this.dfltY = bs.top;
                    }
                    //Do not allow user resizing for non-standard keyboards (e.g. EuroLatin)
                    if (this.vkbd != null) {
                        var d = this.vkbd.kbdDiv, ds = d.style;
                        // Set width, but limit to reasonable value
                        if ('width' in p) {
                            var w = (p['width'] - (b.offsetWidth - d.offsetWidth));
                            if (w < 0.2 * screen.width) {
                                w = 0.2 * screen.width;
                            }
                            if (w > 0.9 * screen.width) {
                                w = 0.9 * screen.width;
                            }
                            ds.width = w + 'px';
                            this.width = w;
                        }
                        // Set height, but limit to reasonable value
                        // This sets the default font size for the OSK in px, but that
                        // can be modified at the key text level by setting
                        // the font size in em in the kmw-key-text class
                        if ('height' in p) {
                            var h = (p['height'] - (b.offsetHeight - d.offsetHeight));
                            if (h < 0.1 * screen.height) {
                                h = 0.1 * screen.height;
                            }
                            if (h > 0.5 * screen.height) {
                                h = 0.5 * screen.height;
                            }
                            ds.height = h + 'px';
                            ds.fontSize = (h / 8) + 'px';
                            this.height = h;
                        }
                        // Fix or release user resizing
                        if ('nosize' in p) {
                            if (this.resizeIcon) {
                                this.resizeIcon.style.display = (p['nosize'] ? 'none' : 'block');
                            }
                        }
                    }
                    // Fix or release user dragging
                    if ('nomove' in p) {
                        this.noDrag = p['nomove'];
                        if (this.pinImg) {
                            this.pinImg.style.display = (p['nomove'] || !this.userPositioned) ? 'none' : 'block';
                        }
                    }
                    // Save the user-defined OSK size
                    this.saveCookie();
                };
                /**
                 * Get position of OSK window
                 *
                 * @return      {Object.<string,number>}     Array object with OSK window position
                **/
                OSKManager.prototype.getPos = function () {
                    var Lkbd = this._Box, p = {
                        left: this._Visible ? Lkbd.offsetLeft : this.x,
                        top: this._Visible ? Lkbd.offsetTop : this.y
                    };
                    return p;
                };
                /**
                 * Function     setPos
                 * Scope        Private
                 * @param       {Object.<string,number>}    p     Array object with OSK left, top
                 * Description  Set position of OSK window, but limit to screen, and ignore if  a touch input device
                 */
                OSKManager.prototype['setPos'] = function (p) {
                    if (typeof (this._Box) == 'undefined' || com.keyman.singleton.util.device.touchable) {
                        return; // I3363 (Build 301)
                    }
                    if (this.userPositioned) {
                        var Px = p['left'], Py = p['top'];
                        if (typeof (Px) != 'undefined') {
                            if (Px < -0.8 * this._Box.offsetWidth) {
                                Px = -0.8 * this._Box.offsetWidth;
                            }
                            if (this.userPositioned) {
                                this._Box.style.left = Px + 'px';
                                this.x = Px;
                            }
                        }
                        // May not be needed - vertical positioning is handled differently and defaults to input field if off screen
                        if (typeof (Py) != 'undefined') {
                            if (Py < 0) {
                                Py = 0;
                            }
                            if (this.userPositioned) {
                                this._Box.style.top = Py + 'px';
                                this.y = Py;
                            }
                        }
                    }
                    if (this.pinImg) {
                        this.pinImg.style.display = (this.userPositioned ? 'block' : 'none');
                    }
                };
                /**
                 * Display KMW OSK at specified position (returns nothing)
                 *
                 * @param       {number=}     Px      x-coordinate for OSK rectangle
                 * @param       {number=}     Py      y-coordinate for OSK rectangle
                 */
                OSKManager.prototype._Show = function (Px, Py) {
                    var keymanweb = com.keyman.singleton;
                    var device = keymanweb.util.device;
                    // Do not try to display OSK if undefined, or no active element
                    if (this._Box == null || keymanweb.domManager.getActiveElement() == null) {
                        return;
                    }
                    // Never display the OSK for desktop browsers unless KMW element is focused, and a keyboard selected
                    if ((!device.touchable) && (keymanweb.keyboardManager.activeKeyboard == null || !this._Enabled)) {
                        return;
                    }
                    var Ls = this._Box.style;
                    // Do not display OSK until it has been positioned correctly
                    if (device.touchable && Ls.bottom == '') {
                        Ls.visibility = 'hidden';
                    }
                    if (device.touchable) {
                        /* In case it's still '0' from a hide() operation.
                         * Happens when _Show is called before the transitionend events are processed,
                         * which can happen in bulk-rendering contexts.
                         *
                         * (Opacity is only modified when device.touchable = true, though a couple of extra
                         * conditions may apply.)
                         */
                        Ls.opacity = '1';
                    }
                    // TODO:  Move this into the VisualKeyboard class!
                    // The following code will always be executed except for externally created OSK such as EuroLatin
                    if (this.vkbd && this.vkbd.ddOSK) {
                        // Enable the currently active keyboard layer and update the default nextLayer member
                        this.vkbd.show();
                        // Extra style changes and overrides for touch-mode.
                        if (device.touchable) {
                            Ls.position = 'fixed';
                            Ls.left = Ls.bottom = '0px';
                            var vkbdHeight = this.vkbd.kbdDiv.firstChild.style.height;
                            vkbdHeight = vkbdHeight.substr(0, vkbdHeight.indexOf('px'));
                            Ls.height = Ls.maxHeight = (this.getBannerHeight() + parseInt(vkbdHeight, 10) + 5 /* kmw-banner-bar top in css */) + 'px';
                            Ls.border = 'none';
                            Ls.borderTop = '1px solid gray';
                            this._Enabled = true;
                            this._Visible = true; // I3363 (Build 301)
                        }
                    }
                    //TODO: may need to return here for touch devices??
                    Ls.display = 'block'; //Ls.visibility='visible';
                    if (this.vkbd) {
                        this.vkbd.showLanguage();
                    }
                    if (device.formFactor == 'desktop') {
                        Ls.position = 'absolute';
                        Ls.display = 'block'; //Ls.visibility='visible';
                        Ls.left = '0px';
                        this.loadCookie();
                        if (Px >= 0) { //probably never happens, legacy support only
                            Ls.left = Px + 'px';
                            Ls.top = Py + 'px';
                        }
                        else {
                            if (this.userPositioned) {
                                Ls.left = this.x + 'px';
                                Ls.top = this.y + 'px';
                            }
                            else {
                                var el = keymanweb.domManager.getActiveElement();
                                // Special case - design mode iframes.  Don't use the active element (inside the design-mode doc);
                                // use its containing iframe from the doc itself.
                                var ownerDoc = el.ownerDocument;
                                if (ownerDoc.designMode == 'on' && ownerDoc.defaultView && ownerDoc.defaultView.frameElement) {
                                    el = ownerDoc.defaultView.frameElement;
                                }
                                if (this.dfltX) {
                                    Ls.left = this.dfltX;
                                }
                                else if (typeof el != 'undefined' && el != null) {
                                    Ls.left = keyman.dom.Utils.getAbsoluteX(el) + 'px';
                                }
                                if (this.dfltY) {
                                    Ls.top = this.dfltY;
                                }
                                else if (typeof el != 'undefined' && el != null) {
                                    Ls.top = (keyman.dom.Utils.getAbsoluteY(el) + el.offsetHeight) + 'px';
                                }
                            }
                        }
                        this._Enabled = true;
                        this._Visible = true;
                        if (this.vkbd && this.vkbd.kbdDiv) {
                            this.width = this.vkbd.kbdDiv.offsetWidth;
                            this.height = this.vkbd.kbdDiv.offsetHeight;
                        }
                        this.saveCookie();
                        var pin = this.pinImg;
                        if (typeof pin != 'undefined' && pin != null)
                            pin.style.display = this.userPositioned ? 'block' : 'none';
                    }
                    // If OSK still hidden, make visible only after all calculation finished
                    if (Ls.visibility == 'hidden') {
                        window.setTimeout(function () {
                            this._Box.style.visibility = 'visible';
                        }.bind(this), 0);
                    }
                    // Allow desktop UI to execute code when showing the OSK
                    if (!device.touchable) {
                        var Lpos = {};
                        Lpos['x'] = this._Box.offsetLeft;
                        Lpos['y'] = this._Box.offsetTop;
                        Lpos['userLocated'] = this.userPositioned;
                        this.doShow(Lpos);
                    }
                };
                /**
                 * Hide Keymanweb On Screen Keyboard
                 *
                 * @param       {boolean}   hiddenByUser    Distinguish between hiding on loss of focus and explicit hiding by user
                 */
                OSKManager.prototype._Hide = function (hiddenByUser) {
                    var keymanweb = com.keyman.singleton;
                    var device = keymanweb.util.device;
                    // The test for CJK languages is necessary to prevent a picklist (displayed in the OSK) from being hidden by the user
                    // Once picklist functionality is separated out, this will no longer be needed.
                    // Logic is: execute always if hidden on lost focus, but if requested by user, only if not CJK
                    // Save current size if visible
                    if (this._Box && this._Box.style.display == 'block' && this.vkbd && this.vkbd.kbdDiv) {
                        this.width = this.vkbd.kbdDiv.offsetWidth;
                        this.height = this.vkbd.kbdDiv.offsetHeight;
                    }
                    if (hiddenByUser) {
                        //osk.loadCookie(); // preserve current offset and userlocated state
                        this._Enabled = ((keymanweb.keyboardManager.isCJK() || device.touchable) ? true : false); // I3363 (Build 301)
                        this.saveCookie(); // Save current OSK state, size and position (desktop only)
                    }
                    else if (device.formFactor == 'desktop') {
                        //Allow desktop OSK to remain visible on blur if body class set
                        if (document.body.className.indexOf('osk-always-visible') >= 0) {
                            return;
                        }
                    }
                    this._Visible = false;
                    if (this._Box && device.touchable && this._Box.offsetHeight > 0) { // I3363 (Build 301)
                        var os = this._Box.style;
                        //Firefox doesn't transition opacity if start delay is explicitly set to 0!
                        if (typeof (os.MozBoxSizing) == 'string') {
                            os.transition = 'opacity 0.8s linear';
                        }
                        else {
                            os.transition = os.msTransition = os.WebkitTransition = 'opacity 0.5s linear 0';
                        }
                        // Cannot hide the OSK smoothly using a transitioned drop, since for
                        // position:fixed elements transitioning is incompatible with translate3d(),
                        // and also does not work with top, bottom or height styles.
                        // Opacity can be transitioned and is probably the simplest alternative.
                        // We must condition on osk._Visible in case focus has since been moved to another
                        // input (in which case osk._Visible will be non-zero)
                        window.setTimeout(function () {
                            var os = this._Box.style;
                            if (this._Visible) {
                                // Leave opacity alone and clear transition if another element activated
                                os.transition = os.msTransition = os.MozTransition = os.WebkitTransition = '';
                            }
                            else {
                                // Set opacity to zero, should decrease smoothly
                                os.opacity = '0';
                                // Actually hide the OSK at the end of the transition
                                this._Box.addEventListener('transitionend', this.hideNow, false);
                                this._Box.addEventListener('webkitTransitionEnd', this.hideNow, false);
                            }
                        }.bind(this), 200); // Wait a bit before starting, to allow for moving to another element
                    }
                    else {
                        if (this._Box) {
                            this._Box.style.display = 'none';
                        }
                    }
                    // Allow UI to execute code when hiding the OSK
                    var p = {};
                    p['HiddenByUser'] = hiddenByUser;
                    this.doHide(p);
                    // If hidden by the UI, be sure to restore the focus
                    if (hiddenByUser) {
                        keymanweb.domManager.focusLastActiveElement();
                    }
                };
                /**
                 * Function     hide
                 * Scope        Public
                 * Description  Prevent display of OSK window on focus
                 */
                OSKManager.prototype['hide'] = function () {
                    this._Enabled = false;
                    this._Hide(true);
                };
                /**
                 * Allow UI to respond to OSK being shown (passing position and properties)
                 *
                 * @param       {Object=}       p     object with coordinates and userdefined flag
                 * @return      {boolean}
                 *
                 */
                OSKManager.prototype.doShow = function (p) {
                    return com.keyman.singleton.util.callEvent('osk.show', p);
                };
                /**
                 * Allow UI to update respond to OSK being hidden
                 *
                 * @param       {Object=}       p     object with coordinates and userdefined flag
                 * @return      {boolean}
                 *
                 */
                OSKManager.prototype.doHide = function (p) {
                    return com.keyman.singleton.util.callEvent('osk.hide', p);
                };
                /**
                 * Display list of installed keyboards in pop-up menu
                 **/
                OSKManager.prototype.showLanguageMenu = function () {
                    var menu = new osk.LanguageMenu(com.keyman.singleton);
                    menu.show();
                };
                /**
                 * Function     userPositioned
                 * Scope        Public
                 * @return      {(boolean|number)}          true if user located
                 * Description  Test if OSK window has been repositioned by user
                 */
                OSKManager.prototype['userLocated'] = function () {
                    return this.userPositioned;
                };
                /**
                 * Description  Display KMW OSK (at position set in callback to UI)
                 * Function     show
                 * Scope        Public
                 * @param       {(boolean|number)=}      bShow     True to display, False to hide, omitted to toggle
                 */
                OSKManager.prototype['show'] = function (bShow) {
                    if (arguments.length > 0) {
                        this._Enabled = bShow;
                        if (bShow) {
                            this._Show();
                        }
                        else {
                            this._Hide(true);
                        }
                    }
                    else {
                        if (this._Visible) {
                            this._Hide(true);
                        }
                        else {
                            this._Show();
                        }
                    }
                };
                /**
                 * Function     addEventListener
                 * Scope        Public
                 * @param       {string}            event     event name
                 * @param       {function(Object)}  func      event handler
                 * @return      {boolean}
                 * Description  Wrapper function to add and identify OSK-specific event handlers
                 */
                OSKManager.prototype['addEventListener'] = function (event, func) {
                    return com.keyman.singleton.util.addEventListener('osk.' + event, func);
                };
                OSKManager.prototype['shutdown'] = function () {
                    // Remove the OSK's elements from the document, allowing them to be properly cleaned up.
                    // Necessary for clean engine testing.
                    var _box = this._Box;
                    if (_box.parentElement) {
                        _box.parentElement.removeChild(_box);
                    }
                };
                return OSKManager;
            }());
            osk.OSKManager = OSKManager;
        })(osk = keyman.osk || (keyman.osk = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Autogenerated code. Do not modify!
function LMLayerWorkerCode() {
    /*! https://mths.be/codepointat v0.2.0 by @mathias */
    if (!String.prototype.codePointAt) {
        (function () {
            'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
            var defineProperty = (function () {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                }
                catch (error) { }
                return result;
            }());
            var codePointAt = function (position) {
                if (this == null) {
                    throw TypeError();
                }
                var string = String(this);
                var size = string.length;
                // `ToInteger`
                var index = position ? Number(position) : 0;
                if (index != index) { // better `isNaN`
                    index = 0;
                }
                // Account for out-of-bounds indices:
                if (index < 0 || index >= size) {
                    return undefined;
                }
                // Get the first code unit
                var first = string.charCodeAt(index);
                var second;
                if ( // check if it’s the start of a surrogate pair
                first >= 0xD800 && first <= 0xDBFF && // high surrogate
                    size > index + 1 // there is a next code unit
                ) {
                    second = string.charCodeAt(index + 1);
                    if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
                        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                    }
                }
                return first;
            };
            if (defineProperty) {
                defineProperty(String.prototype, 'codePointAt', {
                    'value': codePointAt,
                    'configurable': true,
                    'writable': true
                });
            }
            else {
                String.prototype.codePointAt = codePointAt;
            }
        }());
    }
    /*! http://mths.be/startswith v0.2.0 by @mathias */
    if (!String.prototype.startsWith) {
        (function () {
            'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
            var defineProperty = (function () {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                }
                catch (error) { }
                return result;
            }());
            var toString = {}.toString;
            var startsWith = function (search) {
                if (this == null) {
                    throw TypeError();
                }
                var string = String(this);
                if (search && toString.call(search) == '[object RegExp]') {
                    throw TypeError();
                }
                var stringLength = string.length;
                var searchString = String(search);
                var searchLength = searchString.length;
                var position = arguments.length > 1 ? arguments[1] : undefined;
                // `ToInteger`
                var pos = position ? Number(position) : 0;
                if (pos != pos) { // better `isNaN`
                    pos = 0;
                }
                var start = Math.min(Math.max(pos, 0), stringLength);
                // Avoid the `indexOf` call if no match is possible
                if (searchLength + start > stringLength) {
                    return false;
                }
                var index = -1;
                while (++index < searchLength) {
                    if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
                        return false;
                    }
                }
                return true;
            };
            if (defineProperty) {
                defineProperty(String.prototype, 'startsWith', {
                    'value': startsWith,
                    'configurable': true,
                    'writable': true
                });
            }
            else {
                String.prototype.startsWith = startsWith;
            }
        }());
    }
    // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from
    // Any npm-based ones require use of `require`, which won't work for us.
    // Production steps of ECMA-262, Edition 6, 22.1.2.1
    if (!Array.from) {
        Array.from = (function () {
            var toStr = Object.prototype.toString;
            var isCallable = function (fn) {
                return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
            };
            var toInteger = function (value) {
                var number = Number(value);
                if (isNaN(number)) {
                    return 0;
                }
                if (number === 0 || !isFinite(number)) {
                    return number;
                }
                return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
            };
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var toLength = function (value) {
                var len = toInteger(value);
                return Math.min(Math.max(len, 0), maxSafeInteger);
            };
            // The length property of the from method is 1.
            return function from(arrayLike /*, mapFn, thisArg */) {
                // 1. Let C be the this value.
                var C = this;
                // 2. Let items be ToObject(arrayLike).
                var items = Object(arrayLike);
                // 3. ReturnIfAbrupt(items).
                if (arrayLike == null) {
                    throw new TypeError('Array.from requires an array-like object - not null or undefined');
                }
                // 4. If mapfn is undefined, then let mapping be false.
                var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
                var T;
                if (typeof mapFn !== 'undefined') {
                    // 5. else
                    // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
                    if (!isCallable(mapFn)) {
                        throw new TypeError('Array.from: when provided, the second argument must be a function');
                    }
                    // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
                    if (arguments.length > 2) {
                        T = arguments[2];
                    }
                }
                // 10. Let lenValue be Get(items, "length").
                // 11. Let len be ToLength(lenValue).
                var len = toLength(items.length);
                // 13. If IsConstructor(C) is true, then
                // 13. a. Let A be the result of calling the [[Construct]] internal method 
                // of C with an argument list containing the single item len.
                // 14. a. Else, Let A be ArrayCreate(len).
                var A = isCallable(C) ? Object(new C(len)) : new Array(len);
                // 16. Let k be 0.
                var k = 0;
                // 17. Repeat, while k < len… (also steps a - h)
                var kValue;
                while (k < len) {
                    kValue = items[k];
                    if (mapFn) {
                        A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                    }
                    else {
                        A[k] = kValue;
                    }
                    k += 1;
                }
                // 18. Let putStatus be Put(A, "length", len, true).
                A.length = len;
                // 20. Return A.
                return A;
            };
        }());
    }
    /***
       KeymanWeb 11.0
       Copyright 2019 SIL International
    ***/
    /**
     * Constructs a string from one or more Unicode character codepoint values
     * passed as integer parameters.
     *
     * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
     * @return {string|null}      The new String object.
     */
    String.kmwFromCharCode = function (cp0) {
        var chars = [], i;
        for (i = 0; i < arguments.length; i++) {
            var c = Number(arguments[i]);
            if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
                throw new RangeError("Invalid code point " + c);
            }
            if (c < 0x10000) {
                chars.push(c);
            }
            else {
                c -= 0x10000;
                chars.push((c >> 10) + 0xD800);
                chars.push((c % 0x400) + 0xDC00);
            }
        }
        return String.fromCharCode.apply(undefined, chars);
    };
    /**
     * Returns a number indicating the Unicode value of the character at the given
     * code point index, with support for supplementary plane characters.
     *
     * @param  {number}  codePointIndex  The code point index into the string (not
                                         the code unit index) to return
     * @return {number}                  The Unicode character value
     */
    String.prototype.kmwCharCodeAt = function (codePointIndex) {
        var str = String(this);
        var codeUnitIndex = 0;
        if (codePointIndex < 0 || codePointIndex >= str.length) {
            return NaN;
        }
        for (var i = 0; i < codePointIndex; i++) {
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
            if (codeUnitIndex === null)
                return NaN;
        }
        var first = str.charCodeAt(codeUnitIndex);
        if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
            var second = str.charCodeAt(codeUnitIndex + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
            }
        }
        return first;
    };
    /**
     * Returns the code point index within the calling String object of the first occurrence
     * of the specified value, or -1 if not found.
     *
     * @param  {string}  searchValue    The value to search for
     * @param  {number}  [fromIndex]    Optional code point index to start searching from
     * @return {number}                 The code point index of the specified search value
     */
    String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
        var str = String(this);
        var codeUnitIndex = str.indexOf(searchValue, fromIndex);
        if (codeUnitIndex < 0) {
            return codeUnitIndex;
        }
        var codePointIndex = 0;
        for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
            codePointIndex++;
        return codePointIndex;
    };
    /**
     * Returns the code point index within the calling String object of the last occurrence
     * of the specified value, or -1 if not found.
     *
     * @param  {string}  searchValue    The value to search for
     * @param  {number}  fromIndex      Optional code point index to start searching from
     * @return {number}                 The code point index of the specified search value
     */
    String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
        var str = String(this);
        var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
        if (codeUnitIndex < 0) {
            return codeUnitIndex;
        }
        var codePointIndex = 0;
        for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
            codePointIndex++;
        return codePointIndex;
    };
    /**
     * Returns the length of the string in code points, as opposed to code units.
     *
     * @return {number}                 The length of the string in code points
     */
    String.prototype.kmwLength = function () {
        var str = String(this);
        if (str.length == 0)
            return 0;
        for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        return i;
    };
    /**
     * Extracts a section of a string and returns a new string.
     *
     * @param  {number}  beginSlice    The start code point index in the string to
     *                                 extract from
     * @param  {number}  endSlice      Optional end code point index in the string
     *                                 to extract to
     * @return {string}                The substring as selected by beginSlice and
     *                                 endSlice
     */
    String.prototype.kmwSlice = function (beginSlice, endSlice) {
        var str = String(this);
        var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
        var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
        if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
            return '';
        else
            return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
    };
    /**
     * Returns the characters in a string beginning at the specified location through
     * the specified number of characters.
     *
     * @param  {number}  start         The start code point index in the string to
     *                                 extract from
     * @param  {number=}  length        Optional length to extract
     * @return {string}                The substring as selected by start and length
     */
    String.prototype.kmwSubstr = function (start, length) {
        var str = String(this);
        if (start < 0) {
            start = str.kmwLength() + start;
        }
        if (start < 0)
            start = 0;
        var startCodeUnit = str.kmwCodePointToCodeUnit(start);
        var endCodeUnit = startCodeUnit;
        if (startCodeUnit === null)
            return '';
        if (arguments.length < 2) {
            endCodeUnit = str.length;
        }
        else {
            for (var i = 0; i < length; i++)
                endCodeUnit = str.kmwNextChar(endCodeUnit);
        }
        if (endCodeUnit === null)
            return str.substring(startCodeUnit);
        else
            return str.substring(startCodeUnit, endCodeUnit);
    };
    /**
     * Returns the characters in a string between two indexes into the string.
     *
     * @param  {number}  indexA        The start code point index in the string to
     *                                 extract from
     * @param  {number}  indexB        The end code point index in the string to
     *                                 extract to
     * @return {string}                The substring as selected by indexA and indexB
     */
    String.prototype.kmwSubstring = function (indexA, indexB) {
        var str = String(this), indexACodeUnit, indexBCodeUnit;
        if (typeof (indexB) == 'undefined') {
            indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
            indexBCodeUnit = str.length;
        }
        else {
            if (indexA > indexB) {
                var c = indexA;
                indexA = indexB;
                indexB = c;
            }
            indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
            indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
        }
        if (isNaN(indexACodeUnit) || indexACodeUnit === null)
            indexACodeUnit = 0;
        if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
            indexBCodeUnit = str.length;
        return str.substring(indexACodeUnit, indexBCodeUnit);
    };
    /*
      Helper functions
    */
    /**
     * Returns the code unit index for the next code point in the string, accounting for
     * supplementary pairs
     *
     * @param  {number|null}  codeUnitIndex  The code unit position to increment
     * @return {number|null}                 The index of the next code point in the string,
     *                                       in code units
     */
    String.prototype.kmwNextChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
            return null;
        }
        var first = str.charCodeAt(codeUnitIndex);
        if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
            var second = str.charCodeAt(codeUnitIndex + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                if (codeUnitIndex == str.length - 2) {
                    return null;
                }
                return codeUnitIndex + 2;
            }
        }
        return codeUnitIndex + 1;
    };
    /**
     * Returns the code unit index for the previous code point in the string, accounting
     * for supplementary pairs
     *
     * @param  {number|null}  codeUnitIndex  The code unit position to decrement
     * @return {number|null}                 The index of the previous code point in the
     *                                       string, in code units
    */
    String.prototype.kmwPrevChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
            return null;
        }
        var second = str.charCodeAt(codeUnitIndex - 1);
        if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
            var first = str.charCodeAt(codeUnitIndex - 2);
            if (first >= 0xD800 && first <= 0xDBFF) {
                return codeUnitIndex - 2;
            }
        }
        return codeUnitIndex - 1;
    };
    /**
     * Returns the corresponding code unit index to the code point index passed
     *
     * @param  {number|null} codePointIndex  A code point index in the string
     * @return {number|null}                 The corresponding code unit index
     */
    String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
        if (codePointIndex === null)
            return null;
        var str = String(this);
        var codeUnitIndex = 0;
        if (codePointIndex < 0) {
            codeUnitIndex = str.length;
            for (var i = 0; i > codePointIndex; i--)
                codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
            return codeUnitIndex;
        }
        if (codePointIndex == str.kmwLength())
            return str.length;
        for (var i = 0; i < codePointIndex; i++)
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        return codeUnitIndex;
    };
    /**
     * Returns the corresponding code point index to the code unit index passed
     *
     * @param  {number|null}  codeUnitIndex  A code unit index in the string
     * @return {number|null}                 The corresponding code point index
     */
    String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex === null)
            return null;
        else if (codeUnitIndex == 0)
            return 0;
        else if (codeUnitIndex < 0)
            return str.substr(codeUnitIndex).kmwLength();
        else
            return str.substr(0, codeUnitIndex).kmwLength();
    };
    /**
     * Returns the character at a the code point index passed
     *
     * @param  {number}  codePointIndex  A code point index in the string
     * @return {string}                  The corresponding character
     */
    String.prototype.kmwCharAt = function (codePointIndex) {
        var str = String(this);
        if (codePointIndex >= 0)
            return str.kmwSubstr(codePointIndex, 1);
        else
            return '';
    };
    /**
     * String prototype library extensions for basic plane characters,
     * to simplify enabling or disabling supplementary plane functionality (I3319)
     */
    /**
     * Returns the code unit index for the next code point in the string
     *
     * @param  {number}  codeUnitIndex    A code point index in the string
     * @return {number|null}                   The corresponding character
     */
    String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
            return null;
        }
        return codeUnitIndex + 1;
    };
    /**
     * Returns the code unit index for the previous code point in the string
     *
     * @param  {number}  codeUnitIndex    A code unit index in the string
     * @return {number|null}                   The corresponding character
     */
    String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
            return null;
        }
        return codeUnitIndex - 1;
    };
    /**
     * Returns the code unit index for a code point index
     *
     * @param  {number}  codePointIndex   A code point index in the string
     * @return {number}                   The corresponding character
     */
    String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
        return codePointIndex;
    };
    /**
     * Returns the code point index for a code unit index
     *
     * @param  {number}  codeUnitIndex    A code point index in the string
     * @return {number}                   The corresponding character
     */
    String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
        return codeUnitIndex;
    };
    /**
     * Returns the length of a BMP string
     *
     * @return {number}                   The length in code points
     */
    String.prototype.kmwBMPLength = function () {
        var str = String(this);
        return str.length;
    };
    /**
     * Returns a substring
     *
     * @param  {number}  n
     * @param  {number=}  ln
     * @return {string}
     */
    String.prototype.kmwBMPSubstr = function (n, ln) {
        var str = String(this);
        if (n > -1)
            return str.substr(n, ln);
        else
            return str.substr(str.length + n, -n);
    };
    /**
     * Enable or disable supplementary plane string handling
     *
     * @param  {boolean}  bEnable
     */
    String.kmwEnableSupplementaryPlane = function (bEnable) {
        var p = String.prototype;
        String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
        p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
        p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
        p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
        p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
        p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
        p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
        p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
        p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
        p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
        p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
        p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
        p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
    };
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    var models;
    (function (models) {
        /**
         * @file dummy-model.ts
         *
         * Defines the Dummy model, which is used for testing the
         * prediction API exclusively.
         */
        /**
         * The Dummy Model that returns nonsensical, but predictable results.
         */
        var DummyModel = /** @class */ (function () {
            function DummyModel(options) {
                options = options || {};
                // Create a shallow copy of the suggestions;
                // this class mutates the array.
                this._futureSuggestions = options.futureSuggestions
                    ? options.futureSuggestions.slice() : [];
                if (options.punctuation) {
                    this.punctuation = options.punctuation;
                }
            }
            DummyModel.prototype.configure = function (capabilities) {
                this.configuration = {
                    leftContextCodePoints: capabilities.maxLeftContextCodePoints,
                    rightContextCodePoints: capabilities.maxRightContextCodePoints
                };
                return this.configuration;
            };
            DummyModel.prototype.predict = function (transform, context, injectedSuggestions) {
                var makeUniformDistribution = function (suggestions) {
                    var distribution = [];
                    var n = suggestions.length;
                    for (var _i = 0, suggestions_1 = suggestions; _i < suggestions_1.length; _i++) {
                        var s = suggestions_1[_i];
                        distribution.push({ sample: s, p: 1 }); // For a dummy model, this is sufficient.  The uniformness is all that matters.
                    }
                    return distribution;
                };
                if (injectedSuggestions) {
                    return makeUniformDistribution(injectedSuggestions);
                }
                var currentSet = this._futureSuggestions.shift();
                if (!currentSet) {
                    return [];
                }
                else {
                    return makeUniformDistribution(currentSet);
                }
            };
            DummyModel.prototype.wordbreak = function (context) {
                var words = wordBreakers.default_(context.left);
                if (words.length > 0) {
                    return words.pop().text;
                }
                return '';
            };
            return DummyModel;
        }());
        models.DummyModel = DummyModel;
        ;
    })(models || (models = {}));
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * A concrete span class that derives its properties from the result of
         * RegExp.exec() array.
         */
        var RegExpDerivedSpan = /** @class */ (function () {
            function RegExpDerivedSpan(text, start) {
                this.text = text;
                this.start = start;
            }
            Object.defineProperty(RegExpDerivedSpan.prototype, "length", {
                get: function () {
                    return this.text.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RegExpDerivedSpan.prototype, "end", {
                get: function () {
                    return this.start + this.text.length;
                },
                enumerable: true,
                configurable: true
            });
            return RegExpDerivedSpan;
        }());
        /**
         * Splits ASCII words.
         *
         * @param phrase
         */
        function ascii(phrase) {
            var matchWord = /[A-Za-z0-9']+/g;
            var words = [];
            var match;
            while ((match = matchWord.exec(phrase)) !== null) {
                words.push(new RegExpDerivedSpan(match[0], match.index));
            }
            return words;
        }
        wordBreakers.ascii = ascii;
    })(wordBreakers || (wordBreakers = {}));
    var ModelCompositor = /** @class */ (function () {
        function ModelCompositor(lexicalModel) {
            this.lexicalModel = lexicalModel;
            this.punctuation = ModelCompositor.determinePunctuationFromModel(lexicalModel);
        }
        ModelCompositor.prototype.isWhitespace = function (transform) {
            // Matches prefixed text + any instance of a character with Unicode general property Z* or the following: CR, LF, and Tab.
            var whitespaceRemover = /.*[\u0009\u000A\u000D\u0020\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000]/i;
            // Filter out null-inserts; their high probability can cause issues.
            if (transform.insert == '') { // Can actually register as 'whitespace'.
                return false;
            }
            var insert = transform.insert;
            insert = insert.replace(whitespaceRemover, '');
            return insert == '';
        };
        ModelCompositor.prototype.isBackspace = function (transform) {
            return transform.insert == "" && transform.deleteLeft > 0;
        };
        ModelCompositor.prototype.predict = function (transformDistribution, context) {
            var suggestionDistribution = [];
            var punctuation = this.punctuation;
            // Assumption:  Duplicated 'displayAs' properties indicate duplicated Suggestions.
            // When true, we can use an 'associative array' to de-duplicate everything.
            var suggestionDistribMap = {};
            if (!(transformDistribution instanceof Array)) {
                transformDistribution = [{ sample: transformDistribution, p: 1.0 }];
            }
            // Find the transform for the actual keypress.
            var inputTransform = transformDistribution.sort(function (a, b) {
                return b.p - a.p;
            })[0].sample;
            // Only allow new-word suggestions if space was the most likely keypress.
            var allowSpace = this.isWhitespace(inputTransform);
            var allowBksp = this.isBackspace(inputTransform);
            var postContext = models.applyTransform(inputTransform, context);
            var keepOptionText = this.lexicalModel.wordbreak(postContext);
            var keepOption = null;
            var _loop_1 = function (alt) {
                var transform = alt.sample;
                // Filter out special keys unless they're expected.
                if (this_1.isWhitespace(transform) && !allowSpace) {
                    return "continue";
                }
                else if (this_1.isBackspace(transform) && !allowBksp) {
                    return "continue";
                }
                var preserveWhitespace = false;
                if (this_1.isWhitespace(transform)) {
                    // Detect start of new word; prevent whitespace loss here.
                    var postContext_1 = models.applyTransform(transform, context);
                    preserveWhitespace = (this_1.lexicalModel.wordbreak(postContext_1) == '');
                }
                var distribution = this_1.lexicalModel.predict(transform, context);
                distribution.forEach(function (pair) {
                    // Let's not rely on the model to copy transform IDs.
                    // Only bother is there IS an ID to copy.
                    if (transform.id !== undefined) {
                        pair.sample.transformId = transform.id;
                    }
                    // Prepends the original whitespace, ensuring it is preserved if
                    // the suggestion is accepted.
                    if (preserveWhitespace) {
                        models.prependTransform(pair.sample.transform, transform);
                    }
                    // The model is trying to add a word; thus, add some custom formatting
                    // to that word.
                    if (pair.sample.transform.insert.length > 0) {
                        pair.sample.transform.insert += punctuation.insertAfterWord;
                    }
                    // Combine duplicate samples.
                    var displayText = pair.sample.displayAs;
                    if (displayText == keepOptionText) {
                        keepOption = pair.sample;
                        // Specifying 'keep' helps uses of the LMLayer find it quickly
                        // if/when desired.
                        keepOption.tag = 'keep';
                    }
                    else {
                        var existingSuggestion = suggestionDistribMap[displayText];
                        if (existingSuggestion) {
                            existingSuggestion.p += pair.p * alt.p;
                        }
                        else {
                            var compositedPair = { sample: pair.sample, p: pair.p * alt.p };
                            suggestionDistribMap[displayText] = compositedPair;
                        }
                    }
                });
            };
            var this_1 = this;
            for (var _i = 0, transformDistribution_1 = transformDistribution; _i < transformDistribution_1.length; _i++) {
                var alt = transformDistribution_1[_i];
                _loop_1(alt);
            }
            // Generate a default 'keep' option if one was not otherwise produced.
            if (!keepOption && keepOptionText != '') {
                keepOption = {
                    displayAs: keepOptionText,
                    transformId: inputTransform.id,
                    // Replicate the original transform, modified for appropriate language insertion syntax.
                    transform: {
                        insert: inputTransform.insert + punctuation.insertAfterWord,
                        deleteLeft: inputTransform.deleteLeft,
                        deleteRight: inputTransform.deleteRight,
                        id: inputTransform.id
                    },
                    tag: 'keep'
                };
            }
            // Add the surrounding quotes to the "keep" option's display string:
            if (keepOption) {
                var _a = punctuation.quotesForKeepSuggestion, open = _a.open, close_1 = _a.close;
                // Should we also ensure that we're using the default quote marks first?
                // Or is it reasonable to say that the "left" mark is always the one
                // called "open"?
                if (!punctuation.isRTL) {
                    keepOption.displayAs = open + keepOption.displayAs + close_1;
                }
                else {
                    keepOption.displayAs = close_1 + keepOption.displayAs + open;
                }
            }
            // Now that we've calculated a unique set of probability masses, time to make them into a proper
            // distribution and prep for return.
            for (var key in suggestionDistribMap) {
                var pair = suggestionDistribMap[key];
                suggestionDistribution.push(pair);
            }
            suggestionDistribution = suggestionDistribution.sort(function (a, b) {
                return b.p - a.p; // Use descending order - we want the largest probabilty suggestions first!
            });
            var suggestions = suggestionDistribution.splice(0, ModelCompositor.MAX_SUGGESTIONS).map(function (value) {
                return value.sample;
            });
            if (keepOption) {
                suggestions = [keepOption].concat(suggestions);
            }
            return suggestions;
        };
        /**
         * Returns the punctuation used for this model, filling out unspecified fields
         */
        ModelCompositor.determinePunctuationFromModel = function (model) {
            var defaults = DEFAULT_PUNCTUATION;
            // Use the defaults of the model does not provide any punctuation at all.
            if (!model.punctuation)
                return defaults;
            var specifiedPunctuation = model.punctuation;
            var insertAfterWord = specifiedPunctuation.insertAfterWord;
            if (insertAfterWord !== '' && !insertAfterWord) {
                insertAfterWord = defaults.insertAfterWord;
            }
            var quotesForKeepSuggestion = specifiedPunctuation.quotesForKeepSuggestion;
            if (!quotesForKeepSuggestion) {
                quotesForKeepSuggestion = defaults.quotesForKeepSuggestion;
            }
            var isRTL = specifiedPunctuation.isRTL;
            // Default:  false / undefined, so no need to directly specify it.
            return {
                insertAfterWord: insertAfterWord, quotesForKeepSuggestion: quotesForKeepSuggestion, isRTL: isRTL
            };
        };
        ModelCompositor.MAX_SUGGESTIONS = 12;
        return ModelCompositor;
    }());
    /**
     * The default punctuation and spacing produced by the model.
     */
    var DEFAULT_PUNCTUATION = {
        quotesForKeepSuggestion: { open: "\u201C", close: "\u201D" },
        insertAfterWord: " ",
    };
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    var __assign = (this && this.__assign) || function () {
        __assign = Object.assign || function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    /**
     * @file index.ts
     *
     * The main LMLayerWorker class, the top-level class within the Web Worker.
     * The LMLayerWorker handles the keyboard/worker communication
     * protocol, delegating prediction requests to the language
     * model implementations.
     */
    /// <reference path="../message.d.ts" />
    /// <reference path="../../../web/source/text/kmwstring.ts" />
    /// <reference path="models/dummy-model.ts" />
    /// <reference path="word_breaking/ascii-word-breaker.ts" />
    /// <reference path="./model-compositor.ts" />
    /**
     * Encapsulates all the state required for the LMLayer's worker thread.
     *
     * Implements the state pattern. There are three states:
     *
     *  - `unconfigured`  (initial state before configuration)
     *  - `modelless`     (state without model loaded)
     *  - `ready`         (state with model loaded, accepts prediction requests)
     *
     * Transitions are initiated by valid messages. Invalid
     * messages are errors, and do not lead to transitions.
     *
     *          +-------------+    load    +---------+
     *   config |             |----------->|         |
     *  +------->  modelless  +            +  ready  +---+
     *          |             |<-----------|         |   |
     *          +-------------+   unload   +----^----+   | predict
     *                                          |        |
     *                                          +--------+
     *
     * The model and the configuration are ONLY relevant in the `ready` state;
     * as such, they are NOT direct properties of the LMLayerWorker.
     */
    var LMLayerWorker = /** @class */ (function () {
        function LMLayerWorker(options) {
            if (options === void 0) {
                options = {
                    importScripts: null,
                    postMessage: null
                };
            }
            this._postMessage = options.postMessage || postMessage;
            this._importScripts = options.importScripts || importScripts;
            this.setupConfigState();
        }
        LMLayerWorker.prototype.error = function (message, error) {
            // error isn't a fan of being cloned across the worker boundary.
            this.cast('error', {
                log: message,
                error: (error && error.stack) ? error.stack : undefined
            });
        };
        /**
         * A function that can be set as self.onmessage (the Worker
         * message handler).
         * NOTE! You must bind it to a specific instance, e.g.:
         *
         *   // Do this!
         *   self.onmessage = worker.onMessage.bind(worker);
         *
         * Incorrect:
         *
         *   // Don't do this!
         *   self.onmessage = worker.onMessage;
         *
         * See: .install();
         */
        LMLayerWorker.prototype.onMessage = function (event) {
            var message = event.data.message;
            // Ensure the message is tagged with a valid message tag.
            if (!message) {
                throw new Error("Missing required 'message' property: " + event.data);
            }
            // If last load was for this exact model file, squash the message.
            // (Though not if we've had an unload since.)
            var im = event.data;
            if (im.message == 'load') {
                var data = im;
                if (data.model == this._currentModelSource) {
                    // Some JS implementations don't allow web workers access to the console.
                    if (typeof console !== 'undefined') {
                        console.warn("Duplicate model load message detected - squashing!");
                    }
                    return;
                }
                else {
                    this._currentModelSource = data.model;
                }
            }
            else if (im.message == 'unload') {
                this._currentModelSource = null;
            }
            // We got a message! Delegate to the current state.
            this.state.handleMessage(im);
        };
        /**
         * Sends back a message structured according to the protocol.
         * @param message A message type.
         * @param payload The message's payload. Can have any properties, except 'message'.
         */
        LMLayerWorker.prototype.cast = function (message, payload) {
            // Chrome raises "TypeError: invalid invocation" if postMessage is called
            // with any non-default value for `this`, i.e., this won't work:
            //
            //  this._postMessage({ foo: 'bar' });
            //
            // Yank it postMessage() off of `this` so that it's called on the
            // "global" context, and everything works again.
            var postMessage = this._postMessage;
            postMessage(__assign({ message: message }, payload));
        };
        /**
         * Loads a model by executing the given source code, and
         * passing in the appropriate configuration.
         *
         * @param desc         Type of the model to instantiate and its parameters.
         * @param capabilities Capabilities on offer from the keyboard.
         */
        LMLayerWorker.prototype.loadModel = function (model) {
            // TODO:  pass _platformConfig to model so that it can self-configure to the platform,
            // returning a Configuration.
            /* Note that this function is typically called from within an `importScripts` call.
             * For meaningful error messages to be successfully logged, we must catch what we can here
             * and pass a message to outside the worker - otherwise a generic "Script error" occurs.
             */
            try {
                var configuration = model.configure(this._platformCapabilities);
                // Handle deprecations.
                if (!configuration.leftContextCodePoints) {
                    configuration.leftContextCodePoints = configuration.leftContextCodeUnits;
                }
                if (!configuration.rightContextCodePoints) {
                    configuration.rightContextCodePoints = configuration.rightContextCodeUnits;
                }
                // Set reasonable defaults for the configuration.
                if (!configuration.leftContextCodePoints) {
                    configuration.leftContextCodePoints = this._platformCapabilities.maxLeftContextCodePoints;
                }
                if (!configuration.rightContextCodePoints) {
                    configuration.rightContextCodePoints = this._platformCapabilities.maxRightContextCodePoints || 0;
                }
                this.transitionToReadyState(model);
                this.cast('ready', { configuration: configuration });
            }
            catch (err) {
                this.error("loadModel failed!", err);
            }
        };
        LMLayerWorker.prototype.loadModelFile = function (url) {
            // The self/global WebWorker method, allowing us to directly import another script file into WebWorker scope.
            // If built correctly, the model's script file will auto-register the model with loadModel() above.
            try {
                this._importScripts(url);
            }
            catch (err) {
                this.error("Error occurred when attempting to load dictionary", err);
            }
        };
        LMLayerWorker.prototype.unloadModel = function () {
            // Right now, this seems sufficient to clear out the old model.
            // The only existing reference to a loaded model is held by 
            // transitionToReadyState's `handleMessage` closure. (The `model` var)
            this.transitionToLoadingState();
        };
        /**
         * Sets the initial state, i.e., `unconfigured`.
         * This state only handles `config` messages, and will
         * transition to the `modelless` state once it receives
         * the config data from the host platform.
         */
        LMLayerWorker.prototype.setupConfigState = function () {
            var _this = this;
            this.state = {
                name: 'unconfigured',
                handleMessage: function (payload) {
                    // ... that message must have been 'config'!
                    if (payload.message !== 'config') {
                        throw new Error("invalid message; expected 'config' but got " + payload.message);
                    }
                    _this._platformCapabilities = payload.capabilities;
                    _this.transitionToLoadingState();
                }
            };
        };
        /**
         * Sets the model-loading state, i.e., `modelless`.
         * This state only handles `load` messages, and will
         * transition to the `ready` state once it receives a model
         * description and capabilities.
         */
        LMLayerWorker.prototype.transitionToLoadingState = function () {
            var _this = this;
            this.state = {
                name: 'modelless',
                handleMessage: function (payload) {
                    // ...that message must have been 'load'!
                    if (payload.message !== 'load') {
                        throw new Error("invalid message; expected 'load' but got " + payload.message);
                    }
                    // TODO: validate configuration?
                    _this.loadModelFile(payload.model);
                }
            };
        };
        /**
         * Sets the state to `ready`. This requires a
         * fully-instantiated model. The `ready` state only responds
         * to `predict` message, and is an accepting state.
         *
         * @param model The loaded language model.
         */
        LMLayerWorker.prototype.transitionToReadyState = function (model) {
            var _this = this;
            this.state = {
                name: 'ready',
                handleMessage: function (payload) {
                    switch (payload.message) {
                        case 'predict':
                            var transform = payload.transform, context = payload.context;
                            var compositor = new ModelCompositor(model); // Yeah, should probably use a persistent one eventually.
                            var suggestions = compositor.predict(transform, context);
                            // Now that the suggestions are ready, send them out!
                            _this.cast('suggestions', {
                                token: payload.token,
                                suggestions: suggestions
                            });
                            break;
                        case 'wordbreak':
                            var brokenWord = model.wordbreak(payload.context);
                            _this.cast('currentword', {
                                token: payload.token,
                                word: brokenWord
                            });
                            break;
                        case 'unload':
                            _this.unloadModel();
                            break;
                        default:
                            throw new Error("invalid message; expected one of {'predict', 'unload'} but got " + payload.message);
                    }
                }
            };
        };
        /**
         * Creates a new instance of the LMLayerWorker, and installs all its
         * functions within the provided Worker global scope.
         *
         * In production, this is called within the Worker's scope as:
         *
         *    LMLayerWorker.install(self);
         *
         * ...and this will setup onmessage and postMessage() appropriately.
         *
         * During testing, this method is useful to mock an entire global scope,
         *
         *    var fakeScope = { postMessage: ... };
         *    LMLayerWorker.install(fakeScope);
         *    // now we can spy on methods in fakeScope!
         *
         * @param scope A global scope to install upon.
         */
        LMLayerWorker.install = function (scope) {
            var worker = new LMLayerWorker({ postMessage: scope.postMessage, importScripts: scope.importScripts.bind(scope) });
            scope.onmessage = worker.onMessage.bind(worker);
            // Ensures that the worker instance is accessible for loaded model scripts.
            // Assists unit-testing.
            scope['LMLayerWorker'] = worker;
            scope['models'] = models;
            scope['wordBreakers'] = wordBreakers;
            return worker;
        };
        return LMLayerWorker;
    }());
    // Let LMLayerWorker be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = LMLayerWorker;
        module.exports['models'] = models;
        module.exports['wordBreakers'] = wordBreakers;
        /// XXX: export the ModelCompositor for testing.
        module.exports['ModelCompositor'] = ModelCompositor;
    }
    else if (typeof self !== 'undefined' && 'postMessage' in self) {
        // Automatically install if we're in a Web Worker.
        LMLayerWorker.install(self);
    }
    else {
        //@ts-ignore
        window.LMLayerWorker = LMLayerWorker;
    }
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    var models;
    (function (models) {
        function applyTransform(transform, context) {
            // First, get the current context
            var fullLeftContext = context.left || '';
            var lLen = fullLeftContext.length;
            var lDel = lLen < transform.deleteLeft ? lLen : transform.deleteLeft;
            var leftContext = fullLeftContext.substring(0, lLen - lDel) + (transform.insert || '');
            var fullRightContext = context.right || '';
            var rLen = fullRightContext.length;
            var rDel = rLen < transform.deleteRight ? rLen : transform.deleteRight;
            var rightContext = fullRightContext.substring(rDel);
            return {
                left: leftContext,
                right: rightContext,
                startOfBuffer: context.startOfBuffer,
                endOfBuffer: context.endOfBuffer
            };
        }
        models.applyTransform = applyTransform;
        /**
         *
         * @param transform Merges one transform into another, mutating the first parameter to
         *                  include the effects of the second.
         * @param prefix
         */
        function prependTransform(transform, prefix) {
            transform.insert = prefix.insert + transform.insert;
            transform.deleteLeft += prefix.deleteLeft;
            if (prefix.deleteRight) {
                transform.deleteRight = (transform.deleteRight || 0) + prefix.deleteRight;
            }
        }
        models.prependTransform = prependTransform;
    })(models || (models = {}));
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * A **VERY** dumb word breaker that simply splits at words. Do not use this
         * word breaker!
         *
         * @param phrase The phrase in which to break words.
         * @deprecated Use a word breaker tailored to your language instead!
         */
        function placeholder(phrase) {
            var nextStart = 0;
            return phrase.split(/\s+/).map(function (utterance) {
                // XXX: The indices are NOT accurate to the original phrase!
                var span = {
                    start: nextStart,
                    end: nextStart + utterance.length,
                    text: utterance,
                    length: utterance.length
                };
                nextStart = span.end;
                return span;
            });
        }
        wordBreakers.placeholder = placeholder;
    })(wordBreakers || (wordBreakers = {}));
    /*
     * Copyright (c) 2019 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2019 SIL International
     * Copyright (c) 2015–2017 Conrad Irwin
     * Copyright (c) 2011–2015 Marc Campbell
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    /// <reference path="../word_breaking/placeholder-word-breaker.ts" />
    /// <reference path="common.ts" />
    /**
     * @file trie-model.ts
     *
     * Defines a simple word list (unigram) model.
     */
    var models;
    (function (models) {
        /** Upper bound on the amount of suggestions to generate. */
        var MAX_SUGGESTIONS = 12;
        /**
         * @class TrieModel
         *
         * Defines a trie-backed word list model, or the unigram model.
         * Unigram models throw away all preceding words, and search
         * for the next word exclusively. As such, they can perform simple
         * prefix searches within words, however they are not very good
         * at predicting the next word.
         */
        var TrieModel = /** @class */ (function () {
            function TrieModel(trieData, options) {
                if (options === void 0) {
                    options = {};
                }
                this._trie = new Trie(trieData['root'], trieData['totalWeight'], options.searchTermToKey || defaultWordform2Key);
                this.breakWords = options.wordBreaker || wordBreakers['default'];
                this.punctuation = options.punctuation;
            }
            TrieModel.prototype.configure = function (capabilities) {
                return this.configuration = {
                    leftContextCodePoints: capabilities.maxLeftContextCodePoints,
                    rightContextCodePoints: capabilities.maxRightContextCodePoints
                };
            };
            TrieModel.prototype.predict = function (transform, context) {
                // Special-case the empty buffer/transform: return the top suggestions.
                if (!transform.insert && context.startOfBuffer && context.endOfBuffer) {
                    return makeDistribution(this._trie.firstN(MAX_SUGGESTIONS).map(function (_a) {
                        var text = _a.text, p = _a.p;
                        return ({
                            transform: {
                                insert: text,
                                deleteLeft: 0
                            },
                            displayAs: text,
                            p: p
                        });
                    }));
                }
                // Compute the results of the keystroke:
                var newContext = models.applyTransform(transform, context);
                // Computes the different in word length after applying the transform above.
                var leftDelOffset = transform.deleteLeft - transform.insert.kmwLength();
                // All text to the left of the cursor INCLUDING anything that has
                // just been typed.
                var prefix = this.getLastWord(newContext.left);
                // Return suggestions from the trie.
                return makeDistribution(this._trie.lookup(prefix).map(function (_a) {
                    var text = _a.text, p = _a.p;
                    return ({
                        transform: {
                            // Insert the suggestion from the Trie, verbatim
                            insert: text,
                            // Delete whatever the prefix that the user wrote.
                            // Note: a separate capitalization/orthography engine can take this
                            // result and transform it as needed.
                            deleteLeft: leftDelOffset + prefix.kmwLength(),
                        },
                        displayAs: text,
                        p: p
                    });
                }));
                /* Helper */
                function makeDistribution(suggestions) {
                    var distribution = [];
                    for (var _i = 0, suggestions_2 = suggestions; _i < suggestions_2.length; _i++) {
                        var s = suggestions_2[_i];
                        distribution.push({ sample: s, p: s.p });
                    }
                    return distribution;
                }
            };
            /**
             * Get the last word of the phrase, or nothing.
             * @param fullLeftContext the entire left context of the string.
             */
            TrieModel.prototype.getLastWord = function (fullLeftContext) {
                var words = this.breakWords(fullLeftContext);
                if (words.length > 0) {
                    return words.pop().text;
                }
                return '';
            };
            TrieModel.prototype.wordbreak = function (context) {
                return this.getLastWord(context.left);
            };
            return TrieModel;
        }());
        models.TrieModel = TrieModel;
        ;
        /**
         * Wrapper class for the trie and its nodes.
         */
        var Trie = /** @class */ (function () {
            function Trie(root, totalWeight, wordform2key) {
                this.root = root;
                this.toKey = wordform2key;
                this.totalWeight = totalWeight;
            }
            /**
             * Lookups an arbitrary prefix (a query) in the trie. Returns the top 3
             * results in sorted order.
             *
             * @param prefix
             */
            Trie.prototype.lookup = function (prefix) {
                var searchKey = this.toKey(prefix);
                var lowestCommonNode = findPrefix(this.root, searchKey);
                if (lowestCommonNode === null) {
                    return [];
                }
                return getSortedResults(lowestCommonNode, searchKey, this.totalWeight);
            };
            /**
             * Returns the top N suggestions from the trie.
             * @param n How many suggestions, maximum, to return.
             */
            Trie.prototype.firstN = function (n) {
                return getSortedResults(this.root, '', this.totalWeight, n);
            };
            return Trie;
        }());
        /**
         * Finds the deepest descendent in the trie with the given prefix key.
         *
         * This means that a search in the trie for a given prefix has a best-case
         * complexity of O(m) where m is the length of the prefix.
         *
         * @param key The prefix to search for.
         * @param index The index in the prefix. Initially 0.
         */
        function findPrefix(node, key, index) {
            if (index === void 0) {
                index = 0;
            }
            // An important note - the Trie itself is built on a per-JS-character basis,
            // not on a UTF-8 character-code basis.
            if (node.type === 'leaf' || index === key.length) {
                return node;
            }
            // So, for SMP models, we need to match each char of the supplementary pair
            // in sequence.  Each has its own node in the Trie.
            var char = key[index];
            if (node.children[char]) {
                return findPrefix(node.children[char], key, index + 1);
            }
            return null;
        }
        /**
         * Returns all entries matching the given prefix, in descending order of
         * weight.
         *
         * @param prefix  the prefix to match.
         * @param results the current results
         * @param queue
         */
        function getSortedResults(node, prefix, N, limit) {
            if (limit === void 0) {
                limit = MAX_SUGGESTIONS;
            }
            var queue = new PriorityQueue();
            var results = [];
            if (node.type === 'leaf') {
                // Assuming the values are sorted, we can just add all of the values in the
                // leaf, until we reach the limit.
                for (var _i = 0, _a = node.entries; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.key.startsWith(prefix)) {
                        var content = item.content, weight = item.weight;
                        results.push({
                            text: content,
                            p: weight / N
                        });
                        if (results.length >= limit) {
                            return results;
                        }
                    }
                }
            }
            else {
                queue.enqueue(node);
                var next = void 0;
                var _loop_2 = function () {
                    if (isNode(next)) {
                        // When a node is next up in the queue, that means that next least
                        // likely suggestion is among its decsendants.
                        // So we search all of its descendants!
                        if (next.type === 'leaf') {
                            queue.enqueueAll(next.entries);
                        }
                        else {
                            // XXX: alias `next` so that TypeScript can be SURE that internal is
                            // in fact an internal node. Because of the callback binding to the
                            // original definition of node (i.e., a Node | Entry), this will not
                            // type-check otherwise.
                            var internal_1 = next;
                            queue.enqueueAll(next.values.map(function (char) {
                                return internal_1.children[char];
                            }));
                        }
                    }
                    else {
                        // When an entry is up next in the queue, we just add its contents to
                        // the results!
                        results.push({
                            text: next.content,
                            p: next.weight / N
                        });
                        if (results.length >= limit) {
                            return { value: results };
                        }
                    }
                };
                while (next = queue.pop()) {
                    var state_1 = _loop_2();
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            return results;
        }
        /** TypeScript type guard that returns whether the thing is a Node. */
        function isNode(x) {
            return 'type' in x;
        }
        /**
         * A priority queue that always pops the highest weighted item.
         */
        var PriorityQueue = /** @class */ (function () {
            function PriorityQueue() {
                // TODO: This probable should use a max-heap implementation, but I'm just doing
                // a O(n log n) sort of the array when an item is popped.
                this._storage = [];
            }
            // TODO: this should have a limit, and ensure small values are not added.
            /**
             * Enqueues a single element to the priority queue.
             */
            PriorityQueue.prototype.enqueue = function (element) {
                this._storage.push(element);
            };
            /**
             * Adds an array of weighted elements to the priority queue.
             */
            PriorityQueue.prototype.enqueueAll = function (elements) {
                this._storage = this._storage.concat(elements);
            };
            /**
             * Pops the highest weighted item in the queue.
             */
            PriorityQueue.prototype.pop = function () {
                // Lazily sort only when NEEDED.
                // Sort in descending order of weight, so heaviest weight will be popped
                // first.
                this._storage.sort(function (a, b) { return b.weight - a.weight; });
                return this._storage.shift();
            };
            return PriorityQueue;
        }());
        /**
         * Converts word forms in into an indexable form. It does this by converting
         * the string to uppercase and trying to remove diacritical marks.
         *
         * This is a very naïve implementation, that I've only though to work on
         * languages that use the Latin script. Even then, some Latin-based
         * orthographies use code points that, under NFD normalization, do NOT
         * decompose into an ASCII letter and a combining diacritical mark (e.g.,
         * SENĆOŦEN).
         *
         * Use this only in early iterations of the model. For a production lexical
         * model, you SHOULD write/generate your own key function, tailored to your
         * language.
         */
        function defaultWordform2Key(wordform) {
            return wordform
                // remove all combining diacritics (if input is in NFD)
                .replace(/[\u0300-\u036f]/g, '')
                // remove all composed diacritics (if input is in NFC) LATIN-ONLY!
                .replace(/[\u00C0-\u212A]/g, function (c) {
                if (c in PARTIAL_NFD_LOOKUP) {
                    return PARTIAL_NFD_LOOKUP[c];
                }
                return c;
            })
                .toLowerCase();
        }
        /**
         * String.prototype.normalize() is not available on all platforms (*cough* IE
         * 11 *cough cough*). We want to use NFD to take off diacritical marks from
         * characters so that they are not used in key searches.
         *
         * This table is of all characters in the range of U+0100 to U+2200 that
         * have a canonical decomposition in NFD form. For some characters, this
         * translates them into their canonical characters (e.g., K -> K). For
         * characters with combining diacritical marks, this leaves behind the base
         * character, removing its diacritics (e.g., É -> E).
         */
        var PARTIAL_NFD_LOOKUP = { "À": "A", "Á": "A", "Â": "A", "Ã": "A", "Ä": "A", "Å": "A", "Ç": "C", "È": "E", "É": "E", "Ê": "E", "Ë": "E", "Ì": "I", "Í": "I", "Î": "I", "Ï": "I", "Ñ": "N", "Ò": "O", "Ó": "O", "Ô": "O", "Õ": "O", "Ö": "O", "Ù": "U", "Ú": "U", "Û": "U", "Ü": "U", "Ý": "Y", "à": "a", "á": "a", "â": "a", "ã": "a", "ä": "a", "å": "a", "ç": "c", "è": "e", "é": "e", "ê": "e", "ë": "e", "ì": "i", "í": "i", "î": "i", "ï": "i", "ñ": "n", "ò": "o", "ó": "o", "ô": "o", "õ": "o", "ö": "o", "ù": "u", "ú": "u", "û": "u", "ü": "u", "ý": "y", "ÿ": "y", "Ā": "A", "ā": "a", "Ă": "A", "ă": "a", "Ą": "A", "ą": "a", "Ć": "C", "ć": "c", "Ĉ": "C", "ĉ": "c", "Ċ": "C", "ċ": "c", "Č": "C", "č": "c", "Ď": "D", "ď": "d", "Ē": "E", "ē": "e", "Ĕ": "E", "ĕ": "e", "Ė": "E", "ė": "e", "Ę": "E", "ę": "e", "Ě": "E", "ě": "e", "Ĝ": "G", "ĝ": "g", "Ğ": "G", "ğ": "g", "Ġ": "G", "ġ": "g", "Ģ": "G", "ģ": "g", "Ĥ": "H", "ĥ": "h", "Ĩ": "I", "ĩ": "i", "Ī": "I", "ī": "i", "Ĭ": "I", "ĭ": "i", "Į": "I", "į": "i", "İ": "I", "Ĵ": "J", "ĵ": "j", "Ķ": "K", "ķ": "k", "Ĺ": "L", "ĺ": "l", "Ļ": "L", "ļ": "l", "Ľ": "L", "ľ": "l", "Ń": "N", "ń": "n", "Ņ": "N", "ņ": "n", "Ň": "N", "ň": "n", "Ō": "O", "ō": "o", "Ŏ": "O", "ŏ": "o", "Ő": "O", "ő": "o", "Ŕ": "R", "ŕ": "r", "Ŗ": "R", "ŗ": "r", "Ř": "R", "ř": "r", "Ś": "S", "ś": "s", "Ŝ": "S", "ŝ": "s", "Ş": "S", "ş": "s", "Š": "S", "š": "s", "Ţ": "T", "ţ": "t", "Ť": "T", "ť": "t", "Ũ": "U", "ũ": "u", "Ū": "U", "ū": "u", "Ŭ": "U", "ŭ": "u", "Ů": "U", "ů": "u", "Ű": "U", "ű": "u", "Ų": "U", "ų": "u", "Ŵ": "W", "ŵ": "w", "Ŷ": "Y", "ŷ": "y", "Ÿ": "Y", "Ź": "Z", "ź": "z", "Ż": "Z", "ż": "z", "Ž": "Z", "ž": "z", "Ơ": "O", "ơ": "o", "Ư": "U", "ư": "u", "Ǎ": "A", "ǎ": "a", "Ǐ": "I", "ǐ": "i", "Ǒ": "O", "ǒ": "o", "Ǔ": "U", "ǔ": "u", "Ǖ": "U", "ǖ": "u", "Ǘ": "U", "ǘ": "u", "Ǚ": "U", "ǚ": "u", "Ǜ": "U", "ǜ": "u", "Ǟ": "A", "ǟ": "a", "Ǡ": "A", "ǡ": "a", "Ǣ": "Æ", "ǣ": "æ", "Ǧ": "G", "ǧ": "g", "Ǩ": "K", "ǩ": "k", "Ǫ": "O", "ǫ": "o", "Ǭ": "O", "ǭ": "o", "Ǯ": "Ʒ", "ǯ": "ʒ", "ǰ": "j", "Ǵ": "G", "ǵ": "g", "Ǹ": "N", "ǹ": "n", "Ǻ": "A", "ǻ": "a", "Ǽ": "Æ", "ǽ": "æ", "Ǿ": "Ø", "ǿ": "ø", "Ȁ": "A", "ȁ": "a", "Ȃ": "A", "ȃ": "a", "Ȅ": "E", "ȅ": "e", "Ȇ": "E", "ȇ": "e", "Ȉ": "I", "ȉ": "i", "Ȋ": "I", "ȋ": "i", "Ȍ": "O", "ȍ": "o", "Ȏ": "O", "ȏ": "o", "Ȑ": "R", "ȑ": "r", "Ȓ": "R", "ȓ": "r", "Ȕ": "U", "ȕ": "u", "Ȗ": "U", "ȗ": "u", "Ș": "S", "ș": "s", "Ț": "T", "ț": "t", "Ȟ": "H", "ȟ": "h", "Ȧ": "A", "ȧ": "a", "Ȩ": "E", "ȩ": "e", "Ȫ": "O", "ȫ": "o", "Ȭ": "O", "ȭ": "o", "Ȯ": "O", "ȯ": "o", "Ȱ": "O", "ȱ": "o", "Ȳ": "Y", "ȳ": "y", "̀": "̀", "́": "́", "̓": "̓", "̈́": "̈", "ʹ": "ʹ", ";": ";", "΅": "¨", "Ά": "Α", "·": "·", "Έ": "Ε", "Ή": "Η", "Ί": "Ι", "Ό": "Ο", "Ύ": "Υ", "Ώ": "Ω", "ΐ": "ι", "Ϊ": "Ι", "Ϋ": "Υ", "ά": "α", "έ": "ε", "ή": "η", "ί": "ι", "ΰ": "υ", "ϊ": "ι", "ϋ": "υ", "ό": "ο", "ύ": "υ", "ώ": "ω", "ϓ": "ϒ", "ϔ": "ϒ", "Ѐ": "Е", "Ё": "Е", "Ѓ": "Г", "Ї": "І", "Ќ": "К", "Ѝ": "И", "Ў": "У", "Й": "И", "й": "и", "ѐ": "е", "ё": "е", "ѓ": "г", "ї": "і", "ќ": "к", "ѝ": "и", "ў": "у", "Ѷ": "Ѵ", "ѷ": "ѵ", "Ӂ": "Ж", "ӂ": "ж", "Ӑ": "А", "ӑ": "а", "Ӓ": "А", "ӓ": "а", "Ӗ": "Е", "ӗ": "е", "Ӛ": "Ә", "ӛ": "ә", "Ӝ": "Ж", "ӝ": "ж", "Ӟ": "З", "ӟ": "з", "Ӣ": "И", "ӣ": "и", "Ӥ": "И", "ӥ": "и", "Ӧ": "О", "ӧ": "о", "Ӫ": "Ө", "ӫ": "ө", "Ӭ": "Э", "ӭ": "э", "Ӯ": "У", "ӯ": "у", "Ӱ": "У", "ӱ": "у", "Ӳ": "У", "ӳ": "у", "Ӵ": "Ч", "ӵ": "ч", "Ӹ": "Ы", "ӹ": "ы", "Ḁ": "A", "ḁ": "a", "Ḃ": "B", "ḃ": "b", "Ḅ": "B", "ḅ": "b", "Ḇ": "B", "ḇ": "b", "Ḉ": "C", "ḉ": "c", "Ḋ": "D", "ḋ": "d", "Ḍ": "D", "ḍ": "d", "Ḏ": "D", "ḏ": "d", "Ḑ": "D", "ḑ": "d", "Ḓ": "D", "ḓ": "d", "Ḕ": "E", "ḕ": "e", "Ḗ": "E", "ḗ": "e", "Ḙ": "E", "ḙ": "e", "Ḛ": "E", "ḛ": "e", "Ḝ": "E", "ḝ": "e", "Ḟ": "F", "ḟ": "f", "Ḡ": "G", "ḡ": "g", "Ḣ": "H", "ḣ": "h", "Ḥ": "H", "ḥ": "h", "Ḧ": "H", "ḧ": "h", "Ḩ": "H", "ḩ": "h", "Ḫ": "H", "ḫ": "h", "Ḭ": "I", "ḭ": "i", "Ḯ": "I", "ḯ": "i", "Ḱ": "K", "ḱ": "k", "Ḳ": "K", "ḳ": "k", "Ḵ": "K", "ḵ": "k", "Ḷ": "L", "ḷ": "l", "Ḹ": "L", "ḹ": "l", "Ḻ": "L", "ḻ": "l", "Ḽ": "L", "ḽ": "l", "Ḿ": "M", "ḿ": "m", "Ṁ": "M", "ṁ": "m", "Ṃ": "M", "ṃ": "m", "Ṅ": "N", "ṅ": "n", "Ṇ": "N", "ṇ": "n", "Ṉ": "N", "ṉ": "n", "Ṋ": "N", "ṋ": "n", "Ṍ": "O", "ṍ": "o", "Ṏ": "O", "ṏ": "o", "Ṑ": "O", "ṑ": "o", "Ṓ": "O", "ṓ": "o", "Ṕ": "P", "ṕ": "p", "Ṗ": "P", "ṗ": "p", "Ṙ": "R", "ṙ": "r", "Ṛ": "R", "ṛ": "r", "Ṝ": "R", "ṝ": "r", "Ṟ": "R", "ṟ": "r", "Ṡ": "S", "ṡ": "s", "Ṣ": "S", "ṣ": "s", "Ṥ": "S", "ṥ": "s", "Ṧ": "S", "ṧ": "s", "Ṩ": "S", "ṩ": "s", "Ṫ": "T", "ṫ": "t", "Ṭ": "T", "ṭ": "t", "Ṯ": "T", "ṯ": "t", "Ṱ": "T", "ṱ": "t", "Ṳ": "U", "ṳ": "u", "Ṵ": "U", "ṵ": "u", "Ṷ": "U", "ṷ": "u", "Ṹ": "U", "ṹ": "u", "Ṻ": "U", "ṻ": "u", "Ṽ": "V", "ṽ": "v", "Ṿ": "V", "ṿ": "v", "Ẁ": "W", "ẁ": "w", "Ẃ": "W", "ẃ": "w", "Ẅ": "W", "ẅ": "w", "Ẇ": "W", "ẇ": "w", "Ẉ": "W", "ẉ": "w", "Ẋ": "X", "ẋ": "x", "Ẍ": "X", "ẍ": "x", "Ẏ": "Y", "ẏ": "y", "Ẑ": "Z", "ẑ": "z", "Ẓ": "Z", "ẓ": "z", "Ẕ": "Z", "ẕ": "z", "ẖ": "h", "ẗ": "t", "ẘ": "w", "ẙ": "y", "ẛ": "ſ", "Ạ": "A", "ạ": "a", "Ả": "A", "ả": "a", "Ấ": "A", "ấ": "a", "Ầ": "A", "ầ": "a", "Ẩ": "A", "ẩ": "a", "Ẫ": "A", "ẫ": "a", "Ậ": "A", "ậ": "a", "Ắ": "A", "ắ": "a", "Ằ": "A", "ằ": "a", "Ẳ": "A", "ẳ": "a", "Ẵ": "A", "ẵ": "a", "Ặ": "A", "ặ": "a", "Ẹ": "E", "ẹ": "e", "Ẻ": "E", "ẻ": "e", "Ẽ": "E", "ẽ": "e", "Ế": "E", "ế": "e", "Ề": "E", "ề": "e", "Ể": "E", "ể": "e", "Ễ": "E", "ễ": "e", "Ệ": "E", "ệ": "e", "Ỉ": "I", "ỉ": "i", "Ị": "I", "ị": "i", "Ọ": "O", "ọ": "o", "Ỏ": "O", "ỏ": "o", "Ố": "O", "ố": "o", "Ồ": "O", "ồ": "o", "Ổ": "O", "ổ": "o", "Ỗ": "O", "ỗ": "o", "Ộ": "O", "ộ": "o", "Ớ": "O", "ớ": "o", "Ờ": "O", "ờ": "o", "Ở": "O", "ở": "o", "Ỡ": "O", "ỡ": "o", "Ợ": "O", "ợ": "o", "Ụ": "U", "ụ": "u", "Ủ": "U", "ủ": "u", "Ứ": "U", "ứ": "u", "Ừ": "U", "ừ": "u", "Ử": "U", "ử": "u", "Ữ": "U", "ữ": "u", "Ự": "U", "ự": "u", "Ỳ": "Y", "ỳ": "y", "Ỵ": "Y", "ỵ": "y", "Ỷ": "Y", "ỷ": "y", "Ỹ": "Y", "ỹ": "y", "ἀ": "α", "ἁ": "α", "ἂ": "α", "ἃ": "α", "ἄ": "α", "ἅ": "α", "ἆ": "α", "ἇ": "α", "Ἀ": "Α", "Ἁ": "Α", "Ἂ": "Α", "Ἃ": "Α", "Ἄ": "Α", "Ἅ": "Α", "Ἆ": "Α", "Ἇ": "Α", "ἐ": "ε", "ἑ": "ε", "ἒ": "ε", "ἓ": "ε", "ἔ": "ε", "ἕ": "ε", "Ἐ": "Ε", "Ἑ": "Ε", "Ἒ": "Ε", "Ἓ": "Ε", "Ἔ": "Ε", "Ἕ": "Ε", "ἠ": "η", "ἡ": "η", "ἢ": "η", "ἣ": "η", "ἤ": "η", "ἥ": "η", "ἦ": "η", "ἧ": "η", "Ἠ": "Η", "Ἡ": "Η", "Ἢ": "Η", "Ἣ": "Η", "Ἤ": "Η", "Ἥ": "Η", "Ἦ": "Η", "Ἧ": "Η", "ἰ": "ι", "ἱ": "ι", "ἲ": "ι", "ἳ": "ι", "ἴ": "ι", "ἵ": "ι", "ἶ": "ι", "ἷ": "ι", "Ἰ": "Ι", "Ἱ": "Ι", "Ἲ": "Ι", "Ἳ": "Ι", "Ἴ": "Ι", "Ἵ": "Ι", "Ἶ": "Ι", "Ἷ": "Ι", "ὀ": "ο", "ὁ": "ο", "ὂ": "ο", "ὃ": "ο", "ὄ": "ο", "ὅ": "ο", "Ὀ": "Ο", "Ὁ": "Ο", "Ὂ": "Ο", "Ὃ": "Ο", "Ὄ": "Ο", "Ὅ": "Ο", "ὐ": "υ", "ὑ": "υ", "ὒ": "υ", "ὓ": "υ", "ὔ": "υ", "ὕ": "υ", "ὖ": "υ", "ὗ": "υ", "Ὑ": "Υ", "Ὓ": "Υ", "Ὕ": "Υ", "Ὗ": "Υ", "ὠ": "ω", "ὡ": "ω", "ὢ": "ω", "ὣ": "ω", "ὤ": "ω", "ὥ": "ω", "ὦ": "ω", "ὧ": "ω", "Ὠ": "Ω", "Ὡ": "Ω", "Ὢ": "Ω", "Ὣ": "Ω", "Ὤ": "Ω", "Ὥ": "Ω", "Ὦ": "Ω", "Ὧ": "Ω", "ὰ": "α", "ά": "α", "ὲ": "ε", "έ": "ε", "ὴ": "η", "ή": "η", "ὶ": "ι", "ί": "ι", "ὸ": "ο", "ό": "ο", "ὺ": "υ", "ύ": "υ", "ὼ": "ω", "ώ": "ω", "ᾀ": "α", "ᾁ": "α", "ᾂ": "α", "ᾃ": "α", "ᾄ": "α", "ᾅ": "α", "ᾆ": "α", "ᾇ": "α", "ᾈ": "Α", "ᾉ": "Α", "ᾊ": "Α", "ᾋ": "Α", "ᾌ": "Α", "ᾍ": "Α", "ᾎ": "Α", "ᾏ": "Α", "ᾐ": "η", "ᾑ": "η", "ᾒ": "η", "ᾓ": "η", "ᾔ": "η", "ᾕ": "η", "ᾖ": "η", "ᾗ": "η", "ᾘ": "Η", "ᾙ": "Η", "ᾚ": "Η", "ᾛ": "Η", "ᾜ": "Η", "ᾝ": "Η", "ᾞ": "Η", "ᾟ": "Η", "ᾠ": "ω", "ᾡ": "ω", "ᾢ": "ω", "ᾣ": "ω", "ᾤ": "ω", "ᾥ": "ω", "ᾦ": "ω", "ᾧ": "ω", "ᾨ": "Ω", "ᾩ": "Ω", "ᾪ": "Ω", "ᾫ": "Ω", "ᾬ": "Ω", "ᾭ": "Ω", "ᾮ": "Ω", "ᾯ": "Ω", "ᾰ": "α", "ᾱ": "α", "ᾲ": "α", "ᾳ": "α", "ᾴ": "α", "ᾶ": "α", "ᾷ": "α", "Ᾰ": "Α", "Ᾱ": "Α", "Ὰ": "Α", "Ά": "Α", "ᾼ": "Α", "ι": "ι", "῁": "¨", "ῂ": "η", "ῃ": "η", "ῄ": "η", "ῆ": "η", "ῇ": "η", "Ὲ": "Ε", "Έ": "Ε", "Ὴ": "Η", "Ή": "Η", "ῌ": "Η", "῍": "᾿", "῎": "᾿", "῏": "᾿", "ῐ": "ι", "ῑ": "ι", "ῒ": "ι", "ΐ": "ι", "ῖ": "ι", "ῗ": "ι", "Ῐ": "Ι", "Ῑ": "Ι", "Ὶ": "Ι", "Ί": "Ι", "῝": "῾", "῞": "῾", "῟": "῾", "ῠ": "υ", "ῡ": "υ", "ῢ": "υ", "ΰ": "υ", "ῤ": "ρ", "ῥ": "ρ", "ῦ": "υ", "ῧ": "υ", "Ῠ": "Υ", "Ῡ": "Υ", "Ὺ": "Υ", "Ύ": "Υ", "Ῥ": "Ρ", "῭": "¨", "΅": "¨", "`": "`", "ῲ": "ω", "ῳ": "ω", "ῴ": "ω", "ῶ": "ω", "ῷ": "ω", "Ὸ": "Ο", "Ό": "Ο", "Ὼ": "Ω", "Ώ": "Ω", "ῼ": "Ω", "´": "´", " ": " ", " ": " ", "Ω": "Ω", "K": "K", "Å": "A" };
    })(models || (models = {}));
    var wordBreakers;
    (function (wordBreakers) {
        var data;
        (function (data) {
            ;
            data.WORD_BREAK_PROPERTY = [
                [/*start*/ 0xA, /*end*/ 0xA, 1 /* LF */],
                [/*start*/ 0xB, /*end*/ 0xC, 2 /* Newline */],
                [/*start*/ 0xD, /*end*/ 0xD, 3 /* CR */],
                [/*start*/ 0x20, /*end*/ 0x20, 4 /* WSegSpace */],
                [/*start*/ 0x22, /*end*/ 0x22, 5 /* Double_Quote */],
                [/*start*/ 0x27, /*end*/ 0x27, 6 /* Single_Quote */],
                [/*start*/ 0x2C, /*end*/ 0x2C, 7 /* MidNum */],
                [/*start*/ 0x2E, /*end*/ 0x2E, 8 /* MidNumLet */],
                [/*start*/ 0x30, /*end*/ 0x39, 9 /* Numeric */],
                [/*start*/ 0x3A, /*end*/ 0x3A, 10 /* MidLetter */],
                [/*start*/ 0x3B, /*end*/ 0x3B, 7 /* MidNum */],
                [/*start*/ 0x41, /*end*/ 0x5A, 11 /* ALetter */],
                [/*start*/ 0x5F, /*end*/ 0x5F, 12 /* ExtendNumLet */],
                [/*start*/ 0x61, /*end*/ 0x7A, 11 /* ALetter */],
                [/*start*/ 0x85, /*end*/ 0x85, 2 /* Newline */],
                [/*start*/ 0xAA, /*end*/ 0xAA, 11 /* ALetter */],
                [/*start*/ 0xAD, /*end*/ 0xAD, 13 /* Format */],
                [/*start*/ 0xB5, /*end*/ 0xB5, 11 /* ALetter */],
                [/*start*/ 0xB7, /*end*/ 0xB7, 10 /* MidLetter */],
                [/*start*/ 0xBA, /*end*/ 0xBA, 11 /* ALetter */],
                [/*start*/ 0xC0, /*end*/ 0xD6, 11 /* ALetter */],
                [/*start*/ 0xD8, /*end*/ 0xF6, 11 /* ALetter */],
                [/*start*/ 0xF8, /*end*/ 0x1BA, 11 /* ALetter */],
                [/*start*/ 0x1BB, /*end*/ 0x1BB, 11 /* ALetter */],
                [/*start*/ 0x1BC, /*end*/ 0x1BF, 11 /* ALetter */],
                [/*start*/ 0x1C0, /*end*/ 0x1C3, 11 /* ALetter */],
                [/*start*/ 0x1C4, /*end*/ 0x293, 11 /* ALetter */],
                [/*start*/ 0x294, /*end*/ 0x294, 11 /* ALetter */],
                [/*start*/ 0x295, /*end*/ 0x2AF, 11 /* ALetter */],
                [/*start*/ 0x2B0, /*end*/ 0x2C1, 11 /* ALetter */],
                [/*start*/ 0x2C2, /*end*/ 0x2C5, 11 /* ALetter */],
                [/*start*/ 0x2C6, /*end*/ 0x2D1, 11 /* ALetter */],
                [/*start*/ 0x2D2, /*end*/ 0x2D7, 11 /* ALetter */],
                [/*start*/ 0x2DE, /*end*/ 0x2DF, 11 /* ALetter */],
                [/*start*/ 0x2E0, /*end*/ 0x2E4, 11 /* ALetter */],
                [/*start*/ 0x2EC, /*end*/ 0x2EC, 11 /* ALetter */],
                [/*start*/ 0x2ED, /*end*/ 0x2ED, 11 /* ALetter */],
                [/*start*/ 0x2EE, /*end*/ 0x2EE, 11 /* ALetter */],
                [/*start*/ 0x2EF, /*end*/ 0x2FF, 11 /* ALetter */],
                [/*start*/ 0x300, /*end*/ 0x36F, 14 /* Extend */],
                [/*start*/ 0x370, /*end*/ 0x373, 11 /* ALetter */],
                [/*start*/ 0x374, /*end*/ 0x374, 11 /* ALetter */],
                [/*start*/ 0x376, /*end*/ 0x377, 11 /* ALetter */],
                [/*start*/ 0x37A, /*end*/ 0x37A, 11 /* ALetter */],
                [/*start*/ 0x37B, /*end*/ 0x37D, 11 /* ALetter */],
                [/*start*/ 0x37E, /*end*/ 0x37E, 7 /* MidNum */],
                [/*start*/ 0x37F, /*end*/ 0x37F, 11 /* ALetter */],
                [/*start*/ 0x386, /*end*/ 0x386, 11 /* ALetter */],
                [/*start*/ 0x387, /*end*/ 0x387, 10 /* MidLetter */],
                [/*start*/ 0x388, /*end*/ 0x38A, 11 /* ALetter */],
                [/*start*/ 0x38C, /*end*/ 0x38C, 11 /* ALetter */],
                [/*start*/ 0x38E, /*end*/ 0x3A1, 11 /* ALetter */],
                [/*start*/ 0x3A3, /*end*/ 0x3F5, 11 /* ALetter */],
                [/*start*/ 0x3F7, /*end*/ 0x481, 11 /* ALetter */],
                [/*start*/ 0x483, /*end*/ 0x487, 14 /* Extend */],
                [/*start*/ 0x488, /*end*/ 0x489, 14 /* Extend */],
                [/*start*/ 0x48A, /*end*/ 0x52F, 11 /* ALetter */],
                [/*start*/ 0x531, /*end*/ 0x556, 11 /* ALetter */],
                [/*start*/ 0x559, /*end*/ 0x559, 11 /* ALetter */],
                [/*start*/ 0x55B, /*end*/ 0x55C, 11 /* ALetter */],
                [/*start*/ 0x55E, /*end*/ 0x55E, 11 /* ALetter */],
                [/*start*/ 0x560, /*end*/ 0x588, 11 /* ALetter */],
                [/*start*/ 0x589, /*end*/ 0x589, 7 /* MidNum */],
                [/*start*/ 0x591, /*end*/ 0x5BD, 14 /* Extend */],
                [/*start*/ 0x5BF, /*end*/ 0x5BF, 14 /* Extend */],
                [/*start*/ 0x5C1, /*end*/ 0x5C2, 14 /* Extend */],
                [/*start*/ 0x5C4, /*end*/ 0x5C5, 14 /* Extend */],
                [/*start*/ 0x5C7, /*end*/ 0x5C7, 14 /* Extend */],
                [/*start*/ 0x5D0, /*end*/ 0x5EA, 15 /* Hebrew_Letter */],
                [/*start*/ 0x5EF, /*end*/ 0x5F2, 15 /* Hebrew_Letter */],
                [/*start*/ 0x5F3, /*end*/ 0x5F3, 11 /* ALetter */],
                [/*start*/ 0x5F4, /*end*/ 0x5F4, 10 /* MidLetter */],
                [/*start*/ 0x600, /*end*/ 0x605, 13 /* Format */],
                [/*start*/ 0x60C, /*end*/ 0x60D, 7 /* MidNum */],
                [/*start*/ 0x610, /*end*/ 0x61A, 14 /* Extend */],
                [/*start*/ 0x61C, /*end*/ 0x61C, 13 /* Format */],
                [/*start*/ 0x620, /*end*/ 0x63F, 11 /* ALetter */],
                [/*start*/ 0x640, /*end*/ 0x640, 11 /* ALetter */],
                [/*start*/ 0x641, /*end*/ 0x64A, 11 /* ALetter */],
                [/*start*/ 0x64B, /*end*/ 0x65F, 14 /* Extend */],
                [/*start*/ 0x660, /*end*/ 0x669, 9 /* Numeric */],
                [/*start*/ 0x66B, /*end*/ 0x66B, 9 /* Numeric */],
                [/*start*/ 0x66C, /*end*/ 0x66C, 7 /* MidNum */],
                [/*start*/ 0x66E, /*end*/ 0x66F, 11 /* ALetter */],
                [/*start*/ 0x670, /*end*/ 0x670, 14 /* Extend */],
                [/*start*/ 0x671, /*end*/ 0x6D3, 11 /* ALetter */],
                [/*start*/ 0x6D5, /*end*/ 0x6D5, 11 /* ALetter */],
                [/*start*/ 0x6D6, /*end*/ 0x6DC, 14 /* Extend */],
                [/*start*/ 0x6DD, /*end*/ 0x6DD, 13 /* Format */],
                [/*start*/ 0x6DF, /*end*/ 0x6E4, 14 /* Extend */],
                [/*start*/ 0x6E5, /*end*/ 0x6E6, 11 /* ALetter */],
                [/*start*/ 0x6E7, /*end*/ 0x6E8, 14 /* Extend */],
                [/*start*/ 0x6EA, /*end*/ 0x6ED, 14 /* Extend */],
                [/*start*/ 0x6EE, /*end*/ 0x6EF, 11 /* ALetter */],
                [/*start*/ 0x6F0, /*end*/ 0x6F9, 9 /* Numeric */],
                [/*start*/ 0x6FA, /*end*/ 0x6FC, 11 /* ALetter */],
                [/*start*/ 0x6FF, /*end*/ 0x6FF, 11 /* ALetter */],
                [/*start*/ 0x70F, /*end*/ 0x70F, 13 /* Format */],
                [/*start*/ 0x710, /*end*/ 0x710, 11 /* ALetter */],
                [/*start*/ 0x711, /*end*/ 0x711, 14 /* Extend */],
                [/*start*/ 0x712, /*end*/ 0x72F, 11 /* ALetter */],
                [/*start*/ 0x730, /*end*/ 0x74A, 14 /* Extend */],
                [/*start*/ 0x74D, /*end*/ 0x7A5, 11 /* ALetter */],
                [/*start*/ 0x7A6, /*end*/ 0x7B0, 14 /* Extend */],
                [/*start*/ 0x7B1, /*end*/ 0x7B1, 11 /* ALetter */],
                [/*start*/ 0x7C0, /*end*/ 0x7C9, 9 /* Numeric */],
                [/*start*/ 0x7CA, /*end*/ 0x7EA, 11 /* ALetter */],
                [/*start*/ 0x7EB, /*end*/ 0x7F3, 14 /* Extend */],
                [/*start*/ 0x7F4, /*end*/ 0x7F5, 11 /* ALetter */],
                [/*start*/ 0x7F8, /*end*/ 0x7F8, 7 /* MidNum */],
                [/*start*/ 0x7FA, /*end*/ 0x7FA, 11 /* ALetter */],
                [/*start*/ 0x7FD, /*end*/ 0x7FD, 14 /* Extend */],
                [/*start*/ 0x800, /*end*/ 0x815, 11 /* ALetter */],
                [/*start*/ 0x816, /*end*/ 0x819, 14 /* Extend */],
                [/*start*/ 0x81A, /*end*/ 0x81A, 11 /* ALetter */],
                [/*start*/ 0x81B, /*end*/ 0x823, 14 /* Extend */],
                [/*start*/ 0x824, /*end*/ 0x824, 11 /* ALetter */],
                [/*start*/ 0x825, /*end*/ 0x827, 14 /* Extend */],
                [/*start*/ 0x828, /*end*/ 0x828, 11 /* ALetter */],
                [/*start*/ 0x829, /*end*/ 0x82D, 14 /* Extend */],
                [/*start*/ 0x840, /*end*/ 0x858, 11 /* ALetter */],
                [/*start*/ 0x859, /*end*/ 0x85B, 14 /* Extend */],
                [/*start*/ 0x860, /*end*/ 0x86A, 11 /* ALetter */],
                [/*start*/ 0x8A0, /*end*/ 0x8B4, 11 /* ALetter */],
                [/*start*/ 0x8B6, /*end*/ 0x8BD, 11 /* ALetter */],
                [/*start*/ 0x8D3, /*end*/ 0x8E1, 14 /* Extend */],
                [/*start*/ 0x8E2, /*end*/ 0x8E2, 13 /* Format */],
                [/*start*/ 0x8E3, /*end*/ 0x902, 14 /* Extend */],
                [/*start*/ 0x903, /*end*/ 0x903, 14 /* Extend */],
                [/*start*/ 0x904, /*end*/ 0x939, 11 /* ALetter */],
                [/*start*/ 0x93A, /*end*/ 0x93A, 14 /* Extend */],
                [/*start*/ 0x93B, /*end*/ 0x93B, 14 /* Extend */],
                [/*start*/ 0x93C, /*end*/ 0x93C, 14 /* Extend */],
                [/*start*/ 0x93D, /*end*/ 0x93D, 11 /* ALetter */],
                [/*start*/ 0x93E, /*end*/ 0x940, 14 /* Extend */],
                [/*start*/ 0x941, /*end*/ 0x948, 14 /* Extend */],
                [/*start*/ 0x949, /*end*/ 0x94C, 14 /* Extend */],
                [/*start*/ 0x94D, /*end*/ 0x94D, 14 /* Extend */],
                [/*start*/ 0x94E, /*end*/ 0x94F, 14 /* Extend */],
                [/*start*/ 0x950, /*end*/ 0x950, 11 /* ALetter */],
                [/*start*/ 0x951, /*end*/ 0x957, 14 /* Extend */],
                [/*start*/ 0x958, /*end*/ 0x961, 11 /* ALetter */],
                [/*start*/ 0x962, /*end*/ 0x963, 14 /* Extend */],
                [/*start*/ 0x966, /*end*/ 0x96F, 9 /* Numeric */],
                [/*start*/ 0x971, /*end*/ 0x971, 11 /* ALetter */],
                [/*start*/ 0x972, /*end*/ 0x980, 11 /* ALetter */],
                [/*start*/ 0x981, /*end*/ 0x981, 14 /* Extend */],
                [/*start*/ 0x982, /*end*/ 0x983, 14 /* Extend */],
                [/*start*/ 0x985, /*end*/ 0x98C, 11 /* ALetter */],
                [/*start*/ 0x98F, /*end*/ 0x990, 11 /* ALetter */],
                [/*start*/ 0x993, /*end*/ 0x9A8, 11 /* ALetter */],
                [/*start*/ 0x9AA, /*end*/ 0x9B0, 11 /* ALetter */],
                [/*start*/ 0x9B2, /*end*/ 0x9B2, 11 /* ALetter */],
                [/*start*/ 0x9B6, /*end*/ 0x9B9, 11 /* ALetter */],
                [/*start*/ 0x9BC, /*end*/ 0x9BC, 14 /* Extend */],
                [/*start*/ 0x9BD, /*end*/ 0x9BD, 11 /* ALetter */],
                [/*start*/ 0x9BE, /*end*/ 0x9C0, 14 /* Extend */],
                [/*start*/ 0x9C1, /*end*/ 0x9C4, 14 /* Extend */],
                [/*start*/ 0x9C7, /*end*/ 0x9C8, 14 /* Extend */],
                [/*start*/ 0x9CB, /*end*/ 0x9CC, 14 /* Extend */],
                [/*start*/ 0x9CD, /*end*/ 0x9CD, 14 /* Extend */],
                [/*start*/ 0x9CE, /*end*/ 0x9CE, 11 /* ALetter */],
                [/*start*/ 0x9D7, /*end*/ 0x9D7, 14 /* Extend */],
                [/*start*/ 0x9DC, /*end*/ 0x9DD, 11 /* ALetter */],
                [/*start*/ 0x9DF, /*end*/ 0x9E1, 11 /* ALetter */],
                [/*start*/ 0x9E2, /*end*/ 0x9E3, 14 /* Extend */],
                [/*start*/ 0x9E6, /*end*/ 0x9EF, 9 /* Numeric */],
                [/*start*/ 0x9F0, /*end*/ 0x9F1, 11 /* ALetter */],
                [/*start*/ 0x9FC, /*end*/ 0x9FC, 11 /* ALetter */],
                [/*start*/ 0x9FE, /*end*/ 0x9FE, 14 /* Extend */],
                [/*start*/ 0xA01, /*end*/ 0xA02, 14 /* Extend */],
                [/*start*/ 0xA03, /*end*/ 0xA03, 14 /* Extend */],
                [/*start*/ 0xA05, /*end*/ 0xA0A, 11 /* ALetter */],
                [/*start*/ 0xA0F, /*end*/ 0xA10, 11 /* ALetter */],
                [/*start*/ 0xA13, /*end*/ 0xA28, 11 /* ALetter */],
                [/*start*/ 0xA2A, /*end*/ 0xA30, 11 /* ALetter */],
                [/*start*/ 0xA32, /*end*/ 0xA33, 11 /* ALetter */],
                [/*start*/ 0xA35, /*end*/ 0xA36, 11 /* ALetter */],
                [/*start*/ 0xA38, /*end*/ 0xA39, 11 /* ALetter */],
                [/*start*/ 0xA3C, /*end*/ 0xA3C, 14 /* Extend */],
                [/*start*/ 0xA3E, /*end*/ 0xA40, 14 /* Extend */],
                [/*start*/ 0xA41, /*end*/ 0xA42, 14 /* Extend */],
                [/*start*/ 0xA47, /*end*/ 0xA48, 14 /* Extend */],
                [/*start*/ 0xA4B, /*end*/ 0xA4D, 14 /* Extend */],
                [/*start*/ 0xA51, /*end*/ 0xA51, 14 /* Extend */],
                [/*start*/ 0xA59, /*end*/ 0xA5C, 11 /* ALetter */],
                [/*start*/ 0xA5E, /*end*/ 0xA5E, 11 /* ALetter */],
                [/*start*/ 0xA66, /*end*/ 0xA6F, 9 /* Numeric */],
                [/*start*/ 0xA70, /*end*/ 0xA71, 14 /* Extend */],
                [/*start*/ 0xA72, /*end*/ 0xA74, 11 /* ALetter */],
                [/*start*/ 0xA75, /*end*/ 0xA75, 14 /* Extend */],
                [/*start*/ 0xA81, /*end*/ 0xA82, 14 /* Extend */],
                [/*start*/ 0xA83, /*end*/ 0xA83, 14 /* Extend */],
                [/*start*/ 0xA85, /*end*/ 0xA8D, 11 /* ALetter */],
                [/*start*/ 0xA8F, /*end*/ 0xA91, 11 /* ALetter */],
                [/*start*/ 0xA93, /*end*/ 0xAA8, 11 /* ALetter */],
                [/*start*/ 0xAAA, /*end*/ 0xAB0, 11 /* ALetter */],
                [/*start*/ 0xAB2, /*end*/ 0xAB3, 11 /* ALetter */],
                [/*start*/ 0xAB5, /*end*/ 0xAB9, 11 /* ALetter */],
                [/*start*/ 0xABC, /*end*/ 0xABC, 14 /* Extend */],
                [/*start*/ 0xABD, /*end*/ 0xABD, 11 /* ALetter */],
                [/*start*/ 0xABE, /*end*/ 0xAC0, 14 /* Extend */],
                [/*start*/ 0xAC1, /*end*/ 0xAC5, 14 /* Extend */],
                [/*start*/ 0xAC7, /*end*/ 0xAC8, 14 /* Extend */],
                [/*start*/ 0xAC9, /*end*/ 0xAC9, 14 /* Extend */],
                [/*start*/ 0xACB, /*end*/ 0xACC, 14 /* Extend */],
                [/*start*/ 0xACD, /*end*/ 0xACD, 14 /* Extend */],
                [/*start*/ 0xAD0, /*end*/ 0xAD0, 11 /* ALetter */],
                [/*start*/ 0xAE0, /*end*/ 0xAE1, 11 /* ALetter */],
                [/*start*/ 0xAE2, /*end*/ 0xAE3, 14 /* Extend */],
                [/*start*/ 0xAE6, /*end*/ 0xAEF, 9 /* Numeric */],
                [/*start*/ 0xAF9, /*end*/ 0xAF9, 11 /* ALetter */],
                [/*start*/ 0xAFA, /*end*/ 0xAFF, 14 /* Extend */],
                [/*start*/ 0xB01, /*end*/ 0xB01, 14 /* Extend */],
                [/*start*/ 0xB02, /*end*/ 0xB03, 14 /* Extend */],
                [/*start*/ 0xB05, /*end*/ 0xB0C, 11 /* ALetter */],
                [/*start*/ 0xB0F, /*end*/ 0xB10, 11 /* ALetter */],
                [/*start*/ 0xB13, /*end*/ 0xB28, 11 /* ALetter */],
                [/*start*/ 0xB2A, /*end*/ 0xB30, 11 /* ALetter */],
                [/*start*/ 0xB32, /*end*/ 0xB33, 11 /* ALetter */],
                [/*start*/ 0xB35, /*end*/ 0xB39, 11 /* ALetter */],
                [/*start*/ 0xB3C, /*end*/ 0xB3C, 14 /* Extend */],
                [/*start*/ 0xB3D, /*end*/ 0xB3D, 11 /* ALetter */],
                [/*start*/ 0xB3E, /*end*/ 0xB3E, 14 /* Extend */],
                [/*start*/ 0xB3F, /*end*/ 0xB3F, 14 /* Extend */],
                [/*start*/ 0xB40, /*end*/ 0xB40, 14 /* Extend */],
                [/*start*/ 0xB41, /*end*/ 0xB44, 14 /* Extend */],
                [/*start*/ 0xB47, /*end*/ 0xB48, 14 /* Extend */],
                [/*start*/ 0xB4B, /*end*/ 0xB4C, 14 /* Extend */],
                [/*start*/ 0xB4D, /*end*/ 0xB4D, 14 /* Extend */],
                [/*start*/ 0xB56, /*end*/ 0xB56, 14 /* Extend */],
                [/*start*/ 0xB57, /*end*/ 0xB57, 14 /* Extend */],
                [/*start*/ 0xB5C, /*end*/ 0xB5D, 11 /* ALetter */],
                [/*start*/ 0xB5F, /*end*/ 0xB61, 11 /* ALetter */],
                [/*start*/ 0xB62, /*end*/ 0xB63, 14 /* Extend */],
                [/*start*/ 0xB66, /*end*/ 0xB6F, 9 /* Numeric */],
                [/*start*/ 0xB71, /*end*/ 0xB71, 11 /* ALetter */],
                [/*start*/ 0xB82, /*end*/ 0xB82, 14 /* Extend */],
                [/*start*/ 0xB83, /*end*/ 0xB83, 11 /* ALetter */],
                [/*start*/ 0xB85, /*end*/ 0xB8A, 11 /* ALetter */],
                [/*start*/ 0xB8E, /*end*/ 0xB90, 11 /* ALetter */],
                [/*start*/ 0xB92, /*end*/ 0xB95, 11 /* ALetter */],
                [/*start*/ 0xB99, /*end*/ 0xB9A, 11 /* ALetter */],
                [/*start*/ 0xB9C, /*end*/ 0xB9C, 11 /* ALetter */],
                [/*start*/ 0xB9E, /*end*/ 0xB9F, 11 /* ALetter */],
                [/*start*/ 0xBA3, /*end*/ 0xBA4, 11 /* ALetter */],
                [/*start*/ 0xBA8, /*end*/ 0xBAA, 11 /* ALetter */],
                [/*start*/ 0xBAE, /*end*/ 0xBB9, 11 /* ALetter */],
                [/*start*/ 0xBBE, /*end*/ 0xBBF, 14 /* Extend */],
                [/*start*/ 0xBC0, /*end*/ 0xBC0, 14 /* Extend */],
                [/*start*/ 0xBC1, /*end*/ 0xBC2, 14 /* Extend */],
                [/*start*/ 0xBC6, /*end*/ 0xBC8, 14 /* Extend */],
                [/*start*/ 0xBCA, /*end*/ 0xBCC, 14 /* Extend */],
                [/*start*/ 0xBCD, /*end*/ 0xBCD, 14 /* Extend */],
                [/*start*/ 0xBD0, /*end*/ 0xBD0, 11 /* ALetter */],
                [/*start*/ 0xBD7, /*end*/ 0xBD7, 14 /* Extend */],
                [/*start*/ 0xBE6, /*end*/ 0xBEF, 9 /* Numeric */],
                [/*start*/ 0xC00, /*end*/ 0xC00, 14 /* Extend */],
                [/*start*/ 0xC01, /*end*/ 0xC03, 14 /* Extend */],
                [/*start*/ 0xC04, /*end*/ 0xC04, 14 /* Extend */],
                [/*start*/ 0xC05, /*end*/ 0xC0C, 11 /* ALetter */],
                [/*start*/ 0xC0E, /*end*/ 0xC10, 11 /* ALetter */],
                [/*start*/ 0xC12, /*end*/ 0xC28, 11 /* ALetter */],
                [/*start*/ 0xC2A, /*end*/ 0xC39, 11 /* ALetter */],
                [/*start*/ 0xC3D, /*end*/ 0xC3D, 11 /* ALetter */],
                [/*start*/ 0xC3E, /*end*/ 0xC40, 14 /* Extend */],
                [/*start*/ 0xC41, /*end*/ 0xC44, 14 /* Extend */],
                [/*start*/ 0xC46, /*end*/ 0xC48, 14 /* Extend */],
                [/*start*/ 0xC4A, /*end*/ 0xC4D, 14 /* Extend */],
                [/*start*/ 0xC55, /*end*/ 0xC56, 14 /* Extend */],
                [/*start*/ 0xC58, /*end*/ 0xC5A, 11 /* ALetter */],
                [/*start*/ 0xC60, /*end*/ 0xC61, 11 /* ALetter */],
                [/*start*/ 0xC62, /*end*/ 0xC63, 14 /* Extend */],
                [/*start*/ 0xC66, /*end*/ 0xC6F, 9 /* Numeric */],
                [/*start*/ 0xC80, /*end*/ 0xC80, 11 /* ALetter */],
                [/*start*/ 0xC81, /*end*/ 0xC81, 14 /* Extend */],
                [/*start*/ 0xC82, /*end*/ 0xC83, 14 /* Extend */],
                [/*start*/ 0xC85, /*end*/ 0xC8C, 11 /* ALetter */],
                [/*start*/ 0xC8E, /*end*/ 0xC90, 11 /* ALetter */],
                [/*start*/ 0xC92, /*end*/ 0xCA8, 11 /* ALetter */],
                [/*start*/ 0xCAA, /*end*/ 0xCB3, 11 /* ALetter */],
                [/*start*/ 0xCB5, /*end*/ 0xCB9, 11 /* ALetter */],
                [/*start*/ 0xCBC, /*end*/ 0xCBC, 14 /* Extend */],
                [/*start*/ 0xCBD, /*end*/ 0xCBD, 11 /* ALetter */],
                [/*start*/ 0xCBE, /*end*/ 0xCBE, 14 /* Extend */],
                [/*start*/ 0xCBF, /*end*/ 0xCBF, 14 /* Extend */],
                [/*start*/ 0xCC0, /*end*/ 0xCC4, 14 /* Extend */],
                [/*start*/ 0xCC6, /*end*/ 0xCC6, 14 /* Extend */],
                [/*start*/ 0xCC7, /*end*/ 0xCC8, 14 /* Extend */],
                [/*start*/ 0xCCA, /*end*/ 0xCCB, 14 /* Extend */],
                [/*start*/ 0xCCC, /*end*/ 0xCCD, 14 /* Extend */],
                [/*start*/ 0xCD5, /*end*/ 0xCD6, 14 /* Extend */],
                [/*start*/ 0xCDE, /*end*/ 0xCDE, 11 /* ALetter */],
                [/*start*/ 0xCE0, /*end*/ 0xCE1, 11 /* ALetter */],
                [/*start*/ 0xCE2, /*end*/ 0xCE3, 14 /* Extend */],
                [/*start*/ 0xCE6, /*end*/ 0xCEF, 9 /* Numeric */],
                [/*start*/ 0xCF1, /*end*/ 0xCF2, 11 /* ALetter */],
                [/*start*/ 0xD00, /*end*/ 0xD01, 14 /* Extend */],
                [/*start*/ 0xD02, /*end*/ 0xD03, 14 /* Extend */],
                [/*start*/ 0xD05, /*end*/ 0xD0C, 11 /* ALetter */],
                [/*start*/ 0xD0E, /*end*/ 0xD10, 11 /* ALetter */],
                [/*start*/ 0xD12, /*end*/ 0xD3A, 11 /* ALetter */],
                [/*start*/ 0xD3B, /*end*/ 0xD3C, 14 /* Extend */],
                [/*start*/ 0xD3D, /*end*/ 0xD3D, 11 /* ALetter */],
                [/*start*/ 0xD3E, /*end*/ 0xD40, 14 /* Extend */],
                [/*start*/ 0xD41, /*end*/ 0xD44, 14 /* Extend */],
                [/*start*/ 0xD46, /*end*/ 0xD48, 14 /* Extend */],
                [/*start*/ 0xD4A, /*end*/ 0xD4C, 14 /* Extend */],
                [/*start*/ 0xD4D, /*end*/ 0xD4D, 14 /* Extend */],
                [/*start*/ 0xD4E, /*end*/ 0xD4E, 11 /* ALetter */],
                [/*start*/ 0xD54, /*end*/ 0xD56, 11 /* ALetter */],
                [/*start*/ 0xD57, /*end*/ 0xD57, 14 /* Extend */],
                [/*start*/ 0xD5F, /*end*/ 0xD61, 11 /* ALetter */],
                [/*start*/ 0xD62, /*end*/ 0xD63, 14 /* Extend */],
                [/*start*/ 0xD66, /*end*/ 0xD6F, 9 /* Numeric */],
                [/*start*/ 0xD7A, /*end*/ 0xD7F, 11 /* ALetter */],
                [/*start*/ 0xD82, /*end*/ 0xD83, 14 /* Extend */],
                [/*start*/ 0xD85, /*end*/ 0xD96, 11 /* ALetter */],
                [/*start*/ 0xD9A, /*end*/ 0xDB1, 11 /* ALetter */],
                [/*start*/ 0xDB3, /*end*/ 0xDBB, 11 /* ALetter */],
                [/*start*/ 0xDBD, /*end*/ 0xDBD, 11 /* ALetter */],
                [/*start*/ 0xDC0, /*end*/ 0xDC6, 11 /* ALetter */],
                [/*start*/ 0xDCA, /*end*/ 0xDCA, 14 /* Extend */],
                [/*start*/ 0xDCF, /*end*/ 0xDD1, 14 /* Extend */],
                [/*start*/ 0xDD2, /*end*/ 0xDD4, 14 /* Extend */],
                [/*start*/ 0xDD6, /*end*/ 0xDD6, 14 /* Extend */],
                [/*start*/ 0xDD8, /*end*/ 0xDDF, 14 /* Extend */],
                [/*start*/ 0xDE6, /*end*/ 0xDEF, 9 /* Numeric */],
                [/*start*/ 0xDF2, /*end*/ 0xDF3, 14 /* Extend */],
                [/*start*/ 0xE31, /*end*/ 0xE31, 14 /* Extend */],
                [/*start*/ 0xE34, /*end*/ 0xE3A, 14 /* Extend */],
                [/*start*/ 0xE47, /*end*/ 0xE4E, 14 /* Extend */],
                [/*start*/ 0xE50, /*end*/ 0xE59, 9 /* Numeric */],
                [/*start*/ 0xEB1, /*end*/ 0xEB1, 14 /* Extend */],
                [/*start*/ 0xEB4, /*end*/ 0xEBC, 14 /* Extend */],
                [/*start*/ 0xEC8, /*end*/ 0xECD, 14 /* Extend */],
                [/*start*/ 0xED0, /*end*/ 0xED9, 9 /* Numeric */],
                [/*start*/ 0xF00, /*end*/ 0xF00, 11 /* ALetter */],
                [/*start*/ 0xF18, /*end*/ 0xF19, 14 /* Extend */],
                [/*start*/ 0xF20, /*end*/ 0xF29, 9 /* Numeric */],
                [/*start*/ 0xF35, /*end*/ 0xF35, 14 /* Extend */],
                [/*start*/ 0xF37, /*end*/ 0xF37, 14 /* Extend */],
                [/*start*/ 0xF39, /*end*/ 0xF39, 14 /* Extend */],
                [/*start*/ 0xF3E, /*end*/ 0xF3F, 14 /* Extend */],
                [/*start*/ 0xF40, /*end*/ 0xF47, 11 /* ALetter */],
                [/*start*/ 0xF49, /*end*/ 0xF6C, 11 /* ALetter */],
                [/*start*/ 0xF71, /*end*/ 0xF7E, 14 /* Extend */],
                [/*start*/ 0xF7F, /*end*/ 0xF7F, 14 /* Extend */],
                [/*start*/ 0xF80, /*end*/ 0xF84, 14 /* Extend */],
                [/*start*/ 0xF86, /*end*/ 0xF87, 14 /* Extend */],
                [/*start*/ 0xF88, /*end*/ 0xF8C, 11 /* ALetter */],
                [/*start*/ 0xF8D, /*end*/ 0xF97, 14 /* Extend */],
                [/*start*/ 0xF99, /*end*/ 0xFBC, 14 /* Extend */],
                [/*start*/ 0xFC6, /*end*/ 0xFC6, 14 /* Extend */],
                [/*start*/ 0x102B, /*end*/ 0x102C, 14 /* Extend */],
                [/*start*/ 0x102D, /*end*/ 0x1030, 14 /* Extend */],
                [/*start*/ 0x1031, /*end*/ 0x1031, 14 /* Extend */],
                [/*start*/ 0x1032, /*end*/ 0x1037, 14 /* Extend */],
                [/*start*/ 0x1038, /*end*/ 0x1038, 14 /* Extend */],
                [/*start*/ 0x1039, /*end*/ 0x103A, 14 /* Extend */],
                [/*start*/ 0x103B, /*end*/ 0x103C, 14 /* Extend */],
                [/*start*/ 0x103D, /*end*/ 0x103E, 14 /* Extend */],
                [/*start*/ 0x1040, /*end*/ 0x1049, 9 /* Numeric */],
                [/*start*/ 0x1056, /*end*/ 0x1057, 14 /* Extend */],
                [/*start*/ 0x1058, /*end*/ 0x1059, 14 /* Extend */],
                [/*start*/ 0x105E, /*end*/ 0x1060, 14 /* Extend */],
                [/*start*/ 0x1062, /*end*/ 0x1064, 14 /* Extend */],
                [/*start*/ 0x1067, /*end*/ 0x106D, 14 /* Extend */],
                [/*start*/ 0x1071, /*end*/ 0x1074, 14 /* Extend */],
                [/*start*/ 0x1082, /*end*/ 0x1082, 14 /* Extend */],
                [/*start*/ 0x1083, /*end*/ 0x1084, 14 /* Extend */],
                [/*start*/ 0x1085, /*end*/ 0x1086, 14 /* Extend */],
                [/*start*/ 0x1087, /*end*/ 0x108C, 14 /* Extend */],
                [/*start*/ 0x108D, /*end*/ 0x108D, 14 /* Extend */],
                [/*start*/ 0x108F, /*end*/ 0x108F, 14 /* Extend */],
                [/*start*/ 0x1090, /*end*/ 0x1099, 9 /* Numeric */],
                [/*start*/ 0x109A, /*end*/ 0x109C, 14 /* Extend */],
                [/*start*/ 0x109D, /*end*/ 0x109D, 14 /* Extend */],
                [/*start*/ 0x10A0, /*end*/ 0x10C5, 11 /* ALetter */],
                [/*start*/ 0x10C7, /*end*/ 0x10C7, 11 /* ALetter */],
                [/*start*/ 0x10CD, /*end*/ 0x10CD, 11 /* ALetter */],
                [/*start*/ 0x10D0, /*end*/ 0x10FA, 11 /* ALetter */],
                [/*start*/ 0x10FC, /*end*/ 0x10FC, 11 /* ALetter */],
                [/*start*/ 0x10FD, /*end*/ 0x10FF, 11 /* ALetter */],
                [/*start*/ 0x1100, /*end*/ 0x1248, 11 /* ALetter */],
                [/*start*/ 0x124A, /*end*/ 0x124D, 11 /* ALetter */],
                [/*start*/ 0x1250, /*end*/ 0x1256, 11 /* ALetter */],
                [/*start*/ 0x1258, /*end*/ 0x1258, 11 /* ALetter */],
                [/*start*/ 0x125A, /*end*/ 0x125D, 11 /* ALetter */],
                [/*start*/ 0x1260, /*end*/ 0x1288, 11 /* ALetter */],
                [/*start*/ 0x128A, /*end*/ 0x128D, 11 /* ALetter */],
                [/*start*/ 0x1290, /*end*/ 0x12B0, 11 /* ALetter */],
                [/*start*/ 0x12B2, /*end*/ 0x12B5, 11 /* ALetter */],
                [/*start*/ 0x12B8, /*end*/ 0x12BE, 11 /* ALetter */],
                [/*start*/ 0x12C0, /*end*/ 0x12C0, 11 /* ALetter */],
                [/*start*/ 0x12C2, /*end*/ 0x12C5, 11 /* ALetter */],
                [/*start*/ 0x12C8, /*end*/ 0x12D6, 11 /* ALetter */],
                [/*start*/ 0x12D8, /*end*/ 0x1310, 11 /* ALetter */],
                [/*start*/ 0x1312, /*end*/ 0x1315, 11 /* ALetter */],
                [/*start*/ 0x1318, /*end*/ 0x135A, 11 /* ALetter */],
                [/*start*/ 0x135D, /*end*/ 0x135F, 14 /* Extend */],
                [/*start*/ 0x1380, /*end*/ 0x138F, 11 /* ALetter */],
                [/*start*/ 0x13A0, /*end*/ 0x13F5, 11 /* ALetter */],
                [/*start*/ 0x13F8, /*end*/ 0x13FD, 11 /* ALetter */],
                [/*start*/ 0x1401, /*end*/ 0x166C, 11 /* ALetter */],
                [/*start*/ 0x166F, /*end*/ 0x167F, 11 /* ALetter */],
                [/*start*/ 0x1680, /*end*/ 0x1680, 4 /* WSegSpace */],
                [/*start*/ 0x1681, /*end*/ 0x169A, 11 /* ALetter */],
                [/*start*/ 0x16A0, /*end*/ 0x16EA, 11 /* ALetter */],
                [/*start*/ 0x16EE, /*end*/ 0x16F0, 11 /* ALetter */],
                [/*start*/ 0x16F1, /*end*/ 0x16F8, 11 /* ALetter */],
                [/*start*/ 0x1700, /*end*/ 0x170C, 11 /* ALetter */],
                [/*start*/ 0x170E, /*end*/ 0x1711, 11 /* ALetter */],
                [/*start*/ 0x1712, /*end*/ 0x1714, 14 /* Extend */],
                [/*start*/ 0x1720, /*end*/ 0x1731, 11 /* ALetter */],
                [/*start*/ 0x1732, /*end*/ 0x1734, 14 /* Extend */],
                [/*start*/ 0x1740, /*end*/ 0x1751, 11 /* ALetter */],
                [/*start*/ 0x1752, /*end*/ 0x1753, 14 /* Extend */],
                [/*start*/ 0x1760, /*end*/ 0x176C, 11 /* ALetter */],
                [/*start*/ 0x176E, /*end*/ 0x1770, 11 /* ALetter */],
                [/*start*/ 0x1772, /*end*/ 0x1773, 14 /* Extend */],
                [/*start*/ 0x17B4, /*end*/ 0x17B5, 14 /* Extend */],
                [/*start*/ 0x17B6, /*end*/ 0x17B6, 14 /* Extend */],
                [/*start*/ 0x17B7, /*end*/ 0x17BD, 14 /* Extend */],
                [/*start*/ 0x17BE, /*end*/ 0x17C5, 14 /* Extend */],
                [/*start*/ 0x17C6, /*end*/ 0x17C6, 14 /* Extend */],
                [/*start*/ 0x17C7, /*end*/ 0x17C8, 14 /* Extend */],
                [/*start*/ 0x17C9, /*end*/ 0x17D3, 14 /* Extend */],
                [/*start*/ 0x17DD, /*end*/ 0x17DD, 14 /* Extend */],
                [/*start*/ 0x17E0, /*end*/ 0x17E9, 9 /* Numeric */],
                [/*start*/ 0x180B, /*end*/ 0x180D, 14 /* Extend */],
                [/*start*/ 0x180E, /*end*/ 0x180E, 13 /* Format */],
                [/*start*/ 0x1810, /*end*/ 0x1819, 9 /* Numeric */],
                [/*start*/ 0x1820, /*end*/ 0x1842, 11 /* ALetter */],
                [/*start*/ 0x1843, /*end*/ 0x1843, 11 /* ALetter */],
                [/*start*/ 0x1844, /*end*/ 0x1878, 11 /* ALetter */],
                [/*start*/ 0x1880, /*end*/ 0x1884, 11 /* ALetter */],
                [/*start*/ 0x1885, /*end*/ 0x1886, 14 /* Extend */],
                [/*start*/ 0x1887, /*end*/ 0x18A8, 11 /* ALetter */],
                [/*start*/ 0x18A9, /*end*/ 0x18A9, 14 /* Extend */],
                [/*start*/ 0x18AA, /*end*/ 0x18AA, 11 /* ALetter */],
                [/*start*/ 0x18B0, /*end*/ 0x18F5, 11 /* ALetter */],
                [/*start*/ 0x1900, /*end*/ 0x191E, 11 /* ALetter */],
                [/*start*/ 0x1920, /*end*/ 0x1922, 14 /* Extend */],
                [/*start*/ 0x1923, /*end*/ 0x1926, 14 /* Extend */],
                [/*start*/ 0x1927, /*end*/ 0x1928, 14 /* Extend */],
                [/*start*/ 0x1929, /*end*/ 0x192B, 14 /* Extend */],
                [/*start*/ 0x1930, /*end*/ 0x1931, 14 /* Extend */],
                [/*start*/ 0x1932, /*end*/ 0x1932, 14 /* Extend */],
                [/*start*/ 0x1933, /*end*/ 0x1938, 14 /* Extend */],
                [/*start*/ 0x1939, /*end*/ 0x193B, 14 /* Extend */],
                [/*start*/ 0x1946, /*end*/ 0x194F, 9 /* Numeric */],
                [/*start*/ 0x19D0, /*end*/ 0x19D9, 9 /* Numeric */],
                [/*start*/ 0x1A00, /*end*/ 0x1A16, 11 /* ALetter */],
                [/*start*/ 0x1A17, /*end*/ 0x1A18, 14 /* Extend */],
                [/*start*/ 0x1A19, /*end*/ 0x1A1A, 14 /* Extend */],
                [/*start*/ 0x1A1B, /*end*/ 0x1A1B, 14 /* Extend */],
                [/*start*/ 0x1A55, /*end*/ 0x1A55, 14 /* Extend */],
                [/*start*/ 0x1A56, /*end*/ 0x1A56, 14 /* Extend */],
                [/*start*/ 0x1A57, /*end*/ 0x1A57, 14 /* Extend */],
                [/*start*/ 0x1A58, /*end*/ 0x1A5E, 14 /* Extend */],
                [/*start*/ 0x1A60, /*end*/ 0x1A60, 14 /* Extend */],
                [/*start*/ 0x1A61, /*end*/ 0x1A61, 14 /* Extend */],
                [/*start*/ 0x1A62, /*end*/ 0x1A62, 14 /* Extend */],
                [/*start*/ 0x1A63, /*end*/ 0x1A64, 14 /* Extend */],
                [/*start*/ 0x1A65, /*end*/ 0x1A6C, 14 /* Extend */],
                [/*start*/ 0x1A6D, /*end*/ 0x1A72, 14 /* Extend */],
                [/*start*/ 0x1A73, /*end*/ 0x1A7C, 14 /* Extend */],
                [/*start*/ 0x1A7F, /*end*/ 0x1A7F, 14 /* Extend */],
                [/*start*/ 0x1A80, /*end*/ 0x1A89, 9 /* Numeric */],
                [/*start*/ 0x1A90, /*end*/ 0x1A99, 9 /* Numeric */],
                [/*start*/ 0x1AB0, /*end*/ 0x1ABD, 14 /* Extend */],
                [/*start*/ 0x1ABE, /*end*/ 0x1ABE, 14 /* Extend */],
                [/*start*/ 0x1B00, /*end*/ 0x1B03, 14 /* Extend */],
                [/*start*/ 0x1B04, /*end*/ 0x1B04, 14 /* Extend */],
                [/*start*/ 0x1B05, /*end*/ 0x1B33, 11 /* ALetter */],
                [/*start*/ 0x1B34, /*end*/ 0x1B34, 14 /* Extend */],
                [/*start*/ 0x1B35, /*end*/ 0x1B35, 14 /* Extend */],
                [/*start*/ 0x1B36, /*end*/ 0x1B3A, 14 /* Extend */],
                [/*start*/ 0x1B3B, /*end*/ 0x1B3B, 14 /* Extend */],
                [/*start*/ 0x1B3C, /*end*/ 0x1B3C, 14 /* Extend */],
                [/*start*/ 0x1B3D, /*end*/ 0x1B41, 14 /* Extend */],
                [/*start*/ 0x1B42, /*end*/ 0x1B42, 14 /* Extend */],
                [/*start*/ 0x1B43, /*end*/ 0x1B44, 14 /* Extend */],
                [/*start*/ 0x1B45, /*end*/ 0x1B4B, 11 /* ALetter */],
                [/*start*/ 0x1B50, /*end*/ 0x1B59, 9 /* Numeric */],
                [/*start*/ 0x1B6B, /*end*/ 0x1B73, 14 /* Extend */],
                [/*start*/ 0x1B80, /*end*/ 0x1B81, 14 /* Extend */],
                [/*start*/ 0x1B82, /*end*/ 0x1B82, 14 /* Extend */],
                [/*start*/ 0x1B83, /*end*/ 0x1BA0, 11 /* ALetter */],
                [/*start*/ 0x1BA1, /*end*/ 0x1BA1, 14 /* Extend */],
                [/*start*/ 0x1BA2, /*end*/ 0x1BA5, 14 /* Extend */],
                [/*start*/ 0x1BA6, /*end*/ 0x1BA7, 14 /* Extend */],
                [/*start*/ 0x1BA8, /*end*/ 0x1BA9, 14 /* Extend */],
                [/*start*/ 0x1BAA, /*end*/ 0x1BAA, 14 /* Extend */],
                [/*start*/ 0x1BAB, /*end*/ 0x1BAD, 14 /* Extend */],
                [/*start*/ 0x1BAE, /*end*/ 0x1BAF, 11 /* ALetter */],
                [/*start*/ 0x1BB0, /*end*/ 0x1BB9, 9 /* Numeric */],
                [/*start*/ 0x1BBA, /*end*/ 0x1BE5, 11 /* ALetter */],
                [/*start*/ 0x1BE6, /*end*/ 0x1BE6, 14 /* Extend */],
                [/*start*/ 0x1BE7, /*end*/ 0x1BE7, 14 /* Extend */],
                [/*start*/ 0x1BE8, /*end*/ 0x1BE9, 14 /* Extend */],
                [/*start*/ 0x1BEA, /*end*/ 0x1BEC, 14 /* Extend */],
                [/*start*/ 0x1BED, /*end*/ 0x1BED, 14 /* Extend */],
                [/*start*/ 0x1BEE, /*end*/ 0x1BEE, 14 /* Extend */],
                [/*start*/ 0x1BEF, /*end*/ 0x1BF1, 14 /* Extend */],
                [/*start*/ 0x1BF2, /*end*/ 0x1BF3, 14 /* Extend */],
                [/*start*/ 0x1C00, /*end*/ 0x1C23, 11 /* ALetter */],
                [/*start*/ 0x1C24, /*end*/ 0x1C2B, 14 /* Extend */],
                [/*start*/ 0x1C2C, /*end*/ 0x1C33, 14 /* Extend */],
                [/*start*/ 0x1C34, /*end*/ 0x1C35, 14 /* Extend */],
                [/*start*/ 0x1C36, /*end*/ 0x1C37, 14 /* Extend */],
                [/*start*/ 0x1C40, /*end*/ 0x1C49, 9 /* Numeric */],
                [/*start*/ 0x1C4D, /*end*/ 0x1C4F, 11 /* ALetter */],
                [/*start*/ 0x1C50, /*end*/ 0x1C59, 9 /* Numeric */],
                [/*start*/ 0x1C5A, /*end*/ 0x1C77, 11 /* ALetter */],
                [/*start*/ 0x1C78, /*end*/ 0x1C7D, 11 /* ALetter */],
                [/*start*/ 0x1C80, /*end*/ 0x1C88, 11 /* ALetter */],
                [/*start*/ 0x1C90, /*end*/ 0x1CBA, 11 /* ALetter */],
                [/*start*/ 0x1CBD, /*end*/ 0x1CBF, 11 /* ALetter */],
                [/*start*/ 0x1CD0, /*end*/ 0x1CD2, 14 /* Extend */],
                [/*start*/ 0x1CD4, /*end*/ 0x1CE0, 14 /* Extend */],
                [/*start*/ 0x1CE1, /*end*/ 0x1CE1, 14 /* Extend */],
                [/*start*/ 0x1CE2, /*end*/ 0x1CE8, 14 /* Extend */],
                [/*start*/ 0x1CE9, /*end*/ 0x1CEC, 11 /* ALetter */],
                [/*start*/ 0x1CED, /*end*/ 0x1CED, 14 /* Extend */],
                [/*start*/ 0x1CEE, /*end*/ 0x1CF3, 11 /* ALetter */],
                [/*start*/ 0x1CF4, /*end*/ 0x1CF4, 14 /* Extend */],
                [/*start*/ 0x1CF5, /*end*/ 0x1CF6, 11 /* ALetter */],
                [/*start*/ 0x1CF7, /*end*/ 0x1CF7, 14 /* Extend */],
                [/*start*/ 0x1CF8, /*end*/ 0x1CF9, 14 /* Extend */],
                [/*start*/ 0x1CFA, /*end*/ 0x1CFA, 11 /* ALetter */],
                [/*start*/ 0x1D00, /*end*/ 0x1D2B, 11 /* ALetter */],
                [/*start*/ 0x1D2C, /*end*/ 0x1D6A, 11 /* ALetter */],
                [/*start*/ 0x1D6B, /*end*/ 0x1D77, 11 /* ALetter */],
                [/*start*/ 0x1D78, /*end*/ 0x1D78, 11 /* ALetter */],
                [/*start*/ 0x1D79, /*end*/ 0x1D9A, 11 /* ALetter */],
                [/*start*/ 0x1D9B, /*end*/ 0x1DBF, 11 /* ALetter */],
                [/*start*/ 0x1DC0, /*end*/ 0x1DF9, 14 /* Extend */],
                [/*start*/ 0x1DFB, /*end*/ 0x1DFF, 14 /* Extend */],
                [/*start*/ 0x1E00, /*end*/ 0x1F15, 11 /* ALetter */],
                [/*start*/ 0x1F18, /*end*/ 0x1F1D, 11 /* ALetter */],
                [/*start*/ 0x1F20, /*end*/ 0x1F45, 11 /* ALetter */],
                [/*start*/ 0x1F48, /*end*/ 0x1F4D, 11 /* ALetter */],
                [/*start*/ 0x1F50, /*end*/ 0x1F57, 11 /* ALetter */],
                [/*start*/ 0x1F59, /*end*/ 0x1F59, 11 /* ALetter */],
                [/*start*/ 0x1F5B, /*end*/ 0x1F5B, 11 /* ALetter */],
                [/*start*/ 0x1F5D, /*end*/ 0x1F5D, 11 /* ALetter */],
                [/*start*/ 0x1F5F, /*end*/ 0x1F7D, 11 /* ALetter */],
                [/*start*/ 0x1F80, /*end*/ 0x1FB4, 11 /* ALetter */],
                [/*start*/ 0x1FB6, /*end*/ 0x1FBC, 11 /* ALetter */],
                [/*start*/ 0x1FBE, /*end*/ 0x1FBE, 11 /* ALetter */],
                [/*start*/ 0x1FC2, /*end*/ 0x1FC4, 11 /* ALetter */],
                [/*start*/ 0x1FC6, /*end*/ 0x1FCC, 11 /* ALetter */],
                [/*start*/ 0x1FD0, /*end*/ 0x1FD3, 11 /* ALetter */],
                [/*start*/ 0x1FD6, /*end*/ 0x1FDB, 11 /* ALetter */],
                [/*start*/ 0x1FE0, /*end*/ 0x1FEC, 11 /* ALetter */],
                [/*start*/ 0x1FF2, /*end*/ 0x1FF4, 11 /* ALetter */],
                [/*start*/ 0x1FF6, /*end*/ 0x1FFC, 11 /* ALetter */],
                [/*start*/ 0x2000, /*end*/ 0x2006, 4 /* WSegSpace */],
                [/*start*/ 0x2008, /*end*/ 0x200A, 4 /* WSegSpace */],
                [/*start*/ 0x200C, /*end*/ 0x200C, 14 /* Extend */],
                [/*start*/ 0x200D, /*end*/ 0x200D, 16 /* ZWJ */],
                [/*start*/ 0x200E, /*end*/ 0x200F, 13 /* Format */],
                [/*start*/ 0x2018, /*end*/ 0x2018, 8 /* MidNumLet */],
                [/*start*/ 0x2019, /*end*/ 0x2019, 8 /* MidNumLet */],
                [/*start*/ 0x2024, /*end*/ 0x2024, 8 /* MidNumLet */],
                [/*start*/ 0x2027, /*end*/ 0x2027, 10 /* MidLetter */],
                [/*start*/ 0x2028, /*end*/ 0x2028, 2 /* Newline */],
                [/*start*/ 0x2029, /*end*/ 0x2029, 2 /* Newline */],
                [/*start*/ 0x202A, /*end*/ 0x202E, 13 /* Format */],
                [/*start*/ 0x202F, /*end*/ 0x202F, 12 /* ExtendNumLet */],
                [/*start*/ 0x203F, /*end*/ 0x2040, 12 /* ExtendNumLet */],
                [/*start*/ 0x2044, /*end*/ 0x2044, 7 /* MidNum */],
                [/*start*/ 0x2054, /*end*/ 0x2054, 12 /* ExtendNumLet */],
                [/*start*/ 0x205F, /*end*/ 0x205F, 4 /* WSegSpace */],
                [/*start*/ 0x2060, /*end*/ 0x2064, 13 /* Format */],
                [/*start*/ 0x2066, /*end*/ 0x206F, 13 /* Format */],
                [/*start*/ 0x2071, /*end*/ 0x2071, 11 /* ALetter */],
                [/*start*/ 0x207F, /*end*/ 0x207F, 11 /* ALetter */],
                [/*start*/ 0x2090, /*end*/ 0x209C, 11 /* ALetter */],
                [/*start*/ 0x20D0, /*end*/ 0x20DC, 14 /* Extend */],
                [/*start*/ 0x20DD, /*end*/ 0x20E0, 14 /* Extend */],
                [/*start*/ 0x20E1, /*end*/ 0x20E1, 14 /* Extend */],
                [/*start*/ 0x20E2, /*end*/ 0x20E4, 14 /* Extend */],
                [/*start*/ 0x20E5, /*end*/ 0x20F0, 14 /* Extend */],
                [/*start*/ 0x2102, /*end*/ 0x2102, 11 /* ALetter */],
                [/*start*/ 0x2107, /*end*/ 0x2107, 11 /* ALetter */],
                [/*start*/ 0x210A, /*end*/ 0x2113, 11 /* ALetter */],
                [/*start*/ 0x2115, /*end*/ 0x2115, 11 /* ALetter */],
                [/*start*/ 0x2119, /*end*/ 0x211D, 11 /* ALetter */],
                [/*start*/ 0x2124, /*end*/ 0x2124, 11 /* ALetter */],
                [/*start*/ 0x2126, /*end*/ 0x2126, 11 /* ALetter */],
                [/*start*/ 0x2128, /*end*/ 0x2128, 11 /* ALetter */],
                [/*start*/ 0x212A, /*end*/ 0x212D, 11 /* ALetter */],
                [/*start*/ 0x212F, /*end*/ 0x2134, 11 /* ALetter */],
                [/*start*/ 0x2135, /*end*/ 0x2138, 11 /* ALetter */],
                [/*start*/ 0x2139, /*end*/ 0x2139, 11 /* ALetter */],
                [/*start*/ 0x213C, /*end*/ 0x213F, 11 /* ALetter */],
                [/*start*/ 0x2145, /*end*/ 0x2149, 11 /* ALetter */],
                [/*start*/ 0x214E, /*end*/ 0x214E, 11 /* ALetter */],
                [/*start*/ 0x2160, /*end*/ 0x2182, 11 /* ALetter */],
                [/*start*/ 0x2183, /*end*/ 0x2184, 11 /* ALetter */],
                [/*start*/ 0x2185, /*end*/ 0x2188, 11 /* ALetter */],
                [/*start*/ 0x24B6, /*end*/ 0x24E9, 11 /* ALetter */],
                [/*start*/ 0x2C00, /*end*/ 0x2C2E, 11 /* ALetter */],
                [/*start*/ 0x2C30, /*end*/ 0x2C5E, 11 /* ALetter */],
                [/*start*/ 0x2C60, /*end*/ 0x2C7B, 11 /* ALetter */],
                [/*start*/ 0x2C7C, /*end*/ 0x2C7D, 11 /* ALetter */],
                [/*start*/ 0x2C7E, /*end*/ 0x2CE4, 11 /* ALetter */],
                [/*start*/ 0x2CEB, /*end*/ 0x2CEE, 11 /* ALetter */],
                [/*start*/ 0x2CEF, /*end*/ 0x2CF1, 14 /* Extend */],
                [/*start*/ 0x2CF2, /*end*/ 0x2CF3, 11 /* ALetter */],
                [/*start*/ 0x2D00, /*end*/ 0x2D25, 11 /* ALetter */],
                [/*start*/ 0x2D27, /*end*/ 0x2D27, 11 /* ALetter */],
                [/*start*/ 0x2D2D, /*end*/ 0x2D2D, 11 /* ALetter */],
                [/*start*/ 0x2D30, /*end*/ 0x2D67, 11 /* ALetter */],
                [/*start*/ 0x2D6F, /*end*/ 0x2D6F, 11 /* ALetter */],
                [/*start*/ 0x2D7F, /*end*/ 0x2D7F, 14 /* Extend */],
                [/*start*/ 0x2D80, /*end*/ 0x2D96, 11 /* ALetter */],
                [/*start*/ 0x2DA0, /*end*/ 0x2DA6, 11 /* ALetter */],
                [/*start*/ 0x2DA8, /*end*/ 0x2DAE, 11 /* ALetter */],
                [/*start*/ 0x2DB0, /*end*/ 0x2DB6, 11 /* ALetter */],
                [/*start*/ 0x2DB8, /*end*/ 0x2DBE, 11 /* ALetter */],
                [/*start*/ 0x2DC0, /*end*/ 0x2DC6, 11 /* ALetter */],
                [/*start*/ 0x2DC8, /*end*/ 0x2DCE, 11 /* ALetter */],
                [/*start*/ 0x2DD0, /*end*/ 0x2DD6, 11 /* ALetter */],
                [/*start*/ 0x2DD8, /*end*/ 0x2DDE, 11 /* ALetter */],
                [/*start*/ 0x2DE0, /*end*/ 0x2DFF, 14 /* Extend */],
                [/*start*/ 0x2E2F, /*end*/ 0x2E2F, 11 /* ALetter */],
                [/*start*/ 0x3000, /*end*/ 0x3000, 4 /* WSegSpace */],
                [/*start*/ 0x3005, /*end*/ 0x3005, 11 /* ALetter */],
                [/*start*/ 0x302A, /*end*/ 0x302D, 14 /* Extend */],
                [/*start*/ 0x302E, /*end*/ 0x302F, 14 /* Extend */],
                [/*start*/ 0x3031, /*end*/ 0x3035, 17 /* Katakana */],
                [/*start*/ 0x303B, /*end*/ 0x303B, 11 /* ALetter */],
                [/*start*/ 0x303C, /*end*/ 0x303C, 11 /* ALetter */],
                [/*start*/ 0x3099, /*end*/ 0x309A, 14 /* Extend */],
                [/*start*/ 0x309B, /*end*/ 0x309C, 17 /* Katakana */],
                [/*start*/ 0x30A0, /*end*/ 0x30A0, 17 /* Katakana */],
                [/*start*/ 0x30A1, /*end*/ 0x30FA, 17 /* Katakana */],
                [/*start*/ 0x30FC, /*end*/ 0x30FE, 17 /* Katakana */],
                [/*start*/ 0x30FF, /*end*/ 0x30FF, 17 /* Katakana */],
                [/*start*/ 0x3105, /*end*/ 0x312F, 11 /* ALetter */],
                [/*start*/ 0x3131, /*end*/ 0x318E, 11 /* ALetter */],
                [/*start*/ 0x31A0, /*end*/ 0x31BA, 11 /* ALetter */],
                [/*start*/ 0x31F0, /*end*/ 0x31FF, 17 /* Katakana */],
                [/*start*/ 0x32D0, /*end*/ 0x32FE, 17 /* Katakana */],
                [/*start*/ 0x3300, /*end*/ 0x3357, 17 /* Katakana */],
                [/*start*/ 0xA000, /*end*/ 0xA014, 11 /* ALetter */],
                [/*start*/ 0xA015, /*end*/ 0xA015, 11 /* ALetter */],
                [/*start*/ 0xA016, /*end*/ 0xA48C, 11 /* ALetter */],
                [/*start*/ 0xA4D0, /*end*/ 0xA4F7, 11 /* ALetter */],
                [/*start*/ 0xA4F8, /*end*/ 0xA4FD, 11 /* ALetter */],
                [/*start*/ 0xA500, /*end*/ 0xA60B, 11 /* ALetter */],
                [/*start*/ 0xA60C, /*end*/ 0xA60C, 11 /* ALetter */],
                [/*start*/ 0xA610, /*end*/ 0xA61F, 11 /* ALetter */],
                [/*start*/ 0xA620, /*end*/ 0xA629, 9 /* Numeric */],
                [/*start*/ 0xA62A, /*end*/ 0xA62B, 11 /* ALetter */],
                [/*start*/ 0xA640, /*end*/ 0xA66D, 11 /* ALetter */],
                [/*start*/ 0xA66E, /*end*/ 0xA66E, 11 /* ALetter */],
                [/*start*/ 0xA66F, /*end*/ 0xA66F, 14 /* Extend */],
                [/*start*/ 0xA670, /*end*/ 0xA672, 14 /* Extend */],
                [/*start*/ 0xA674, /*end*/ 0xA67D, 14 /* Extend */],
                [/*start*/ 0xA67F, /*end*/ 0xA67F, 11 /* ALetter */],
                [/*start*/ 0xA680, /*end*/ 0xA69B, 11 /* ALetter */],
                [/*start*/ 0xA69C, /*end*/ 0xA69D, 11 /* ALetter */],
                [/*start*/ 0xA69E, /*end*/ 0xA69F, 14 /* Extend */],
                [/*start*/ 0xA6A0, /*end*/ 0xA6E5, 11 /* ALetter */],
                [/*start*/ 0xA6E6, /*end*/ 0xA6EF, 11 /* ALetter */],
                [/*start*/ 0xA6F0, /*end*/ 0xA6F1, 14 /* Extend */],
                [/*start*/ 0xA717, /*end*/ 0xA71F, 11 /* ALetter */],
                [/*start*/ 0xA720, /*end*/ 0xA721, 11 /* ALetter */],
                [/*start*/ 0xA722, /*end*/ 0xA76F, 11 /* ALetter */],
                [/*start*/ 0xA770, /*end*/ 0xA770, 11 /* ALetter */],
                [/*start*/ 0xA771, /*end*/ 0xA787, 11 /* ALetter */],
                [/*start*/ 0xA788, /*end*/ 0xA788, 11 /* ALetter */],
                [/*start*/ 0xA789, /*end*/ 0xA78A, 11 /* ALetter */],
                [/*start*/ 0xA78B, /*end*/ 0xA78E, 11 /* ALetter */],
                [/*start*/ 0xA78F, /*end*/ 0xA78F, 11 /* ALetter */],
                [/*start*/ 0xA790, /*end*/ 0xA7BF, 11 /* ALetter */],
                [/*start*/ 0xA7C2, /*end*/ 0xA7C6, 11 /* ALetter */],
                [/*start*/ 0xA7F7, /*end*/ 0xA7F7, 11 /* ALetter */],
                [/*start*/ 0xA7F8, /*end*/ 0xA7F9, 11 /* ALetter */],
                [/*start*/ 0xA7FA, /*end*/ 0xA7FA, 11 /* ALetter */],
                [/*start*/ 0xA7FB, /*end*/ 0xA801, 11 /* ALetter */],
                [/*start*/ 0xA802, /*end*/ 0xA802, 14 /* Extend */],
                [/*start*/ 0xA803, /*end*/ 0xA805, 11 /* ALetter */],
                [/*start*/ 0xA806, /*end*/ 0xA806, 14 /* Extend */],
                [/*start*/ 0xA807, /*end*/ 0xA80A, 11 /* ALetter */],
                [/*start*/ 0xA80B, /*end*/ 0xA80B, 14 /* Extend */],
                [/*start*/ 0xA80C, /*end*/ 0xA822, 11 /* ALetter */],
                [/*start*/ 0xA823, /*end*/ 0xA824, 14 /* Extend */],
                [/*start*/ 0xA825, /*end*/ 0xA826, 14 /* Extend */],
                [/*start*/ 0xA827, /*end*/ 0xA827, 14 /* Extend */],
                [/*start*/ 0xA840, /*end*/ 0xA873, 11 /* ALetter */],
                [/*start*/ 0xA880, /*end*/ 0xA881, 14 /* Extend */],
                [/*start*/ 0xA882, /*end*/ 0xA8B3, 11 /* ALetter */],
                [/*start*/ 0xA8B4, /*end*/ 0xA8C3, 14 /* Extend */],
                [/*start*/ 0xA8C4, /*end*/ 0xA8C5, 14 /* Extend */],
                [/*start*/ 0xA8D0, /*end*/ 0xA8D9, 9 /* Numeric */],
                [/*start*/ 0xA8E0, /*end*/ 0xA8F1, 14 /* Extend */],
                [/*start*/ 0xA8F2, /*end*/ 0xA8F7, 11 /* ALetter */],
                [/*start*/ 0xA8FB, /*end*/ 0xA8FB, 11 /* ALetter */],
                [/*start*/ 0xA8FD, /*end*/ 0xA8FE, 11 /* ALetter */],
                [/*start*/ 0xA8FF, /*end*/ 0xA8FF, 14 /* Extend */],
                [/*start*/ 0xA900, /*end*/ 0xA909, 9 /* Numeric */],
                [/*start*/ 0xA90A, /*end*/ 0xA925, 11 /* ALetter */],
                [/*start*/ 0xA926, /*end*/ 0xA92D, 14 /* Extend */],
                [/*start*/ 0xA930, /*end*/ 0xA946, 11 /* ALetter */],
                [/*start*/ 0xA947, /*end*/ 0xA951, 14 /* Extend */],
                [/*start*/ 0xA952, /*end*/ 0xA953, 14 /* Extend */],
                [/*start*/ 0xA960, /*end*/ 0xA97C, 11 /* ALetter */],
                [/*start*/ 0xA980, /*end*/ 0xA982, 14 /* Extend */],
                [/*start*/ 0xA983, /*end*/ 0xA983, 14 /* Extend */],
                [/*start*/ 0xA984, /*end*/ 0xA9B2, 11 /* ALetter */],
                [/*start*/ 0xA9B3, /*end*/ 0xA9B3, 14 /* Extend */],
                [/*start*/ 0xA9B4, /*end*/ 0xA9B5, 14 /* Extend */],
                [/*start*/ 0xA9B6, /*end*/ 0xA9B9, 14 /* Extend */],
                [/*start*/ 0xA9BA, /*end*/ 0xA9BB, 14 /* Extend */],
                [/*start*/ 0xA9BC, /*end*/ 0xA9BD, 14 /* Extend */],
                [/*start*/ 0xA9BE, /*end*/ 0xA9C0, 14 /* Extend */],
                [/*start*/ 0xA9CF, /*end*/ 0xA9CF, 11 /* ALetter */],
                [/*start*/ 0xA9D0, /*end*/ 0xA9D9, 9 /* Numeric */],
                [/*start*/ 0xA9E5, /*end*/ 0xA9E5, 14 /* Extend */],
                [/*start*/ 0xA9F0, /*end*/ 0xA9F9, 9 /* Numeric */],
                [/*start*/ 0xAA00, /*end*/ 0xAA28, 11 /* ALetter */],
                [/*start*/ 0xAA29, /*end*/ 0xAA2E, 14 /* Extend */],
                [/*start*/ 0xAA2F, /*end*/ 0xAA30, 14 /* Extend */],
                [/*start*/ 0xAA31, /*end*/ 0xAA32, 14 /* Extend */],
                [/*start*/ 0xAA33, /*end*/ 0xAA34, 14 /* Extend */],
                [/*start*/ 0xAA35, /*end*/ 0xAA36, 14 /* Extend */],
                [/*start*/ 0xAA40, /*end*/ 0xAA42, 11 /* ALetter */],
                [/*start*/ 0xAA43, /*end*/ 0xAA43, 14 /* Extend */],
                [/*start*/ 0xAA44, /*end*/ 0xAA4B, 11 /* ALetter */],
                [/*start*/ 0xAA4C, /*end*/ 0xAA4C, 14 /* Extend */],
                [/*start*/ 0xAA4D, /*end*/ 0xAA4D, 14 /* Extend */],
                [/*start*/ 0xAA50, /*end*/ 0xAA59, 9 /* Numeric */],
                [/*start*/ 0xAA7B, /*end*/ 0xAA7B, 14 /* Extend */],
                [/*start*/ 0xAA7C, /*end*/ 0xAA7C, 14 /* Extend */],
                [/*start*/ 0xAA7D, /*end*/ 0xAA7D, 14 /* Extend */],
                [/*start*/ 0xAAB0, /*end*/ 0xAAB0, 14 /* Extend */],
                [/*start*/ 0xAAB2, /*end*/ 0xAAB4, 14 /* Extend */],
                [/*start*/ 0xAAB7, /*end*/ 0xAAB8, 14 /* Extend */],
                [/*start*/ 0xAABE, /*end*/ 0xAABF, 14 /* Extend */],
                [/*start*/ 0xAAC1, /*end*/ 0xAAC1, 14 /* Extend */],
                [/*start*/ 0xAAE0, /*end*/ 0xAAEA, 11 /* ALetter */],
                [/*start*/ 0xAAEB, /*end*/ 0xAAEB, 14 /* Extend */],
                [/*start*/ 0xAAEC, /*end*/ 0xAAED, 14 /* Extend */],
                [/*start*/ 0xAAEE, /*end*/ 0xAAEF, 14 /* Extend */],
                [/*start*/ 0xAAF2, /*end*/ 0xAAF2, 11 /* ALetter */],
                [/*start*/ 0xAAF3, /*end*/ 0xAAF4, 11 /* ALetter */],
                [/*start*/ 0xAAF5, /*end*/ 0xAAF5, 14 /* Extend */],
                [/*start*/ 0xAAF6, /*end*/ 0xAAF6, 14 /* Extend */],
                [/*start*/ 0xAB01, /*end*/ 0xAB06, 11 /* ALetter */],
                [/*start*/ 0xAB09, /*end*/ 0xAB0E, 11 /* ALetter */],
                [/*start*/ 0xAB11, /*end*/ 0xAB16, 11 /* ALetter */],
                [/*start*/ 0xAB20, /*end*/ 0xAB26, 11 /* ALetter */],
                [/*start*/ 0xAB28, /*end*/ 0xAB2E, 11 /* ALetter */],
                [/*start*/ 0xAB30, /*end*/ 0xAB5A, 11 /* ALetter */],
                [/*start*/ 0xAB5B, /*end*/ 0xAB5B, 11 /* ALetter */],
                [/*start*/ 0xAB5C, /*end*/ 0xAB5F, 11 /* ALetter */],
                [/*start*/ 0xAB60, /*end*/ 0xAB67, 11 /* ALetter */],
                [/*start*/ 0xAB70, /*end*/ 0xABBF, 11 /* ALetter */],
                [/*start*/ 0xABC0, /*end*/ 0xABE2, 11 /* ALetter */],
                [/*start*/ 0xABE3, /*end*/ 0xABE4, 14 /* Extend */],
                [/*start*/ 0xABE5, /*end*/ 0xABE5, 14 /* Extend */],
                [/*start*/ 0xABE6, /*end*/ 0xABE7, 14 /* Extend */],
                [/*start*/ 0xABE8, /*end*/ 0xABE8, 14 /* Extend */],
                [/*start*/ 0xABE9, /*end*/ 0xABEA, 14 /* Extend */],
                [/*start*/ 0xABEC, /*end*/ 0xABEC, 14 /* Extend */],
                [/*start*/ 0xABED, /*end*/ 0xABED, 14 /* Extend */],
                [/*start*/ 0xABF0, /*end*/ 0xABF9, 9 /* Numeric */],
                [/*start*/ 0xAC00, /*end*/ 0xD7A3, 11 /* ALetter */],
                [/*start*/ 0xD7B0, /*end*/ 0xD7C6, 11 /* ALetter */],
                [/*start*/ 0xD7CB, /*end*/ 0xD7FB, 11 /* ALetter */],
                [/*start*/ 0xFB00, /*end*/ 0xFB06, 11 /* ALetter */],
                [/*start*/ 0xFB13, /*end*/ 0xFB17, 11 /* ALetter */],
                [/*start*/ 0xFB1D, /*end*/ 0xFB1D, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB1E, /*end*/ 0xFB1E, 14 /* Extend */],
                [/*start*/ 0xFB1F, /*end*/ 0xFB28, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB2A, /*end*/ 0xFB36, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB38, /*end*/ 0xFB3C, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB3E, /*end*/ 0xFB3E, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB40, /*end*/ 0xFB41, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB43, /*end*/ 0xFB44, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB46, /*end*/ 0xFB4F, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB50, /*end*/ 0xFBB1, 11 /* ALetter */],
                [/*start*/ 0xFBD3, /*end*/ 0xFD3D, 11 /* ALetter */],
                [/*start*/ 0xFD50, /*end*/ 0xFD8F, 11 /* ALetter */],
                [/*start*/ 0xFD92, /*end*/ 0xFDC7, 11 /* ALetter */],
                [/*start*/ 0xFDF0, /*end*/ 0xFDFB, 11 /* ALetter */],
                [/*start*/ 0xFE00, /*end*/ 0xFE0F, 14 /* Extend */],
                [/*start*/ 0xFE10, /*end*/ 0xFE10, 7 /* MidNum */],
                [/*start*/ 0xFE13, /*end*/ 0xFE13, 10 /* MidLetter */],
                [/*start*/ 0xFE14, /*end*/ 0xFE14, 7 /* MidNum */],
                [/*start*/ 0xFE20, /*end*/ 0xFE2F, 14 /* Extend */],
                [/*start*/ 0xFE33, /*end*/ 0xFE34, 12 /* ExtendNumLet */],
                [/*start*/ 0xFE4D, /*end*/ 0xFE4F, 12 /* ExtendNumLet */],
                [/*start*/ 0xFE50, /*end*/ 0xFE50, 7 /* MidNum */],
                [/*start*/ 0xFE52, /*end*/ 0xFE52, 8 /* MidNumLet */],
                [/*start*/ 0xFE54, /*end*/ 0xFE54, 7 /* MidNum */],
                [/*start*/ 0xFE55, /*end*/ 0xFE55, 10 /* MidLetter */],
                [/*start*/ 0xFE70, /*end*/ 0xFE74, 11 /* ALetter */],
                [/*start*/ 0xFE76, /*end*/ 0xFEFC, 11 /* ALetter */],
                [/*start*/ 0xFEFF, /*end*/ 0xFEFF, 13 /* Format */],
                [/*start*/ 0xFF07, /*end*/ 0xFF07, 8 /* MidNumLet */],
                [/*start*/ 0xFF0C, /*end*/ 0xFF0C, 7 /* MidNum */],
                [/*start*/ 0xFF0E, /*end*/ 0xFF0E, 8 /* MidNumLet */],
                [/*start*/ 0xFF10, /*end*/ 0xFF19, 9 /* Numeric */],
                [/*start*/ 0xFF1A, /*end*/ 0xFF1A, 10 /* MidLetter */],
                [/*start*/ 0xFF1B, /*end*/ 0xFF1B, 7 /* MidNum */],
                [/*start*/ 0xFF21, /*end*/ 0xFF3A, 11 /* ALetter */],
                [/*start*/ 0xFF3F, /*end*/ 0xFF3F, 12 /* ExtendNumLet */],
                [/*start*/ 0xFF41, /*end*/ 0xFF5A, 11 /* ALetter */],
                [/*start*/ 0xFF66, /*end*/ 0xFF6F, 17 /* Katakana */],
                [/*start*/ 0xFF70, /*end*/ 0xFF70, 17 /* Katakana */],
                [/*start*/ 0xFF71, /*end*/ 0xFF9D, 17 /* Katakana */],
                [/*start*/ 0xFF9E, /*end*/ 0xFF9F, 14 /* Extend */],
                [/*start*/ 0xFFA0, /*end*/ 0xFFBE, 11 /* ALetter */],
                [/*start*/ 0xFFC2, /*end*/ 0xFFC7, 11 /* ALetter */],
                [/*start*/ 0xFFCA, /*end*/ 0xFFCF, 11 /* ALetter */],
                [/*start*/ 0xFFD2, /*end*/ 0xFFD7, 11 /* ALetter */],
                [/*start*/ 0xFFDA, /*end*/ 0xFFDC, 11 /* ALetter */],
                [/*start*/ 0xFFF9, /*end*/ 0xFFFB, 13 /* Format */],
                [/*start*/ 0x10000, /*end*/ 0x1000B, 11 /* ALetter */],
                [/*start*/ 0x1000D, /*end*/ 0x10026, 11 /* ALetter */],
                [/*start*/ 0x10028, /*end*/ 0x1003A, 11 /* ALetter */],
                [/*start*/ 0x1003C, /*end*/ 0x1003D, 11 /* ALetter */],
                [/*start*/ 0x1003F, /*end*/ 0x1004D, 11 /* ALetter */],
                [/*start*/ 0x10050, /*end*/ 0x1005D, 11 /* ALetter */],
                [/*start*/ 0x10080, /*end*/ 0x100FA, 11 /* ALetter */],
                [/*start*/ 0x10140, /*end*/ 0x10174, 11 /* ALetter */],
                [/*start*/ 0x101FD, /*end*/ 0x101FD, 14 /* Extend */],
                [/*start*/ 0x10280, /*end*/ 0x1029C, 11 /* ALetter */],
                [/*start*/ 0x102A0, /*end*/ 0x102D0, 11 /* ALetter */],
                [/*start*/ 0x102E0, /*end*/ 0x102E0, 14 /* Extend */],
                [/*start*/ 0x10300, /*end*/ 0x1031F, 11 /* ALetter */],
                [/*start*/ 0x1032D, /*end*/ 0x10340, 11 /* ALetter */],
                [/*start*/ 0x10341, /*end*/ 0x10341, 11 /* ALetter */],
                [/*start*/ 0x10342, /*end*/ 0x10349, 11 /* ALetter */],
                [/*start*/ 0x1034A, /*end*/ 0x1034A, 11 /* ALetter */],
                [/*start*/ 0x10350, /*end*/ 0x10375, 11 /* ALetter */],
                [/*start*/ 0x10376, /*end*/ 0x1037A, 14 /* Extend */],
                [/*start*/ 0x10380, /*end*/ 0x1039D, 11 /* ALetter */],
                [/*start*/ 0x103A0, /*end*/ 0x103C3, 11 /* ALetter */],
                [/*start*/ 0x103C8, /*end*/ 0x103CF, 11 /* ALetter */],
                [/*start*/ 0x103D1, /*end*/ 0x103D5, 11 /* ALetter */],
                [/*start*/ 0x10400, /*end*/ 0x1044F, 11 /* ALetter */],
                [/*start*/ 0x10450, /*end*/ 0x1049D, 11 /* ALetter */],
                [/*start*/ 0x104A0, /*end*/ 0x104A9, 9 /* Numeric */],
                [/*start*/ 0x104B0, /*end*/ 0x104D3, 11 /* ALetter */],
                [/*start*/ 0x104D8, /*end*/ 0x104FB, 11 /* ALetter */],
                [/*start*/ 0x10500, /*end*/ 0x10527, 11 /* ALetter */],
                [/*start*/ 0x10530, /*end*/ 0x10563, 11 /* ALetter */],
                [/*start*/ 0x10600, /*end*/ 0x10736, 11 /* ALetter */],
                [/*start*/ 0x10740, /*end*/ 0x10755, 11 /* ALetter */],
                [/*start*/ 0x10760, /*end*/ 0x10767, 11 /* ALetter */],
                [/*start*/ 0x10800, /*end*/ 0x10805, 11 /* ALetter */],
                [/*start*/ 0x10808, /*end*/ 0x10808, 11 /* ALetter */],
                [/*start*/ 0x1080A, /*end*/ 0x10835, 11 /* ALetter */],
                [/*start*/ 0x10837, /*end*/ 0x10838, 11 /* ALetter */],
                [/*start*/ 0x1083C, /*end*/ 0x1083C, 11 /* ALetter */],
                [/*start*/ 0x1083F, /*end*/ 0x10855, 11 /* ALetter */],
                [/*start*/ 0x10860, /*end*/ 0x10876, 11 /* ALetter */],
                [/*start*/ 0x10880, /*end*/ 0x1089E, 11 /* ALetter */],
                [/*start*/ 0x108E0, /*end*/ 0x108F2, 11 /* ALetter */],
                [/*start*/ 0x108F4, /*end*/ 0x108F5, 11 /* ALetter */],
                [/*start*/ 0x10900, /*end*/ 0x10915, 11 /* ALetter */],
                [/*start*/ 0x10920, /*end*/ 0x10939, 11 /* ALetter */],
                [/*start*/ 0x10980, /*end*/ 0x109B7, 11 /* ALetter */],
                [/*start*/ 0x109BE, /*end*/ 0x109BF, 11 /* ALetter */],
                [/*start*/ 0x10A00, /*end*/ 0x10A00, 11 /* ALetter */],
                [/*start*/ 0x10A01, /*end*/ 0x10A03, 14 /* Extend */],
                [/*start*/ 0x10A05, /*end*/ 0x10A06, 14 /* Extend */],
                [/*start*/ 0x10A0C, /*end*/ 0x10A0F, 14 /* Extend */],
                [/*start*/ 0x10A10, /*end*/ 0x10A13, 11 /* ALetter */],
                [/*start*/ 0x10A15, /*end*/ 0x10A17, 11 /* ALetter */],
                [/*start*/ 0x10A19, /*end*/ 0x10A35, 11 /* ALetter */],
                [/*start*/ 0x10A38, /*end*/ 0x10A3A, 14 /* Extend */],
                [/*start*/ 0x10A3F, /*end*/ 0x10A3F, 14 /* Extend */],
                [/*start*/ 0x10A60, /*end*/ 0x10A7C, 11 /* ALetter */],
                [/*start*/ 0x10A80, /*end*/ 0x10A9C, 11 /* ALetter */],
                [/*start*/ 0x10AC0, /*end*/ 0x10AC7, 11 /* ALetter */],
                [/*start*/ 0x10AC9, /*end*/ 0x10AE4, 11 /* ALetter */],
                [/*start*/ 0x10AE5, /*end*/ 0x10AE6, 14 /* Extend */],
                [/*start*/ 0x10B00, /*end*/ 0x10B35, 11 /* ALetter */],
                [/*start*/ 0x10B40, /*end*/ 0x10B55, 11 /* ALetter */],
                [/*start*/ 0x10B60, /*end*/ 0x10B72, 11 /* ALetter */],
                [/*start*/ 0x10B80, /*end*/ 0x10B91, 11 /* ALetter */],
                [/*start*/ 0x10C00, /*end*/ 0x10C48, 11 /* ALetter */],
                [/*start*/ 0x10C80, /*end*/ 0x10CB2, 11 /* ALetter */],
                [/*start*/ 0x10CC0, /*end*/ 0x10CF2, 11 /* ALetter */],
                [/*start*/ 0x10D00, /*end*/ 0x10D23, 11 /* ALetter */],
                [/*start*/ 0x10D24, /*end*/ 0x10D27, 14 /* Extend */],
                [/*start*/ 0x10D30, /*end*/ 0x10D39, 9 /* Numeric */],
                [/*start*/ 0x10F00, /*end*/ 0x10F1C, 11 /* ALetter */],
                [/*start*/ 0x10F27, /*end*/ 0x10F27, 11 /* ALetter */],
                [/*start*/ 0x10F30, /*end*/ 0x10F45, 11 /* ALetter */],
                [/*start*/ 0x10F46, /*end*/ 0x10F50, 14 /* Extend */],
                [/*start*/ 0x10FE0, /*end*/ 0x10FF6, 11 /* ALetter */],
                [/*start*/ 0x11000, /*end*/ 0x11000, 14 /* Extend */],
                [/*start*/ 0x11001, /*end*/ 0x11001, 14 /* Extend */],
                [/*start*/ 0x11002, /*end*/ 0x11002, 14 /* Extend */],
                [/*start*/ 0x11003, /*end*/ 0x11037, 11 /* ALetter */],
                [/*start*/ 0x11038, /*end*/ 0x11046, 14 /* Extend */],
                [/*start*/ 0x11066, /*end*/ 0x1106F, 9 /* Numeric */],
                [/*start*/ 0x1107F, /*end*/ 0x11081, 14 /* Extend */],
                [/*start*/ 0x11082, /*end*/ 0x11082, 14 /* Extend */],
                [/*start*/ 0x11083, /*end*/ 0x110AF, 11 /* ALetter */],
                [/*start*/ 0x110B0, /*end*/ 0x110B2, 14 /* Extend */],
                [/*start*/ 0x110B3, /*end*/ 0x110B6, 14 /* Extend */],
                [/*start*/ 0x110B7, /*end*/ 0x110B8, 14 /* Extend */],
                [/*start*/ 0x110B9, /*end*/ 0x110BA, 14 /* Extend */],
                [/*start*/ 0x110BD, /*end*/ 0x110BD, 13 /* Format */],
                [/*start*/ 0x110CD, /*end*/ 0x110CD, 13 /* Format */],
                [/*start*/ 0x110D0, /*end*/ 0x110E8, 11 /* ALetter */],
                [/*start*/ 0x110F0, /*end*/ 0x110F9, 9 /* Numeric */],
                [/*start*/ 0x11100, /*end*/ 0x11102, 14 /* Extend */],
                [/*start*/ 0x11103, /*end*/ 0x11126, 11 /* ALetter */],
                [/*start*/ 0x11127, /*end*/ 0x1112B, 14 /* Extend */],
                [/*start*/ 0x1112C, /*end*/ 0x1112C, 14 /* Extend */],
                [/*start*/ 0x1112D, /*end*/ 0x11134, 14 /* Extend */],
                [/*start*/ 0x11136, /*end*/ 0x1113F, 9 /* Numeric */],
                [/*start*/ 0x11144, /*end*/ 0x11144, 11 /* ALetter */],
                [/*start*/ 0x11145, /*end*/ 0x11146, 14 /* Extend */],
                [/*start*/ 0x11150, /*end*/ 0x11172, 11 /* ALetter */],
                [/*start*/ 0x11173, /*end*/ 0x11173, 14 /* Extend */],
                [/*start*/ 0x11176, /*end*/ 0x11176, 11 /* ALetter */],
                [/*start*/ 0x11180, /*end*/ 0x11181, 14 /* Extend */],
                [/*start*/ 0x11182, /*end*/ 0x11182, 14 /* Extend */],
                [/*start*/ 0x11183, /*end*/ 0x111B2, 11 /* ALetter */],
                [/*start*/ 0x111B3, /*end*/ 0x111B5, 14 /* Extend */],
                [/*start*/ 0x111B6, /*end*/ 0x111BE, 14 /* Extend */],
                [/*start*/ 0x111BF, /*end*/ 0x111C0, 14 /* Extend */],
                [/*start*/ 0x111C1, /*end*/ 0x111C4, 11 /* ALetter */],
                [/*start*/ 0x111C9, /*end*/ 0x111CC, 14 /* Extend */],
                [/*start*/ 0x111D0, /*end*/ 0x111D9, 9 /* Numeric */],
                [/*start*/ 0x111DA, /*end*/ 0x111DA, 11 /* ALetter */],
                [/*start*/ 0x111DC, /*end*/ 0x111DC, 11 /* ALetter */],
                [/*start*/ 0x11200, /*end*/ 0x11211, 11 /* ALetter */],
                [/*start*/ 0x11213, /*end*/ 0x1122B, 11 /* ALetter */],
                [/*start*/ 0x1122C, /*end*/ 0x1122E, 14 /* Extend */],
                [/*start*/ 0x1122F, /*end*/ 0x11231, 14 /* Extend */],
                [/*start*/ 0x11232, /*end*/ 0x11233, 14 /* Extend */],
                [/*start*/ 0x11234, /*end*/ 0x11234, 14 /* Extend */],
                [/*start*/ 0x11235, /*end*/ 0x11235, 14 /* Extend */],
                [/*start*/ 0x11236, /*end*/ 0x11237, 14 /* Extend */],
                [/*start*/ 0x1123E, /*end*/ 0x1123E, 14 /* Extend */],
                [/*start*/ 0x11280, /*end*/ 0x11286, 11 /* ALetter */],
                [/*start*/ 0x11288, /*end*/ 0x11288, 11 /* ALetter */],
                [/*start*/ 0x1128A, /*end*/ 0x1128D, 11 /* ALetter */],
                [/*start*/ 0x1128F, /*end*/ 0x1129D, 11 /* ALetter */],
                [/*start*/ 0x1129F, /*end*/ 0x112A8, 11 /* ALetter */],
                [/*start*/ 0x112B0, /*end*/ 0x112DE, 11 /* ALetter */],
                [/*start*/ 0x112DF, /*end*/ 0x112DF, 14 /* Extend */],
                [/*start*/ 0x112E0, /*end*/ 0x112E2, 14 /* Extend */],
                [/*start*/ 0x112E3, /*end*/ 0x112EA, 14 /* Extend */],
                [/*start*/ 0x112F0, /*end*/ 0x112F9, 9 /* Numeric */],
                [/*start*/ 0x11300, /*end*/ 0x11301, 14 /* Extend */],
                [/*start*/ 0x11302, /*end*/ 0x11303, 14 /* Extend */],
                [/*start*/ 0x11305, /*end*/ 0x1130C, 11 /* ALetter */],
                [/*start*/ 0x1130F, /*end*/ 0x11310, 11 /* ALetter */],
                [/*start*/ 0x11313, /*end*/ 0x11328, 11 /* ALetter */],
                [/*start*/ 0x1132A, /*end*/ 0x11330, 11 /* ALetter */],
                [/*start*/ 0x11332, /*end*/ 0x11333, 11 /* ALetter */],
                [/*start*/ 0x11335, /*end*/ 0x11339, 11 /* ALetter */],
                [/*start*/ 0x1133B, /*end*/ 0x1133C, 14 /* Extend */],
                [/*start*/ 0x1133D, /*end*/ 0x1133D, 11 /* ALetter */],
                [/*start*/ 0x1133E, /*end*/ 0x1133F, 14 /* Extend */],
                [/*start*/ 0x11340, /*end*/ 0x11340, 14 /* Extend */],
                [/*start*/ 0x11341, /*end*/ 0x11344, 14 /* Extend */],
                [/*start*/ 0x11347, /*end*/ 0x11348, 14 /* Extend */],
                [/*start*/ 0x1134B, /*end*/ 0x1134D, 14 /* Extend */],
                [/*start*/ 0x11350, /*end*/ 0x11350, 11 /* ALetter */],
                [/*start*/ 0x11357, /*end*/ 0x11357, 14 /* Extend */],
                [/*start*/ 0x1135D, /*end*/ 0x11361, 11 /* ALetter */],
                [/*start*/ 0x11362, /*end*/ 0x11363, 14 /* Extend */],
                [/*start*/ 0x11366, /*end*/ 0x1136C, 14 /* Extend */],
                [/*start*/ 0x11370, /*end*/ 0x11374, 14 /* Extend */],
                [/*start*/ 0x11400, /*end*/ 0x11434, 11 /* ALetter */],
                [/*start*/ 0x11435, /*end*/ 0x11437, 14 /* Extend */],
                [/*start*/ 0x11438, /*end*/ 0x1143F, 14 /* Extend */],
                [/*start*/ 0x11440, /*end*/ 0x11441, 14 /* Extend */],
                [/*start*/ 0x11442, /*end*/ 0x11444, 14 /* Extend */],
                [/*start*/ 0x11445, /*end*/ 0x11445, 14 /* Extend */],
                [/*start*/ 0x11446, /*end*/ 0x11446, 14 /* Extend */],
                [/*start*/ 0x11447, /*end*/ 0x1144A, 11 /* ALetter */],
                [/*start*/ 0x11450, /*end*/ 0x11459, 9 /* Numeric */],
                [/*start*/ 0x1145E, /*end*/ 0x1145E, 14 /* Extend */],
                [/*start*/ 0x1145F, /*end*/ 0x1145F, 11 /* ALetter */],
                [/*start*/ 0x11480, /*end*/ 0x114AF, 11 /* ALetter */],
                [/*start*/ 0x114B0, /*end*/ 0x114B2, 14 /* Extend */],
                [/*start*/ 0x114B3, /*end*/ 0x114B8, 14 /* Extend */],
                [/*start*/ 0x114B9, /*end*/ 0x114B9, 14 /* Extend */],
                [/*start*/ 0x114BA, /*end*/ 0x114BA, 14 /* Extend */],
                [/*start*/ 0x114BB, /*end*/ 0x114BE, 14 /* Extend */],
                [/*start*/ 0x114BF, /*end*/ 0x114C0, 14 /* Extend */],
                [/*start*/ 0x114C1, /*end*/ 0x114C1, 14 /* Extend */],
                [/*start*/ 0x114C2, /*end*/ 0x114C3, 14 /* Extend */],
                [/*start*/ 0x114C4, /*end*/ 0x114C5, 11 /* ALetter */],
                [/*start*/ 0x114C7, /*end*/ 0x114C7, 11 /* ALetter */],
                [/*start*/ 0x114D0, /*end*/ 0x114D9, 9 /* Numeric */],
                [/*start*/ 0x11580, /*end*/ 0x115AE, 11 /* ALetter */],
                [/*start*/ 0x115AF, /*end*/ 0x115B1, 14 /* Extend */],
                [/*start*/ 0x115B2, /*end*/ 0x115B5, 14 /* Extend */],
                [/*start*/ 0x115B8, /*end*/ 0x115BB, 14 /* Extend */],
                [/*start*/ 0x115BC, /*end*/ 0x115BD, 14 /* Extend */],
                [/*start*/ 0x115BE, /*end*/ 0x115BE, 14 /* Extend */],
                [/*start*/ 0x115BF, /*end*/ 0x115C0, 14 /* Extend */],
                [/*start*/ 0x115D8, /*end*/ 0x115DB, 11 /* ALetter */],
                [/*start*/ 0x115DC, /*end*/ 0x115DD, 14 /* Extend */],
                [/*start*/ 0x11600, /*end*/ 0x1162F, 11 /* ALetter */],
                [/*start*/ 0x11630, /*end*/ 0x11632, 14 /* Extend */],
                [/*start*/ 0x11633, /*end*/ 0x1163A, 14 /* Extend */],
                [/*start*/ 0x1163B, /*end*/ 0x1163C, 14 /* Extend */],
                [/*start*/ 0x1163D, /*end*/ 0x1163D, 14 /* Extend */],
                [/*start*/ 0x1163E, /*end*/ 0x1163E, 14 /* Extend */],
                [/*start*/ 0x1163F, /*end*/ 0x11640, 14 /* Extend */],
                [/*start*/ 0x11644, /*end*/ 0x11644, 11 /* ALetter */],
                [/*start*/ 0x11650, /*end*/ 0x11659, 9 /* Numeric */],
                [/*start*/ 0x11680, /*end*/ 0x116AA, 11 /* ALetter */],
                [/*start*/ 0x116AB, /*end*/ 0x116AB, 14 /* Extend */],
                [/*start*/ 0x116AC, /*end*/ 0x116AC, 14 /* Extend */],
                [/*start*/ 0x116AD, /*end*/ 0x116AD, 14 /* Extend */],
                [/*start*/ 0x116AE, /*end*/ 0x116AF, 14 /* Extend */],
                [/*start*/ 0x116B0, /*end*/ 0x116B5, 14 /* Extend */],
                [/*start*/ 0x116B6, /*end*/ 0x116B6, 14 /* Extend */],
                [/*start*/ 0x116B7, /*end*/ 0x116B7, 14 /* Extend */],
                [/*start*/ 0x116B8, /*end*/ 0x116B8, 11 /* ALetter */],
                [/*start*/ 0x116C0, /*end*/ 0x116C9, 9 /* Numeric */],
                [/*start*/ 0x1171D, /*end*/ 0x1171F, 14 /* Extend */],
                [/*start*/ 0x11720, /*end*/ 0x11721, 14 /* Extend */],
                [/*start*/ 0x11722, /*end*/ 0x11725, 14 /* Extend */],
                [/*start*/ 0x11726, /*end*/ 0x11726, 14 /* Extend */],
                [/*start*/ 0x11727, /*end*/ 0x1172B, 14 /* Extend */],
                [/*start*/ 0x11730, /*end*/ 0x11739, 9 /* Numeric */],
                [/*start*/ 0x11800, /*end*/ 0x1182B, 11 /* ALetter */],
                [/*start*/ 0x1182C, /*end*/ 0x1182E, 14 /* Extend */],
                [/*start*/ 0x1182F, /*end*/ 0x11837, 14 /* Extend */],
                [/*start*/ 0x11838, /*end*/ 0x11838, 14 /* Extend */],
                [/*start*/ 0x11839, /*end*/ 0x1183A, 14 /* Extend */],
                [/*start*/ 0x118A0, /*end*/ 0x118DF, 11 /* ALetter */],
                [/*start*/ 0x118E0, /*end*/ 0x118E9, 9 /* Numeric */],
                [/*start*/ 0x118FF, /*end*/ 0x118FF, 11 /* ALetter */],
                [/*start*/ 0x119A0, /*end*/ 0x119A7, 11 /* ALetter */],
                [/*start*/ 0x119AA, /*end*/ 0x119D0, 11 /* ALetter */],
                [/*start*/ 0x119D1, /*end*/ 0x119D3, 14 /* Extend */],
                [/*start*/ 0x119D4, /*end*/ 0x119D7, 14 /* Extend */],
                [/*start*/ 0x119DA, /*end*/ 0x119DB, 14 /* Extend */],
                [/*start*/ 0x119DC, /*end*/ 0x119DF, 14 /* Extend */],
                [/*start*/ 0x119E0, /*end*/ 0x119E0, 14 /* Extend */],
                [/*start*/ 0x119E1, /*end*/ 0x119E1, 11 /* ALetter */],
                [/*start*/ 0x119E3, /*end*/ 0x119E3, 11 /* ALetter */],
                [/*start*/ 0x119E4, /*end*/ 0x119E4, 14 /* Extend */],
                [/*start*/ 0x11A00, /*end*/ 0x11A00, 11 /* ALetter */],
                [/*start*/ 0x11A01, /*end*/ 0x11A0A, 14 /* Extend */],
                [/*start*/ 0x11A0B, /*end*/ 0x11A32, 11 /* ALetter */],
                [/*start*/ 0x11A33, /*end*/ 0x11A38, 14 /* Extend */],
                [/*start*/ 0x11A39, /*end*/ 0x11A39, 14 /* Extend */],
                [/*start*/ 0x11A3A, /*end*/ 0x11A3A, 11 /* ALetter */],
                [/*start*/ 0x11A3B, /*end*/ 0x11A3E, 14 /* Extend */],
                [/*start*/ 0x11A47, /*end*/ 0x11A47, 14 /* Extend */],
                [/*start*/ 0x11A50, /*end*/ 0x11A50, 11 /* ALetter */],
                [/*start*/ 0x11A51, /*end*/ 0x11A56, 14 /* Extend */],
                [/*start*/ 0x11A57, /*end*/ 0x11A58, 14 /* Extend */],
                [/*start*/ 0x11A59, /*end*/ 0x11A5B, 14 /* Extend */],
                [/*start*/ 0x11A5C, /*end*/ 0x11A89, 11 /* ALetter */],
                [/*start*/ 0x11A8A, /*end*/ 0x11A96, 14 /* Extend */],
                [/*start*/ 0x11A97, /*end*/ 0x11A97, 14 /* Extend */],
                [/*start*/ 0x11A98, /*end*/ 0x11A99, 14 /* Extend */],
                [/*start*/ 0x11A9D, /*end*/ 0x11A9D, 11 /* ALetter */],
                [/*start*/ 0x11AC0, /*end*/ 0x11AF8, 11 /* ALetter */],
                [/*start*/ 0x11C00, /*end*/ 0x11C08, 11 /* ALetter */],
                [/*start*/ 0x11C0A, /*end*/ 0x11C2E, 11 /* ALetter */],
                [/*start*/ 0x11C2F, /*end*/ 0x11C2F, 14 /* Extend */],
                [/*start*/ 0x11C30, /*end*/ 0x11C36, 14 /* Extend */],
                [/*start*/ 0x11C38, /*end*/ 0x11C3D, 14 /* Extend */],
                [/*start*/ 0x11C3E, /*end*/ 0x11C3E, 14 /* Extend */],
                [/*start*/ 0x11C3F, /*end*/ 0x11C3F, 14 /* Extend */],
                [/*start*/ 0x11C40, /*end*/ 0x11C40, 11 /* ALetter */],
                [/*start*/ 0x11C50, /*end*/ 0x11C59, 9 /* Numeric */],
                [/*start*/ 0x11C72, /*end*/ 0x11C8F, 11 /* ALetter */],
                [/*start*/ 0x11C92, /*end*/ 0x11CA7, 14 /* Extend */],
                [/*start*/ 0x11CA9, /*end*/ 0x11CA9, 14 /* Extend */],
                [/*start*/ 0x11CAA, /*end*/ 0x11CB0, 14 /* Extend */],
                [/*start*/ 0x11CB1, /*end*/ 0x11CB1, 14 /* Extend */],
                [/*start*/ 0x11CB2, /*end*/ 0x11CB3, 14 /* Extend */],
                [/*start*/ 0x11CB4, /*end*/ 0x11CB4, 14 /* Extend */],
                [/*start*/ 0x11CB5, /*end*/ 0x11CB6, 14 /* Extend */],
                [/*start*/ 0x11D00, /*end*/ 0x11D06, 11 /* ALetter */],
                [/*start*/ 0x11D08, /*end*/ 0x11D09, 11 /* ALetter */],
                [/*start*/ 0x11D0B, /*end*/ 0x11D30, 11 /* ALetter */],
                [/*start*/ 0x11D31, /*end*/ 0x11D36, 14 /* Extend */],
                [/*start*/ 0x11D3A, /*end*/ 0x11D3A, 14 /* Extend */],
                [/*start*/ 0x11D3C, /*end*/ 0x11D3D, 14 /* Extend */],
                [/*start*/ 0x11D3F, /*end*/ 0x11D45, 14 /* Extend */],
                [/*start*/ 0x11D46, /*end*/ 0x11D46, 11 /* ALetter */],
                [/*start*/ 0x11D47, /*end*/ 0x11D47, 14 /* Extend */],
                [/*start*/ 0x11D50, /*end*/ 0x11D59, 9 /* Numeric */],
                [/*start*/ 0x11D60, /*end*/ 0x11D65, 11 /* ALetter */],
                [/*start*/ 0x11D67, /*end*/ 0x11D68, 11 /* ALetter */],
                [/*start*/ 0x11D6A, /*end*/ 0x11D89, 11 /* ALetter */],
                [/*start*/ 0x11D8A, /*end*/ 0x11D8E, 14 /* Extend */],
                [/*start*/ 0x11D90, /*end*/ 0x11D91, 14 /* Extend */],
                [/*start*/ 0x11D93, /*end*/ 0x11D94, 14 /* Extend */],
                [/*start*/ 0x11D95, /*end*/ 0x11D95, 14 /* Extend */],
                [/*start*/ 0x11D96, /*end*/ 0x11D96, 14 /* Extend */],
                [/*start*/ 0x11D97, /*end*/ 0x11D97, 14 /* Extend */],
                [/*start*/ 0x11D98, /*end*/ 0x11D98, 11 /* ALetter */],
                [/*start*/ 0x11DA0, /*end*/ 0x11DA9, 9 /* Numeric */],
                [/*start*/ 0x11EE0, /*end*/ 0x11EF2, 11 /* ALetter */],
                [/*start*/ 0x11EF3, /*end*/ 0x11EF4, 14 /* Extend */],
                [/*start*/ 0x11EF5, /*end*/ 0x11EF6, 14 /* Extend */],
                [/*start*/ 0x12000, /*end*/ 0x12399, 11 /* ALetter */],
                [/*start*/ 0x12400, /*end*/ 0x1246E, 11 /* ALetter */],
                [/*start*/ 0x12480, /*end*/ 0x12543, 11 /* ALetter */],
                [/*start*/ 0x13000, /*end*/ 0x1342E, 11 /* ALetter */],
                [/*start*/ 0x13430, /*end*/ 0x13438, 13 /* Format */],
                [/*start*/ 0x14400, /*end*/ 0x14646, 11 /* ALetter */],
                [/*start*/ 0x16800, /*end*/ 0x16A38, 11 /* ALetter */],
                [/*start*/ 0x16A40, /*end*/ 0x16A5E, 11 /* ALetter */],
                [/*start*/ 0x16A60, /*end*/ 0x16A69, 9 /* Numeric */],
                [/*start*/ 0x16AD0, /*end*/ 0x16AED, 11 /* ALetter */],
                [/*start*/ 0x16AF0, /*end*/ 0x16AF4, 14 /* Extend */],
                [/*start*/ 0x16B00, /*end*/ 0x16B2F, 11 /* ALetter */],
                [/*start*/ 0x16B30, /*end*/ 0x16B36, 14 /* Extend */],
                [/*start*/ 0x16B40, /*end*/ 0x16B43, 11 /* ALetter */],
                [/*start*/ 0x16B50, /*end*/ 0x16B59, 9 /* Numeric */],
                [/*start*/ 0x16B63, /*end*/ 0x16B77, 11 /* ALetter */],
                [/*start*/ 0x16B7D, /*end*/ 0x16B8F, 11 /* ALetter */],
                [/*start*/ 0x16E40, /*end*/ 0x16E7F, 11 /* ALetter */],
                [/*start*/ 0x16F00, /*end*/ 0x16F4A, 11 /* ALetter */],
                [/*start*/ 0x16F4F, /*end*/ 0x16F4F, 14 /* Extend */],
                [/*start*/ 0x16F50, /*end*/ 0x16F50, 11 /* ALetter */],
                [/*start*/ 0x16F51, /*end*/ 0x16F87, 14 /* Extend */],
                [/*start*/ 0x16F8F, /*end*/ 0x16F92, 14 /* Extend */],
                [/*start*/ 0x16F93, /*end*/ 0x16F9F, 11 /* ALetter */],
                [/*start*/ 0x16FE0, /*end*/ 0x16FE1, 11 /* ALetter */],
                [/*start*/ 0x16FE3, /*end*/ 0x16FE3, 11 /* ALetter */],
                [/*start*/ 0x1B000, /*end*/ 0x1B000, 17 /* Katakana */],
                [/*start*/ 0x1B164, /*end*/ 0x1B167, 17 /* Katakana */],
                [/*start*/ 0x1BC00, /*end*/ 0x1BC6A, 11 /* ALetter */],
                [/*start*/ 0x1BC70, /*end*/ 0x1BC7C, 11 /* ALetter */],
                [/*start*/ 0x1BC80, /*end*/ 0x1BC88, 11 /* ALetter */],
                [/*start*/ 0x1BC90, /*end*/ 0x1BC99, 11 /* ALetter */],
                [/*start*/ 0x1BC9D, /*end*/ 0x1BC9E, 14 /* Extend */],
                [/*start*/ 0x1BCA0, /*end*/ 0x1BCA3, 13 /* Format */],
                [/*start*/ 0x1D165, /*end*/ 0x1D166, 14 /* Extend */],
                [/*start*/ 0x1D167, /*end*/ 0x1D169, 14 /* Extend */],
                [/*start*/ 0x1D16D, /*end*/ 0x1D172, 14 /* Extend */],
                [/*start*/ 0x1D173, /*end*/ 0x1D17A, 13 /* Format */],
                [/*start*/ 0x1D17B, /*end*/ 0x1D182, 14 /* Extend */],
                [/*start*/ 0x1D185, /*end*/ 0x1D18B, 14 /* Extend */],
                [/*start*/ 0x1D1AA, /*end*/ 0x1D1AD, 14 /* Extend */],
                [/*start*/ 0x1D242, /*end*/ 0x1D244, 14 /* Extend */],
                [/*start*/ 0x1D400, /*end*/ 0x1D454, 11 /* ALetter */],
                [/*start*/ 0x1D456, /*end*/ 0x1D49C, 11 /* ALetter */],
                [/*start*/ 0x1D49E, /*end*/ 0x1D49F, 11 /* ALetter */],
                [/*start*/ 0x1D4A2, /*end*/ 0x1D4A2, 11 /* ALetter */],
                [/*start*/ 0x1D4A5, /*end*/ 0x1D4A6, 11 /* ALetter */],
                [/*start*/ 0x1D4A9, /*end*/ 0x1D4AC, 11 /* ALetter */],
                [/*start*/ 0x1D4AE, /*end*/ 0x1D4B9, 11 /* ALetter */],
                [/*start*/ 0x1D4BB, /*end*/ 0x1D4BB, 11 /* ALetter */],
                [/*start*/ 0x1D4BD, /*end*/ 0x1D4C3, 11 /* ALetter */],
                [/*start*/ 0x1D4C5, /*end*/ 0x1D505, 11 /* ALetter */],
                [/*start*/ 0x1D507, /*end*/ 0x1D50A, 11 /* ALetter */],
                [/*start*/ 0x1D50D, /*end*/ 0x1D514, 11 /* ALetter */],
                [/*start*/ 0x1D516, /*end*/ 0x1D51C, 11 /* ALetter */],
                [/*start*/ 0x1D51E, /*end*/ 0x1D539, 11 /* ALetter */],
                [/*start*/ 0x1D53B, /*end*/ 0x1D53E, 11 /* ALetter */],
                [/*start*/ 0x1D540, /*end*/ 0x1D544, 11 /* ALetter */],
                [/*start*/ 0x1D546, /*end*/ 0x1D546, 11 /* ALetter */],
                [/*start*/ 0x1D54A, /*end*/ 0x1D550, 11 /* ALetter */],
                [/*start*/ 0x1D552, /*end*/ 0x1D6A5, 11 /* ALetter */],
                [/*start*/ 0x1D6A8, /*end*/ 0x1D6C0, 11 /* ALetter */],
                [/*start*/ 0x1D6C2, /*end*/ 0x1D6DA, 11 /* ALetter */],
                [/*start*/ 0x1D6DC, /*end*/ 0x1D6FA, 11 /* ALetter */],
                [/*start*/ 0x1D6FC, /*end*/ 0x1D714, 11 /* ALetter */],
                [/*start*/ 0x1D716, /*end*/ 0x1D734, 11 /* ALetter */],
                [/*start*/ 0x1D736, /*end*/ 0x1D74E, 11 /* ALetter */],
                [/*start*/ 0x1D750, /*end*/ 0x1D76E, 11 /* ALetter */],
                [/*start*/ 0x1D770, /*end*/ 0x1D788, 11 /* ALetter */],
                [/*start*/ 0x1D78A, /*end*/ 0x1D7A8, 11 /* ALetter */],
                [/*start*/ 0x1D7AA, /*end*/ 0x1D7C2, 11 /* ALetter */],
                [/*start*/ 0x1D7C4, /*end*/ 0x1D7CB, 11 /* ALetter */],
                [/*start*/ 0x1D7CE, /*end*/ 0x1D7FF, 9 /* Numeric */],
                [/*start*/ 0x1DA00, /*end*/ 0x1DA36, 14 /* Extend */],
                [/*start*/ 0x1DA3B, /*end*/ 0x1DA6C, 14 /* Extend */],
                [/*start*/ 0x1DA75, /*end*/ 0x1DA75, 14 /* Extend */],
                [/*start*/ 0x1DA84, /*end*/ 0x1DA84, 14 /* Extend */],
                [/*start*/ 0x1DA9B, /*end*/ 0x1DA9F, 14 /* Extend */],
                [/*start*/ 0x1DAA1, /*end*/ 0x1DAAF, 14 /* Extend */],
                [/*start*/ 0x1E000, /*end*/ 0x1E006, 14 /* Extend */],
                [/*start*/ 0x1E008, /*end*/ 0x1E018, 14 /* Extend */],
                [/*start*/ 0x1E01B, /*end*/ 0x1E021, 14 /* Extend */],
                [/*start*/ 0x1E023, /*end*/ 0x1E024, 14 /* Extend */],
                [/*start*/ 0x1E026, /*end*/ 0x1E02A, 14 /* Extend */],
                [/*start*/ 0x1E100, /*end*/ 0x1E12C, 11 /* ALetter */],
                [/*start*/ 0x1E130, /*end*/ 0x1E136, 14 /* Extend */],
                [/*start*/ 0x1E137, /*end*/ 0x1E13D, 11 /* ALetter */],
                [/*start*/ 0x1E140, /*end*/ 0x1E149, 9 /* Numeric */],
                [/*start*/ 0x1E14E, /*end*/ 0x1E14E, 11 /* ALetter */],
                [/*start*/ 0x1E2C0, /*end*/ 0x1E2EB, 11 /* ALetter */],
                [/*start*/ 0x1E2EC, /*end*/ 0x1E2EF, 14 /* Extend */],
                [/*start*/ 0x1E2F0, /*end*/ 0x1E2F9, 9 /* Numeric */],
                [/*start*/ 0x1E800, /*end*/ 0x1E8C4, 11 /* ALetter */],
                [/*start*/ 0x1E8D0, /*end*/ 0x1E8D6, 14 /* Extend */],
                [/*start*/ 0x1E900, /*end*/ 0x1E943, 11 /* ALetter */],
                [/*start*/ 0x1E944, /*end*/ 0x1E94A, 14 /* Extend */],
                [/*start*/ 0x1E94B, /*end*/ 0x1E94B, 11 /* ALetter */],
                [/*start*/ 0x1E950, /*end*/ 0x1E959, 9 /* Numeric */],
                [/*start*/ 0x1EE00, /*end*/ 0x1EE03, 11 /* ALetter */],
                [/*start*/ 0x1EE05, /*end*/ 0x1EE1F, 11 /* ALetter */],
                [/*start*/ 0x1EE21, /*end*/ 0x1EE22, 11 /* ALetter */],
                [/*start*/ 0x1EE24, /*end*/ 0x1EE24, 11 /* ALetter */],
                [/*start*/ 0x1EE27, /*end*/ 0x1EE27, 11 /* ALetter */],
                [/*start*/ 0x1EE29, /*end*/ 0x1EE32, 11 /* ALetter */],
                [/*start*/ 0x1EE34, /*end*/ 0x1EE37, 11 /* ALetter */],
                [/*start*/ 0x1EE39, /*end*/ 0x1EE39, 11 /* ALetter */],
                [/*start*/ 0x1EE3B, /*end*/ 0x1EE3B, 11 /* ALetter */],
                [/*start*/ 0x1EE42, /*end*/ 0x1EE42, 11 /* ALetter */],
                [/*start*/ 0x1EE47, /*end*/ 0x1EE47, 11 /* ALetter */],
                [/*start*/ 0x1EE49, /*end*/ 0x1EE49, 11 /* ALetter */],
                [/*start*/ 0x1EE4B, /*end*/ 0x1EE4B, 11 /* ALetter */],
                [/*start*/ 0x1EE4D, /*end*/ 0x1EE4F, 11 /* ALetter */],
                [/*start*/ 0x1EE51, /*end*/ 0x1EE52, 11 /* ALetter */],
                [/*start*/ 0x1EE54, /*end*/ 0x1EE54, 11 /* ALetter */],
                [/*start*/ 0x1EE57, /*end*/ 0x1EE57, 11 /* ALetter */],
                [/*start*/ 0x1EE59, /*end*/ 0x1EE59, 11 /* ALetter */],
                [/*start*/ 0x1EE5B, /*end*/ 0x1EE5B, 11 /* ALetter */],
                [/*start*/ 0x1EE5D, /*end*/ 0x1EE5D, 11 /* ALetter */],
                [/*start*/ 0x1EE5F, /*end*/ 0x1EE5F, 11 /* ALetter */],
                [/*start*/ 0x1EE61, /*end*/ 0x1EE62, 11 /* ALetter */],
                [/*start*/ 0x1EE64, /*end*/ 0x1EE64, 11 /* ALetter */],
                [/*start*/ 0x1EE67, /*end*/ 0x1EE6A, 11 /* ALetter */],
                [/*start*/ 0x1EE6C, /*end*/ 0x1EE72, 11 /* ALetter */],
                [/*start*/ 0x1EE74, /*end*/ 0x1EE77, 11 /* ALetter */],
                [/*start*/ 0x1EE79, /*end*/ 0x1EE7C, 11 /* ALetter */],
                [/*start*/ 0x1EE7E, /*end*/ 0x1EE7E, 11 /* ALetter */],
                [/*start*/ 0x1EE80, /*end*/ 0x1EE89, 11 /* ALetter */],
                [/*start*/ 0x1EE8B, /*end*/ 0x1EE9B, 11 /* ALetter */],
                [/*start*/ 0x1EEA1, /*end*/ 0x1EEA3, 11 /* ALetter */],
                [/*start*/ 0x1EEA5, /*end*/ 0x1EEA9, 11 /* ALetter */],
                [/*start*/ 0x1EEAB, /*end*/ 0x1EEBB, 11 /* ALetter */],
                [/*start*/ 0x1F130, /*end*/ 0x1F149, 11 /* ALetter */],
                [/*start*/ 0x1F150, /*end*/ 0x1F169, 11 /* ALetter */],
                [/*start*/ 0x1F170, /*end*/ 0x1F189, 11 /* ALetter */],
                [/*start*/ 0x1F1E6, /*end*/ 0x1F1FF, 18 /* Regional_Indicator */],
                [/*start*/ 0x1F3FB, /*end*/ 0x1F3FF, 14 /* Extend */],
                [/*start*/ 0xE0001, /*end*/ 0xE0001, 13 /* Format */],
                [/*start*/ 0xE0020, /*end*/ 0xE007F, 14 /* Extend */],
                [/*start*/ 0xE0100, /*end*/ 0xE01EF, 14 /* Extend */],
            ];
        })(data = wordBreakers.data || (wordBreakers.data = {}));
    })(wordBreakers || (wordBreakers = {}));
    // Include the word-breaking data here:
    /// <reference path="./data.ts" />
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * Word breaker based on Unicode Standard Annex #29, Section 4.1:
         * Default Word Boundary Specification.
         *
         * @see http://unicode.org/reports/tr29/#Word_Boundaries
         * @see https://github.com/eddieantonio/unicode-default-word-boundary/tree/v12.0.0
         */
        function default_(text) {
            var boundaries = findBoundaries(text);
            if (boundaries.length == 0) {
                return [];
            }
            // All non-empty strings have at least TWO boundaries at the start and end of
            // the string.
            var spans = [];
            for (var i = 0; i < boundaries.length - 1; i++) {
                var start = boundaries[i];
                var end = boundaries[i + 1];
                var span = new LazySpan(text, start, end);
                if (isNonSpace(span.text)) {
                    spans.push(span);
                    // Preserve a sequence-final space if it exists.  Needed to signal "end of word".
                }
                else if (i == boundaries.length - 2) { // if "we just checked the final boundary"...
                    // We don't want to return the whitespace itself; the correct token is simply ''.
                    span = new LazySpan(text, end, end);
                    spans.push(span);
                }
            }
            return spans;
        }
        wordBreakers.default_ = default_;
        var WORD_BREAK_PROPERTY = wordBreakers.data.WORD_BREAK_PROPERTY;
        /**
         * A span that does not cut out the substring until it absolutely has to!
         */
        var LazySpan = /** @class */ (function () {
            function LazySpan(source, start, end) {
                this._source = source;
                this.start = start;
                this.end = end;
            }
            Object.defineProperty(LazySpan.prototype, "text", {
                get: function () {
                    return this._source.substring(this.start, this.end);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LazySpan.prototype, "length", {
                get: function () {
                    return this.end - this.start;
                },
                enumerable: true,
                configurable: true
            });
            return LazySpan;
        }());
        /**
         * Returns true when the chunk does not solely consist of whitespace.
         *
         * @param chunk a chunk of text. Starts and ends at word boundaries.
         */
        function isNonSpace(chunk) {
            return !Array.from(chunk).map(property).every(function (wb) {
                return (wb === 3 /* CR */ ||
                    wb === 1 /* LF */ ||
                    wb === 2 /* Newline */ ||
                    wb === 4 /* WSegSpace */);
            });
        }
        /**
         * Yields a series of string indices where a word break should
         * occur. That is, there should be a break BEFORE each string
         * index yielded by this generator.
         *
         * @param text Text to find word boundaries in.
         */
        function findBoundaries(text) {
            var _a, _b, _c;
            // WB1 and WB2: no boundaries if given an empty string.
            if (text.length === 0) {
                // There are no boundaries in an empty string!
                return [];
            }
            // This algorithm works by maintaining a sliding window of four SCALAR VALUES.
            //
            //  - Scalar values? JavaScript strings are NOT actually a string of
            //    Unicode code points; some characters are made up of TWO
            //    JavaScript indices. e.g.,
            //        "💩".length === 2;
            //        "💩"[0] === '\uD83D';
            //        "💩"[1] === '\uDCA9';
            //
            //    These characters that are represented by TWO indices are
            //    called "surrogate pairs". Since we don't want to be in the
            //    "middle" of a character, make sure we're always advancing
            //    by scalar values, and NOT indices. That means, we sometimes
            //    need to advance by TWO indices, not just one.
            //  - Four values? Some rules look at what's to the left of
            //    left, and some look at what's to the right of right. So
            //    keep track of this!
            var boundaries = [];
            var rightPos;
            var lookaheadPos = 0; // lookahead, one scalar value to the right of right.
            // Before the start of the string is also the start of the string.
            var lookbehind;
            var left = 19 /* sot */;
            var right = 19 /* sot */;
            var lookahead = wordbreakPropertyAt(0);
            // Count RIs to make sure we're not splitting emoji flags:
            var nConsecutiveRegionalIndicators = 0;
            do {
                // Shift all positions, one scalar value to the right.
                rightPos = lookaheadPos;
                lookaheadPos = positionAfter(lookaheadPos);
                // Shift all properties, one scalar value to the right.
                _a = [left, right, lookahead, wordbreakPropertyAt(lookaheadPos)], lookbehind = _a[0], left = _a[1], right = _a[2], lookahead = _a[3];
                // Break at the start and end of text, unless the text is empty.
                // WB1: Break at start of text...
                if (left === 19 /* sot */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // WB2: Break at the end of text...
                if (right === 20 /* eot */) {
                    boundaries.push(rightPos);
                    break; // Reached the end of the string. We're done!
                }
                // WB3: Do not break within CRLF:
                if (left === 3 /* CR */ && right === 1 /* LF */)
                    continue;
                // WB3b: Otherwise, break after...
                if (left === 2 /* Newline */ ||
                    left === 3 /* CR */ ||
                    left === 1 /* LF */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // WB3a: ...and before newlines
                if (right === 2 /* Newline */ ||
                    right === 3 /* CR */ ||
                    right === 1 /* LF */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // TODO: WB3c is not implemented, due to its complex, error-prone
                // implementation, requiring a ginormous regexp, and the fact that
                // the only thing it does is prevent big emoji sequences from being
                // split up, like 🧚🏼‍♂️
                // https://www.unicode.org/Public/emoji/12.0/emoji-zwj-sequences.txt
                // WB3d: Keep horizontal whitespace together
                if (left === 4 /* WSegSpace */ && right == 4 /* WSegSpace */)
                    continue;
                // WB4: Ignore format and extend characters
                // This is to keep grapheme clusters together!
                // See: Section 6.2: https://unicode.org/reports/tr29/#Grapheme_Cluster_and_Format_Rules
                // N.B.: The rule about "except after sot, CR, LF, and
                // Newline" already been by WB1, WB2, WB3a, and WB3b above.
                while (right === 13 /* Format */ ||
                    right === 14 /* Extend */ ||
                    right === 16 /* ZWJ */) {
                    // Continue advancing in the string, as if these
                    // characters do not exist. DO NOT update left and
                    // lookbehind however!
                    _b = [lookaheadPos, positionAfter(lookaheadPos)], rightPos = _b[0], lookaheadPos = _b[1];
                    _c = [lookahead, wordbreakPropertyAt(lookaheadPos)], right = _c[0], lookahead = _c[1];
                }
                // In ignoring the characters in the previous loop, we could
                // have fallen off the end of the string, so end the loop
                // prematurely if that happens!
                if (right === 20 /* eot */) {
                    boundaries.push(rightPos);
                    break;
                }
                // WB4 (continued): Lookahead must ALSO ignore these format,
                // extend, ZWJ characters!
                while (lookahead === 13 /* Format */ ||
                    lookahead === 14 /* Extend */ ||
                    lookahead === 16 /* ZWJ */) {
                    // Continue advancing in the string, as if these
                    // characters do not exist. DO NOT update left and right,
                    // however!
                    lookaheadPos = positionAfter(lookaheadPos);
                    lookahead = wordbreakPropertyAt(lookaheadPos);
                }
                // WB5: Do not break between most letters.
                if (isAHLetter(left) && isAHLetter(right))
                    continue;
                // Do not break across certain punctuation
                // WB6: (Don't break before apostrophes in contractions)
                if (isAHLetter(left) && isAHLetter(lookahead) &&
                    (right === 10 /* MidLetter */ || isMidNumLetQ(right)))
                    continue;
                // WB7: (Don't break after apostrophes in contractions)
                if (isAHLetter(lookbehind) && isAHLetter(right) &&
                    (left === 10 /* MidLetter */ || isMidNumLetQ(left)))
                    continue;
                // WB7a
                if (left === 15 /* Hebrew_Letter */ && right === 6 /* Single_Quote */)
                    continue;
                // WB7b
                if (left === 15 /* Hebrew_Letter */ && right === 5 /* Double_Quote */ &&
                    lookahead === 15 /* Hebrew_Letter */)
                    continue;
                // WB7c
                if (lookbehind === 15 /* Hebrew_Letter */ && left === 5 /* Double_Quote */ &&
                    right === 15 /* Hebrew_Letter */)
                    continue;
                // Do not break within sequences of digits, or digits adjacent to letters.
                // e.g., "3a" or "A3"
                // WB8
                if (left === 9 /* Numeric */ && right === 9 /* Numeric */)
                    continue;
                // WB9
                if (isAHLetter(left) && right === 9 /* Numeric */)
                    continue;
                // WB10
                if (left === 9 /* Numeric */ && isAHLetter(right))
                    continue;
                // Do not break within sequences, such as 3.2, 3,456.789
                // WB11
                if (lookbehind === 9 /* Numeric */ && right === 9 /* Numeric */ &&
                    (left === 7 /* MidNum */ || isMidNumLetQ(left)))
                    continue;
                // WB12
                if (left === 9 /* Numeric */ && lookahead === 9 /* Numeric */ &&
                    (right === 7 /* MidNum */ || isMidNumLetQ(right)))
                    continue;
                // WB13: Do not break between Katakana
                if (left === 17 /* Katakana */ && right === 17 /* Katakana */)
                    continue;
                // Do not break from extenders (e.g., U+202F NARROW NO-BREAK SPACE)
                // WB13a
                if ((isAHLetter(left) ||
                    left === 9 /* Numeric */ ||
                    left === 17 /* Katakana */ ||
                    left === 12 /* ExtendNumLet */) &&
                    right === 12 /* ExtendNumLet */)
                    continue;
                // WB13b
                if ((isAHLetter(right) ||
                    right === 9 /* Numeric */ ||
                    right === 17 /* Katakana */) && left === 12 /* ExtendNumLet */)
                    continue;
                // WB15 & WB16:
                // Do not break within emoji flag sequences. That is, do not break between
                // regional indicator (RI) symbols if there is an odd number of RI
                // characters before the break point.
                if (right === 18 /* Regional_Indicator */) {
                    // Emoji flags are actually composed of TWO scalar values, each being a
                    // "regional indicator". These indicators correspond to Latin letters. Put
                    // two of them together, and they spell out an ISO 3166-1-alpha-2 country
                    // code. Since these always come in pairs, NEVER split the pairs! So, if
                    // we happen to be inside the middle of an odd numbered of
                    // Regional_Indicators, DON'T SPLIT IT!
                    nConsecutiveRegionalIndicators += 1;
                    if ((nConsecutiveRegionalIndicators % 2) == 1) {
                        continue;
                    }
                }
                else {
                    nConsecutiveRegionalIndicators = 0;
                }
                // WB999: Otherwise, break EVERYWHERE (including around ideographs)
                boundaries.push(rightPos);
            } while (rightPos < text.length);
            return boundaries;
            ///// Internal utility functions /////
            /**
             * Returns the position of the start of the next scalar value. This jumps
             * over surrogate pairs.
             *
             * If asked for the character AFTER the end of the string, this always
             * returns the length of the string.
             */
            function positionAfter(pos) {
                if (pos >= text.length) {
                    return text.length;
                }
                else if (isStartOfSurrogatePair(text[pos])) {
                    return pos + 2;
                }
                return pos + 1;
            }
            /**
             * Return the value of the Word_Break property at the given string index.
             * @param pos position in the text.
             */
            function wordbreakPropertyAt(pos) {
                if (pos < 0) {
                    return 19 /* sot */; // Always "start of string" before the string starts!
                }
                else if (pos >= text.length) {
                    return 20 /* eot */; // Always "end of string" after the string ends!
                }
                else if (isStartOfSurrogatePair(text[pos])) {
                    // Surrogate pairs the next TWO items from the string!
                    return property(text[pos] + text[pos + 1]);
                }
                return property(text[pos]);
            }
            // Word_Break rule macros
            // See: https://unicode.org/reports/tr29/#WB_Rule_Macros
            function isAHLetter(prop) {
                return prop === 11 /* ALetter */ ||
                    prop === 15 /* Hebrew_Letter */;
            }
            function isMidNumLetQ(prop) {
                return prop === 8 /* MidNumLet */ ||
                    prop === 6 /* Single_Quote */;
            }
        }
        function isStartOfSurrogatePair(character) {
            var codeUnit = character.charCodeAt(0);
            return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;
        }
        /**
         * Return the Word_Break property value for a character.
         * Note that
         * @param character a scalar value
         */
        function property(character) {
            // This MUST be a scalar value.
            // TODO: remove dependence on character.codepointAt()?
            var codepoint = character.codePointAt(0);
            return searchForProperty(codepoint, 0, WORD_BREAK_PROPERTY.length - 1);
        }
        /**
         * Binary search for the word break property of a given CODE POINT.
         */
        function searchForProperty(codePoint, left, right) {
            // All items that are not found in the array are assigned the 'Other' property.
            if (right < left) {
                return 0 /* Other */;
            }
            var midpoint = left + ~~((right - left) / 2);
            var candidate = WORD_BREAK_PROPERTY[midpoint];
            if (codePoint < candidate[0 /* Start */]) {
                return searchForProperty(codePoint, left, midpoint - 1);
            }
            else if (codePoint > candidate[1 /* End */]) {
                return searchForProperty(codePoint, midpoint + 1, right);
            }
            else {
                // We found it!
                return candidate[2 /* Value */];
            }
        }
    })(wordBreakers || (wordBreakers = {}));
    // We cannot export a member whose name is a reserved word when
    // implementing a namespace, BUT we can manually make the
    // assignment and **declare** it as part of the namespace.
    wordBreakers['default'] = wordBreakers.default_;
    //# sourceMappingURL=index.js.map
}
/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */
(function (e, t) { if (typeof define === "function" && define.amd) {
    define(t);
}
else if (typeof exports === "object") {
    module.exports = t();
}
else {
    e.returnExports = t();
} })(this, function () {
    "use strict";
    var e = Function.call.bind(Function.apply);
    var t = Function.call.bind(Function.call);
    var r = Array.isArray;
    var n = Object.keys;
    var o = function notThunker(t) { return function notThunk() { return !e(t, this, arguments); }; };
    var i = function (e) { try {
        e();
        return false;
    }
    catch (t) {
        return true;
    } };
    var a = function valueOrFalseIfThrows(e) { try {
        return e();
    }
    catch (t) {
        return false;
    } };
    var u = o(i);
    var f = function () { return !i(function () { return Object.defineProperty({}, "x", { get: function () { } }); }); };
    var s = !!Object.defineProperty && f();
    var c = function foo() { }.name === "foo";
    var l = Function.call.bind(Array.prototype.forEach);
    var p = Function.call.bind(Array.prototype.reduce);
    var v = Function.call.bind(Array.prototype.filter);
    var y = Function.call.bind(Array.prototype.some);
    var h = function (e, t, r, n) { if (!n && t in e) {
        return;
    } if (s) {
        Object.defineProperty(e, t, { configurable: true, enumerable: false, writable: true, value: r });
    }
    else {
        e[t] = r;
    } };
    var b = function (e, t, r) { l(n(t), function (n) { var o = t[n]; h(e, n, o, !!r); }); };
    var g = Function.call.bind(Object.prototype.toString);
    var d = typeof /abc/ === "function" ? function IsCallableSlow(e) { return typeof e === "function" && g(e) === "[object Function]"; } : function IsCallableFast(e) { return typeof e === "function"; };
    var m = { getter: function (e, t, r) { if (!s) {
            throw new TypeError("getters require true ES5 support");
        } Object.defineProperty(e, t, { configurable: true, enumerable: false, get: r }); }, proxy: function (e, t, r) { if (!s) {
            throw new TypeError("getters require true ES5 support");
        } var n = Object.getOwnPropertyDescriptor(e, t); Object.defineProperty(r, t, { configurable: n.configurable, enumerable: n.enumerable, get: function getKey() { return e[t]; }, set: function setKey(r) { e[t] = r; } }); }, redefine: function (e, t, r) { if (s) {
            var n = Object.getOwnPropertyDescriptor(e, t);
            n.value = r;
            Object.defineProperty(e, t, n);
        }
        else {
            e[t] = r;
        } }, defineByDescriptor: function (e, t, r) { if (s) {
            Object.defineProperty(e, t, r);
        }
        else if ("value" in r) {
            e[t] = r.value;
        } }, preserveToString: function (e, t) { if (t && d(t.toString)) {
            h(e, "toString", t.toString.bind(t), true);
        } } };
    var O = Object.create || function (e, t) { var r = function Prototype() { }; r.prototype = e; var o = new r; if (typeof t !== "undefined") {
        n(t).forEach(function (e) { m.defineByDescriptor(o, e, t[e]); });
    } return o; };
    var w = function (e, t) { if (!Object.setPrototypeOf) {
        return false;
    } return a(function () { var r = function Subclass(t) { var r = new e(t); Object.setPrototypeOf(r, Subclass.prototype); return r; }; Object.setPrototypeOf(r, e); r.prototype = O(e.prototype, { constructor: { value: r } }); return t(r); }); };
    var j = function () { if (typeof self !== "undefined") {
        return self;
    } if (typeof window !== "undefined") {
        return window;
    } if (typeof global !== "undefined") {
        return global;
    } throw new Error("unable to locate global object"); };
    var S = j();
    var T = S.isFinite;
    var I = Function.call.bind(String.prototype.indexOf);
    var E = Function.apply.bind(Array.prototype.indexOf);
    var P = Function.call.bind(Array.prototype.concat);
    var C = Function.call.bind(String.prototype.slice);
    var M = Function.call.bind(Array.prototype.push);
    var x = Function.apply.bind(Array.prototype.push);
    var N = Function.call.bind(Array.prototype.shift);
    var A = Math.max;
    var R = Math.min;
    var _ = Math.floor;
    var k = Math.abs;
    var L = Math.exp;
    var F = Math.log;
    var D = Math.sqrt;
    var z = Function.call.bind(Object.prototype.hasOwnProperty);
    var q;
    var W = function () { };
    var G = S.Map;
    var H = G && G.prototype["delete"];
    var V = G && G.prototype.get;
    var B = G && G.prototype.has;
    var U = G && G.prototype.set;
    var $ = S.Symbol || {};
    var J = $.species || "@@species";
    var X = Number.isNaN || function isNaN(e) { return e !== e; };
    var K = Number.isFinite || function isFinite(e) { return typeof e === "number" && T(e); };
    var Z = d(Math.sign) ? Math.sign : function sign(e) { var t = Number(e); if (t === 0) {
        return t;
    } if (X(t)) {
        return t;
    } return t < 0 ? -1 : 1; };
    var Y = function log1p(e) { var t = Number(e); if (t < -1 || X(t)) {
        return NaN;
    } if (t === 0 || t === Infinity) {
        return t;
    } if (t === -1) {
        return -Infinity;
    } return 1 + t - 1 === 0 ? t : t * (F(1 + t) / (1 + t - 1)); };
    var Q = function isArguments(e) { return g(e) === "[object Arguments]"; };
    var ee = function isArguments(e) { return e !== null && typeof e === "object" && typeof e.length === "number" && e.length >= 0 && g(e) !== "[object Array]" && g(e.callee) === "[object Function]"; };
    var te = Q(arguments) ? Q : ee;
    var re = { primitive: function (e) { return e === null || typeof e !== "function" && typeof e !== "object"; }, string: function (e) { return g(e) === "[object String]"; }, regex: function (e) { return g(e) === "[object RegExp]"; }, symbol: function (e) { return typeof S.Symbol === "function" && typeof e === "symbol"; } };
    var ne = function overrideNative(e, t, r) { var n = e[t]; h(e, t, r, true); m.preserveToString(e[t], n); };
    var oe = typeof $ === "function" && typeof $["for"] === "function" && re.symbol($());
    var ie = re.symbol($.iterator) ? $.iterator : "_es6-shim iterator_";
    if (S.Set && typeof (new S.Set)["@@iterator"] === "function") {
        ie = "@@iterator";
    }
    if (!S.Reflect) {
        h(S, "Reflect", {}, true);
    }
    var ae = S.Reflect;
    var ue = String;
    var fe = typeof document === "undefined" || !document ? null : document.all;
    var se = fe == null ? function isNullOrUndefined(e) { return e == null; } : function isNullOrUndefinedAndNotDocumentAll(e) { return e == null && e !== fe; };
    var ce = { Call: function Call(t, r) { var n = arguments.length > 2 ? arguments[2] : []; if (!ce.IsCallable(t)) {
            throw new TypeError(t + " is not a function");
        } return e(t, r, n); }, RequireObjectCoercible: function (e, t) { if (se(e)) {
            throw new TypeError(t || "Cannot call method on " + e);
        } return e; }, TypeIsObject: function (e) { if (e === void 0 || e === null || e === true || e === false) {
            return false;
        } return typeof e === "function" || typeof e === "object" || e === fe; }, ToObject: function (e, t) { return Object(ce.RequireObjectCoercible(e, t)); }, IsCallable: d, IsConstructor: function (e) { return ce.IsCallable(e); }, ToInt32: function (e) { return ce.ToNumber(e) >> 0; }, ToUint32: function (e) { return ce.ToNumber(e) >>> 0; }, ToNumber: function (e) { if (g(e) === "[object Symbol]") {
            throw new TypeError("Cannot convert a Symbol value to a number");
        } return +e; }, ToInteger: function (e) { var t = ce.ToNumber(e); if (X(t)) {
            return 0;
        } if (t === 0 || !K(t)) {
            return t;
        } return (t > 0 ? 1 : -1) * _(k(t)); }, ToLength: function (e) { var t = ce.ToInteger(e); if (t <= 0) {
            return 0;
        } if (t > Number.MAX_SAFE_INTEGER) {
            return Number.MAX_SAFE_INTEGER;
        } return t; }, SameValue: function (e, t) { if (e === t) {
            if (e === 0) {
                return 1 / e === 1 / t;
            }
            return true;
        } return X(e) && X(t); }, SameValueZero: function (e, t) { return e === t || X(e) && X(t); }, IsIterable: function (e) { return ce.TypeIsObject(e) && (typeof e[ie] !== "undefined" || te(e)); }, GetIterator: function (e) { if (te(e)) {
            return new q(e, "value");
        } var t = ce.GetMethod(e, ie); if (!ce.IsCallable(t)) {
            throw new TypeError("value is not an iterable");
        } var r = ce.Call(t, e); if (!ce.TypeIsObject(r)) {
            throw new TypeError("bad iterator");
        } return r; }, GetMethod: function (e, t) { var r = ce.ToObject(e)[t]; if (se(r)) {
            return void 0;
        } if (!ce.IsCallable(r)) {
            throw new TypeError("Method not callable: " + t);
        } return r; }, IteratorComplete: function (e) { return !!e.done; }, IteratorClose: function (e, t) { var r = ce.GetMethod(e, "return"); if (r === void 0) {
            return;
        } var n, o; try {
            n = ce.Call(r, e);
        }
        catch (i) {
            o = i;
        } if (t) {
            return;
        } if (o) {
            throw o;
        } if (!ce.TypeIsObject(n)) {
            throw new TypeError("Iterator's return method returned a non-object.");
        } }, IteratorNext: function (e) { var t = arguments.length > 1 ? e.next(arguments[1]) : e.next(); if (!ce.TypeIsObject(t)) {
            throw new TypeError("bad iterator");
        } return t; }, IteratorStep: function (e) { var t = ce.IteratorNext(e); var r = ce.IteratorComplete(t); return r ? false : t; }, Construct: function (e, t, r, n) { var o = typeof r === "undefined" ? e : r; if (!n && ae.construct) {
            return ae.construct(e, t, o);
        } var i = o.prototype; if (!ce.TypeIsObject(i)) {
            i = Object.prototype;
        } var a = O(i); var u = ce.Call(e, a, t); return ce.TypeIsObject(u) ? u : a; }, SpeciesConstructor: function (e, t) { var r = e.constructor; if (r === void 0) {
            return t;
        } if (!ce.TypeIsObject(r)) {
            throw new TypeError("Bad constructor");
        } var n = r[J]; if (se(n)) {
            return t;
        } if (!ce.IsConstructor(n)) {
            throw new TypeError("Bad @@species");
        } return n; }, CreateHTML: function (e, t, r, n) { var o = ce.ToString(e); var i = "<" + t; if (r !== "") {
            var a = ce.ToString(n);
            var u = a.replace(/"/g, "&quot;");
            i += " " + r + '="' + u + '"';
        } var f = i + ">"; var s = f + o; return s + "</" + t + ">"; }, IsRegExp: function IsRegExp(e) { if (!ce.TypeIsObject(e)) {
            return false;
        } var t = e[$.match]; if (typeof t !== "undefined") {
            return !!t;
        } return re.regex(e); }, ToString: function ToString(e) { return ue(e); } };
    if (s && oe) {
        var le = function defineWellKnownSymbol(e) { if (re.symbol($[e])) {
            return $[e];
        } var t = $["for"]("Symbol." + e); Object.defineProperty($, e, { configurable: false, enumerable: false, writable: false, value: t }); return t; };
        if (!re.symbol($.search)) {
            var pe = le("search");
            var ve = String.prototype.search;
            h(RegExp.prototype, pe, function search(e) { return ce.Call(ve, e, [this]); });
            var ye = function search(e) { var t = ce.RequireObjectCoercible(this); if (!se(e)) {
                var r = ce.GetMethod(e, pe);
                if (typeof r !== "undefined") {
                    return ce.Call(r, e, [t]);
                }
            } return ce.Call(ve, t, [ce.ToString(e)]); };
            ne(String.prototype, "search", ye);
        }
        if (!re.symbol($.replace)) {
            var he = le("replace");
            var be = String.prototype.replace;
            h(RegExp.prototype, he, function replace(e, t) { return ce.Call(be, e, [this, t]); });
            var ge = function replace(e, t) { var r = ce.RequireObjectCoercible(this); if (!se(e)) {
                var n = ce.GetMethod(e, he);
                if (typeof n !== "undefined") {
                    return ce.Call(n, e, [r, t]);
                }
            } return ce.Call(be, r, [ce.ToString(e), t]); };
            ne(String.prototype, "replace", ge);
        }
        if (!re.symbol($.split)) {
            var de = le("split");
            var me = String.prototype.split;
            h(RegExp.prototype, de, function split(e, t) { return ce.Call(me, e, [this, t]); });
            var Oe = function split(e, t) { var r = ce.RequireObjectCoercible(this); if (!se(e)) {
                var n = ce.GetMethod(e, de);
                if (typeof n !== "undefined") {
                    return ce.Call(n, e, [r, t]);
                }
            } return ce.Call(me, r, [ce.ToString(e), t]); };
            ne(String.prototype, "split", Oe);
        }
        var we = re.symbol($.match);
        var je = we && function () { var e = {}; e[$.match] = function () { return 42; }; return "a".match(e) !== 42; }();
        if (!we || je) {
            var Se = le("match");
            var Te = String.prototype.match;
            h(RegExp.prototype, Se, function match(e) { return ce.Call(Te, e, [this]); });
            var Ie = function match(e) { var t = ce.RequireObjectCoercible(this); if (!se(e)) {
                var r = ce.GetMethod(e, Se);
                if (typeof r !== "undefined") {
                    return ce.Call(r, e, [t]);
                }
            } return ce.Call(Te, t, [ce.ToString(e)]); };
            ne(String.prototype, "match", Ie);
        }
    }
    var Ee = function wrapConstructor(e, t, r) { m.preserveToString(t, e); if (Object.setPrototypeOf) {
        Object.setPrototypeOf(e, t);
    } if (s) {
        l(Object.getOwnPropertyNames(e), function (n) { if (n in W || r[n]) {
            return;
        } m.proxy(e, n, t); });
    }
    else {
        l(Object.keys(e), function (n) { if (n in W || r[n]) {
            return;
        } t[n] = e[n]; });
    } t.prototype = e.prototype; m.redefine(e.prototype, "constructor", t); };
    var Pe = function () { return this; };
    var Ce = function (e) { if (s && !z(e, J)) {
        m.getter(e, J, Pe);
    } };
    var Me = function (e, t) { var r = t || function iterator() { return this; }; h(e, ie, r); if (!e[ie] && re.symbol(ie)) {
        e[ie] = r;
    } };
    var xe = function createDataProperty(e, t, r) { if (s) {
        Object.defineProperty(e, t, { configurable: true, enumerable: true, writable: true, value: r });
    }
    else {
        e[t] = r;
    } };
    var Ne = function createDataPropertyOrThrow(e, t, r) { xe(e, t, r); if (!ce.SameValue(e[t], r)) {
        throw new TypeError("property is nonconfigurable");
    } };
    var Ae = function (e, t, r, n) { if (!ce.TypeIsObject(e)) {
        throw new TypeError("Constructor requires `new`: " + t.name);
    } var o = t.prototype; if (!ce.TypeIsObject(o)) {
        o = r;
    } var i = O(o); for (var a in n) {
        if (z(n, a)) {
            var u = n[a];
            h(i, a, u, true);
        }
    } return i; };
    if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
        var Re = String.fromCodePoint;
        ne(String, "fromCodePoint", function fromCodePoint(e) { return ce.Call(Re, this, arguments); });
    }
    var _e = { fromCodePoint: function fromCodePoint(e) { var t = []; var r; for (var n = 0, o = arguments.length; n < o; n++) {
            r = Number(arguments[n]);
            if (!ce.SameValue(r, ce.ToInteger(r)) || r < 0 || r > 1114111) {
                throw new RangeError("Invalid code point " + r);
            }
            if (r < 65536) {
                M(t, String.fromCharCode(r));
            }
            else {
                r -= 65536;
                M(t, String.fromCharCode((r >> 10) + 55296));
                M(t, String.fromCharCode(r % 1024 + 56320));
            }
        } return t.join(""); }, raw: function raw(e) { var t = ce.ToObject(e, "bad callSite"); var r = ce.ToObject(t.raw, "bad raw value"); var n = r.length; var o = ce.ToLength(n); if (o <= 0) {
            return "";
        } var i = []; var a = 0; var u, f, s, c; while (a < o) {
            u = ce.ToString(a);
            s = ce.ToString(r[u]);
            M(i, s);
            if (a + 1 >= o) {
                break;
            }
            f = a + 1 < arguments.length ? arguments[a + 1] : "";
            c = ce.ToString(f);
            M(i, c);
            a += 1;
        } return i.join(""); } };
    if (String.raw && String.raw({ raw: { 0: "x", 1: "y", length: 2 } }) !== "xy") {
        ne(String, "raw", _e.raw);
    }
    b(String, _e);
    var ke = function repeat(e, t) { if (t < 1) {
        return "";
    } if (t % 2) {
        return repeat(e, t - 1) + e;
    } var r = repeat(e, t / 2); return r + r; };
    var Le = Infinity;
    var Fe = { repeat: function repeat(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); var r = ce.ToInteger(e); if (r < 0 || r >= Le) {
            throw new RangeError("repeat count must be less than infinity and not overflow maximum string size");
        } return ke(t, r); }, startsWith: function startsWith(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); if (ce.IsRegExp(e)) {
            throw new TypeError('Cannot call method "startsWith" with a regex');
        } var r = ce.ToString(e); var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o = A(ce.ToInteger(n), 0); return C(t, o, o + r.length) === r; }, endsWith: function endsWith(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); if (ce.IsRegExp(e)) {
            throw new TypeError('Cannot call method "endsWith" with a regex');
        } var r = ce.ToString(e); var n = t.length; var o; if (arguments.length > 1) {
            o = arguments[1];
        } var i = typeof o === "undefined" ? n : ce.ToInteger(o); var a = R(A(i, 0), n); return C(t, a - r.length, a) === r; }, includes: function includes(e) { if (ce.IsRegExp(e)) {
            throw new TypeError('"includes" does not accept a RegExp');
        } var t = ce.ToString(e); var r; if (arguments.length > 1) {
            r = arguments[1];
        } return I(this, t, r) !== -1; }, codePointAt: function codePointAt(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); var r = ce.ToInteger(e); var n = t.length; if (r >= 0 && r < n) {
            var o = t.charCodeAt(r);
            var i = r + 1 === n;
            if (o < 55296 || o > 56319 || i) {
                return o;
            }
            var a = t.charCodeAt(r + 1);
            if (a < 56320 || a > 57343) {
                return o;
            }
            return (o - 55296) * 1024 + (a - 56320) + 65536;
        } } };
    if (String.prototype.includes && "a".includes("a", Infinity) !== false) {
        ne(String.prototype, "includes", Fe.includes);
    }
    if (String.prototype.startsWith && String.prototype.endsWith) {
        var De = i(function () { return "/a/".startsWith(/a/); });
        var ze = a(function () { return "abc".startsWith("a", Infinity) === false; });
        if (!De || !ze) {
            ne(String.prototype, "startsWith", Fe.startsWith);
            ne(String.prototype, "endsWith", Fe.endsWith);
        }
    }
    if (oe) {
        var qe = a(function () { var e = /a/; e[$.match] = false; return "/a/".startsWith(e); });
        if (!qe) {
            ne(String.prototype, "startsWith", Fe.startsWith);
        }
        var We = a(function () { var e = /a/; e[$.match] = false; return "/a/".endsWith(e); });
        if (!We) {
            ne(String.prototype, "endsWith", Fe.endsWith);
        }
        var Ge = a(function () { var e = /a/; e[$.match] = false; return "/a/".includes(e); });
        if (!Ge) {
            ne(String.prototype, "includes", Fe.includes);
        }
    }
    b(String.prototype, Fe);
    var He = ["\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003", "\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028", "\u2029\ufeff"].join("");
    var Ve = new RegExp("(^[" + He + "]+)|([" + He + "]+$)", "g");
    var Be = function trim() { return ce.ToString(ce.RequireObjectCoercible(this)).replace(Ve, ""); };
    var Ue = ["\x85", "\u200b", "\ufffe"].join("");
    var $e = new RegExp("[" + Ue + "]", "g");
    var Je = /^[-+]0x[0-9a-f]+$/i;
    var Xe = Ue.trim().length !== Ue.length;
    h(String.prototype, "trim", Be, Xe);
    var Ke = function (e) { return { value: e, done: arguments.length === 0 }; };
    var Ze = function (e) { ce.RequireObjectCoercible(e); this._s = ce.ToString(e); this._i = 0; };
    Ze.prototype.next = function () { var e = this._s; var t = this._i; if (typeof e === "undefined" || t >= e.length) {
        this._s = void 0;
        return Ke();
    } var r = e.charCodeAt(t); var n, o; if (r < 55296 || r > 56319 || t + 1 === e.length) {
        o = 1;
    }
    else {
        n = e.charCodeAt(t + 1);
        o = n < 56320 || n > 57343 ? 1 : 2;
    } this._i = t + o; return Ke(e.substr(t, o)); };
    Me(Ze.prototype);
    Me(String.prototype, function () { return new Ze(this); });
    var Ye = { from: function from(e) { var r = this; var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o, i; if (typeof n === "undefined") {
            o = false;
        }
        else {
            if (!ce.IsCallable(n)) {
                throw new TypeError("Array.from: when provided, the second argument must be a function");
            }
            if (arguments.length > 2) {
                i = arguments[2];
            }
            o = true;
        } var a = typeof (te(e) || ce.GetMethod(e, ie)) !== "undefined"; var u, f, s; if (a) {
            f = ce.IsConstructor(r) ? Object(new r) : [];
            var c = ce.GetIterator(e);
            var l, p;
            s = 0;
            while (true) {
                l = ce.IteratorStep(c);
                if (l === false) {
                    break;
                }
                p = l.value;
                try {
                    if (o) {
                        p = typeof i === "undefined" ? n(p, s) : t(n, i, p, s);
                    }
                    f[s] = p;
                }
                catch (v) {
                    ce.IteratorClose(c, true);
                    throw v;
                }
                s += 1;
            }
            u = s;
        }
        else {
            var y = ce.ToObject(e);
            u = ce.ToLength(y.length);
            f = ce.IsConstructor(r) ? Object(new r(u)) : new Array(u);
            var h;
            for (s = 0; s < u; ++s) {
                h = y[s];
                if (o) {
                    h = typeof i === "undefined" ? n(h, s) : t(n, i, h, s);
                }
                Ne(f, s, h);
            }
        } f.length = u; return f; }, of: function of() { var e = arguments.length; var t = this; var n = r(t) || !ce.IsCallable(t) ? new Array(e) : ce.Construct(t, [e]); for (var o = 0; o < e; ++o) {
            Ne(n, o, arguments[o]);
        } n.length = e; return n; } };
    b(Array, Ye);
    Ce(Array);
    q = function (e, t) { this.i = 0; this.array = e; this.kind = t; };
    b(q.prototype, { next: function () { var e = this.i; var t = this.array; if (!(this instanceof q)) {
            throw new TypeError("Not an ArrayIterator");
        } if (typeof t !== "undefined") {
            var r = ce.ToLength(t.length);
            for (; e < r; e++) {
                var n = this.kind;
                var o;
                if (n === "key") {
                    o = e;
                }
                else if (n === "value") {
                    o = t[e];
                }
                else if (n === "entry") {
                    o = [e, t[e]];
                }
                this.i = e + 1;
                return Ke(o);
            }
        } this.array = void 0; return Ke(); } });
    Me(q.prototype);
    var Qe = Array.of === Ye.of || function () { var e = function Foo(e) { this.length = e; }; e.prototype = []; var t = Array.of.apply(e, [1, 2]); return t instanceof e && t.length === 2; }();
    if (!Qe) {
        ne(Array, "of", Ye.of);
    }
    var et = { copyWithin: function copyWithin(e, t) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); var o = ce.ToInteger(e); var i = ce.ToInteger(t); var a = o < 0 ? A(n + o, 0) : R(o, n); var u = i < 0 ? A(n + i, 0) : R(i, n); var f; if (arguments.length > 2) {
            f = arguments[2];
        } var s = typeof f === "undefined" ? n : ce.ToInteger(f); var c = s < 0 ? A(n + s, 0) : R(s, n); var l = R(c - u, n - a); var p = 1; if (u < a && a < u + l) {
            p = -1;
            u += l - 1;
            a += l - 1;
        } while (l > 0) {
            if (u in r) {
                r[a] = r[u];
            }
            else {
                delete r[a];
            }
            u += p;
            a += p;
            l -= 1;
        } return r; }, fill: function fill(e) { var t; if (arguments.length > 1) {
            t = arguments[1];
        } var r; if (arguments.length > 2) {
            r = arguments[2];
        } var n = ce.ToObject(this); var o = ce.ToLength(n.length); t = ce.ToInteger(typeof t === "undefined" ? 0 : t); r = ce.ToInteger(typeof r === "undefined" ? o : r); var i = t < 0 ? A(o + t, 0) : R(t, o); var a = r < 0 ? o + r : r; for (var u = i; u < o && u < a; ++u) {
            n[u] = e;
        } return n; }, find: function find(e) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); if (!ce.IsCallable(e)) {
            throw new TypeError("Array#find: predicate must be a function");
        } var o = arguments.length > 1 ? arguments[1] : null; for (var i = 0, a; i < n; i++) {
            a = r[i];
            if (o) {
                if (t(e, o, a, i, r)) {
                    return a;
                }
            }
            else if (e(a, i, r)) {
                return a;
            }
        } }, findIndex: function findIndex(e) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); if (!ce.IsCallable(e)) {
            throw new TypeError("Array#findIndex: predicate must be a function");
        } var o = arguments.length > 1 ? arguments[1] : null; for (var i = 0; i < n; i++) {
            if (o) {
                if (t(e, o, r[i], i, r)) {
                    return i;
                }
            }
            else if (e(r[i], i, r)) {
                return i;
            }
        } return -1; }, keys: function keys() { return new q(this, "key"); }, values: function values() { return new q(this, "value"); }, entries: function entries() { return new q(this, "entry"); } };
    if (Array.prototype.keys && !ce.IsCallable([1].keys().next)) {
        delete Array.prototype.keys;
    }
    if (Array.prototype.entries && !ce.IsCallable([1].entries().next)) {
        delete Array.prototype.entries;
    }
    if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[ie]) {
        b(Array.prototype, { values: Array.prototype[ie] });
        if (re.symbol($.unscopables)) {
            Array.prototype[$.unscopables].values = true;
        }
    }
    if (c && Array.prototype.values && Array.prototype.values.name !== "values") {
        var tt = Array.prototype.values;
        ne(Array.prototype, "values", function values() { return ce.Call(tt, this, arguments); });
        h(Array.prototype, ie, Array.prototype.values, true);
    }
    b(Array.prototype, et);
    if (1 / [true].indexOf(true, -0) < 0) {
        h(Array.prototype, "indexOf", function indexOf(e) { var t = E(this, arguments); if (t === 0 && 1 / t < 0) {
            return 0;
        } return t; }, true);
    }
    Me(Array.prototype, function () { return this.values(); });
    if (Object.getPrototypeOf) {
        Me(Object.getPrototypeOf([].values()));
    }
    var rt = function () { return a(function () { return Array.from({ length: -1 }).length === 0; }); }();
    var nt = function () { var e = Array.from([0].entries()); return e.length === 1 && r(e[0]) && e[0][0] === 0 && e[0][1] === 0; }();
    if (!rt || !nt) {
        ne(Array, "from", Ye.from);
    }
    var ot = function () { return a(function () { return Array.from([0], void 0); }); }();
    if (!ot) {
        var it = Array.from;
        ne(Array, "from", function from(e) { if (arguments.length > 1 && typeof arguments[1] !== "undefined") {
            return ce.Call(it, this, arguments);
        }
        else {
            return t(it, this, e);
        } });
    }
    var at = -(Math.pow(2, 32) - 1);
    var ut = function (e, r) { var n = { length: at }; n[r ? (n.length >>> 0) - 1 : 0] = true; return a(function () { t(e, n, function () { throw new RangeError("should not reach here"); }, []); return true; }); };
    if (!ut(Array.prototype.forEach)) {
        var ft = Array.prototype.forEach;
        ne(Array.prototype, "forEach", function forEach(e) { return ce.Call(ft, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.map)) {
        var st = Array.prototype.map;
        ne(Array.prototype, "map", function map(e) { return ce.Call(st, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.filter)) {
        var ct = Array.prototype.filter;
        ne(Array.prototype, "filter", function filter(e) { return ce.Call(ct, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.some)) {
        var lt = Array.prototype.some;
        ne(Array.prototype, "some", function some(e) { return ce.Call(lt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.every)) {
        var pt = Array.prototype.every;
        ne(Array.prototype, "every", function every(e) { return ce.Call(pt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.reduce)) {
        var vt = Array.prototype.reduce;
        ne(Array.prototype, "reduce", function reduce(e) { return ce.Call(vt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.reduceRight, true)) {
        var yt = Array.prototype.reduceRight;
        ne(Array.prototype, "reduceRight", function reduceRight(e) { return ce.Call(yt, this.length >= 0 ? this : [], arguments); }, true);
    }
    var ht = Number("0o10") !== 8;
    var bt = Number("0b10") !== 2;
    var gt = y(Ue, function (e) { return Number(e + 0 + e) === 0; });
    if (ht || bt || gt) {
        var dt = Number;
        var mt = /^0b[01]+$/i;
        var Ot = /^0o[0-7]+$/i;
        var wt = mt.test.bind(mt);
        var jt = Ot.test.bind(Ot);
        var St = function (e) { var t; if (typeof e.valueOf === "function") {
            t = e.valueOf();
            if (re.primitive(t)) {
                return t;
            }
        } if (typeof e.toString === "function") {
            t = e.toString();
            if (re.primitive(t)) {
                return t;
            }
        } throw new TypeError("No default value"); };
        var Tt = $e.test.bind($e);
        var It = Je.test.bind(Je);
        var Et = function () { var e = function Number(t) { var r; if (arguments.length > 0) {
            r = re.primitive(t) ? t : St(t, "number");
        }
        else {
            r = 0;
        } if (typeof r === "string") {
            r = ce.Call(Be, r);
            if (wt(r)) {
                r = parseInt(C(r, 2), 2);
            }
            else if (jt(r)) {
                r = parseInt(C(r, 2), 8);
            }
            else if (Tt(r) || It(r)) {
                r = NaN;
            }
        } var n = this; var o = a(function () { dt.prototype.valueOf.call(n); return true; }); if (n instanceof e && !o) {
            return new dt(r);
        } return dt(r); }; return e; }();
        Ee(dt, Et, {});
        b(Et, { NaN: dt.NaN, MAX_VALUE: dt.MAX_VALUE, MIN_VALUE: dt.MIN_VALUE, NEGATIVE_INFINITY: dt.NEGATIVE_INFINITY, POSITIVE_INFINITY: dt.POSITIVE_INFINITY });
        Number = Et;
        m.redefine(S, "Number", Et);
    }
    var Pt = Math.pow(2, 53) - 1;
    b(Number, { MAX_SAFE_INTEGER: Pt, MIN_SAFE_INTEGER: -Pt, EPSILON: 2.220446049250313e-16, parseInt: S.parseInt, parseFloat: S.parseFloat, isFinite: K, isInteger: function isInteger(e) { return K(e) && ce.ToInteger(e) === e; }, isSafeInteger: function isSafeInteger(e) { return Number.isInteger(e) && k(e) <= Number.MAX_SAFE_INTEGER; }, isNaN: X });
    h(Number, "parseInt", S.parseInt, Number.parseInt !== S.parseInt);
    if ([, 1].find(function () { return true; }) === 1) {
        ne(Array.prototype, "find", et.find);
    }
    if ([, 1].findIndex(function () { return true; }) !== 0) {
        ne(Array.prototype, "findIndex", et.findIndex);
    }
    var Ct = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
    var Mt = function ensureEnumerable(e, t) { if (s && Ct(e, t)) {
        Object.defineProperty(e, t, { enumerable: false });
    } };
    var xt = function sliceArgs() { var e = Number(this); var t = arguments.length; var r = t - e; var n = new Array(r < 0 ? 0 : r); for (var o = e; o < t; ++o) {
        n[o - e] = arguments[o];
    } return n; };
    var Nt = function assignTo(e) { return function assignToSource(t, r) { t[r] = e[r]; return t; }; };
    var At = function (e, t) { var r = n(Object(t)); var o; if (ce.IsCallable(Object.getOwnPropertySymbols)) {
        o = v(Object.getOwnPropertySymbols(Object(t)), Ct(t));
    } return p(P(r, o || []), Nt(t), e); };
    var Rt = { assign: function (e, t) { var r = ce.ToObject(e, "Cannot convert undefined or null to object"); return p(ce.Call(xt, 1, arguments), At, r); }, is: function is(e, t) { return ce.SameValue(e, t); } };
    var _t = Object.assign && Object.preventExtensions && function () { var e = Object.preventExtensions({ 1: 2 }); try {
        Object.assign(e, "xy");
    }
    catch (t) {
        return e[1] === "y";
    } }();
    if (_t) {
        ne(Object, "assign", Rt.assign);
    }
    b(Object, Rt);
    if (s) {
        var kt = { setPrototypeOf: function (e, r) { var n; var o = function (e, t) { if (!ce.TypeIsObject(e)) {
                throw new TypeError("cannot set prototype on a non-object");
            } if (!(t === null || ce.TypeIsObject(t))) {
                throw new TypeError("can only set prototype to an object or null" + t);
            } }; var i = function (e, r) { o(e, r); t(n, e, r); return e; }; try {
                n = e.getOwnPropertyDescriptor(e.prototype, r).set;
                t(n, {}, null);
            }
            catch (a) {
                if (e.prototype !== {}[r]) {
                    return;
                }
                n = function (e) { this[r] = e; };
                i.polyfill = i(i({}, null), e.prototype) instanceof e;
            } return i; }(Object, "__proto__") };
        b(Object, kt);
    }
    if (Object.setPrototypeOf && Object.getPrototypeOf && Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null && Object.getPrototypeOf(Object.create(null)) === null) {
        (function () { var e = Object.create(null); var t = Object.getPrototypeOf; var r = Object.setPrototypeOf; Object.getPrototypeOf = function (r) { var n = t(r); return n === e ? null : n; }; Object.setPrototypeOf = function (t, n) { var o = n === null ? e : n; return r(t, o); }; Object.setPrototypeOf.polyfill = false; })();
    }
    var Lt = !i(function () { return Object.keys("foo"); });
    if (!Lt) {
        var Ft = Object.keys;
        ne(Object, "keys", function keys(e) { return Ft(ce.ToObject(e)); });
        n = Object.keys;
    }
    var Dt = i(function () { return Object.keys(/a/g); });
    if (Dt) {
        var zt = Object.keys;
        ne(Object, "keys", function keys(e) { if (re.regex(e)) {
            var t = [];
            for (var r in e) {
                if (z(e, r)) {
                    M(t, r);
                }
            }
            return t;
        } return zt(e); });
        n = Object.keys;
    }
    if (Object.getOwnPropertyNames) {
        var qt = !i(function () { return Object.getOwnPropertyNames("foo"); });
        if (!qt) {
            var Wt = typeof window === "object" ? Object.getOwnPropertyNames(window) : [];
            var Gt = Object.getOwnPropertyNames;
            ne(Object, "getOwnPropertyNames", function getOwnPropertyNames(e) { var t = ce.ToObject(e); if (g(t) === "[object Window]") {
                try {
                    return Gt(t);
                }
                catch (r) {
                    return P([], Wt);
                }
            } return Gt(t); });
        }
    }
    if (Object.getOwnPropertyDescriptor) {
        var Ht = !i(function () { return Object.getOwnPropertyDescriptor("foo", "bar"); });
        if (!Ht) {
            var Vt = Object.getOwnPropertyDescriptor;
            ne(Object, "getOwnPropertyDescriptor", function getOwnPropertyDescriptor(e, t) { return Vt(ce.ToObject(e), t); });
        }
    }
    if (Object.seal) {
        var Bt = !i(function () { return Object.seal("foo"); });
        if (!Bt) {
            var Ut = Object.seal;
            ne(Object, "seal", function seal(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return Ut(e); });
        }
    }
    if (Object.isSealed) {
        var $t = !i(function () { return Object.isSealed("foo"); });
        if (!$t) {
            var Jt = Object.isSealed;
            ne(Object, "isSealed", function isSealed(e) { if (!ce.TypeIsObject(e)) {
                return true;
            } return Jt(e); });
        }
    }
    if (Object.freeze) {
        var Xt = !i(function () { return Object.freeze("foo"); });
        if (!Xt) {
            var Kt = Object.freeze;
            ne(Object, "freeze", function freeze(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return Kt(e); });
        }
    }
    if (Object.isFrozen) {
        var Zt = !i(function () { return Object.isFrozen("foo"); });
        if (!Zt) {
            var Yt = Object.isFrozen;
            ne(Object, "isFrozen", function isFrozen(e) { if (!ce.TypeIsObject(e)) {
                return true;
            } return Yt(e); });
        }
    }
    if (Object.preventExtensions) {
        var Qt = !i(function () { return Object.preventExtensions("foo"); });
        if (!Qt) {
            var er = Object.preventExtensions;
            ne(Object, "preventExtensions", function preventExtensions(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return er(e); });
        }
    }
    if (Object.isExtensible) {
        var tr = !i(function () { return Object.isExtensible("foo"); });
        if (!tr) {
            var rr = Object.isExtensible;
            ne(Object, "isExtensible", function isExtensible(e) { if (!ce.TypeIsObject(e)) {
                return false;
            } return rr(e); });
        }
    }
    if (Object.getPrototypeOf) {
        var nr = !i(function () { return Object.getPrototypeOf("foo"); });
        if (!nr) {
            var or = Object.getPrototypeOf;
            ne(Object, "getPrototypeOf", function getPrototypeOf(e) { return or(ce.ToObject(e)); });
        }
    }
    var ir = s && function () { var e = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags"); return e && ce.IsCallable(e.get); }();
    if (s && !ir) {
        var ar = function flags() { if (!ce.TypeIsObject(this)) {
            throw new TypeError("Method called on incompatible type: must be an object.");
        } var e = ""; if (this.global) {
            e += "g";
        } if (this.ignoreCase) {
            e += "i";
        } if (this.multiline) {
            e += "m";
        } if (this.unicode) {
            e += "u";
        } if (this.sticky) {
            e += "y";
        } return e; };
        m.getter(RegExp.prototype, "flags", ar);
    }
    var ur = s && a(function () { return String(new RegExp(/a/g, "i")) === "/a/i"; });
    var fr = oe && s && function () { var e = /./; e[$.match] = false; return RegExp(e) === e; }();
    var sr = a(function () { return RegExp.prototype.toString.call({ source: "abc" }) === "/abc/"; });
    var cr = sr && a(function () { return RegExp.prototype.toString.call({ source: "a", flags: "b" }) === "/a/b"; });
    if (!sr || !cr) {
        var lr = RegExp.prototype.toString;
        h(RegExp.prototype, "toString", function toString() { var e = ce.RequireObjectCoercible(this); if (re.regex(e)) {
            return t(lr, e);
        } var r = ue(e.source); var n = ue(e.flags); return "/" + r + "/" + n; }, true);
        m.preserveToString(RegExp.prototype.toString, lr);
    }
    if (s && (!ur || fr)) {
        var pr = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags").get;
        var vr = Object.getOwnPropertyDescriptor(RegExp.prototype, "source") || {};
        var yr = function () { return this.source; };
        var hr = ce.IsCallable(vr.get) ? vr.get : yr;
        var br = RegExp;
        var gr = function () { return function RegExp(e, t) { var r = ce.IsRegExp(e); var n = this instanceof RegExp; if (!n && r && typeof t === "undefined" && e.constructor === RegExp) {
            return e;
        } var o = e; var i = t; if (re.regex(e)) {
            o = ce.Call(hr, e);
            i = typeof t === "undefined" ? ce.Call(pr, e) : t;
            return new RegExp(o, i);
        }
        else if (r) {
            o = e.source;
            i = typeof t === "undefined" ? e.flags : t;
        } return new br(e, t); }; }();
        Ee(br, gr, { $input: true });
        RegExp = gr;
        m.redefine(S, "RegExp", gr);
    }
    if (s) {
        var dr = { input: "$_", lastMatch: "$&", lastParen: "$+", leftContext: "$`", rightContext: "$'" };
        l(n(dr), function (e) { if (e in RegExp && !(dr[e] in RegExp)) {
            m.getter(RegExp, dr[e], function get() { return RegExp[e]; });
        } });
    }
    Ce(RegExp);
    var mr = 1 / Number.EPSILON;
    var Or = function roundTiesToEven(e) { return e + mr - mr; };
    var wr = Math.pow(2, -23);
    var jr = Math.pow(2, 127) * (2 - wr);
    var Sr = Math.pow(2, -126);
    var Tr = Math.E;
    var Ir = Math.LOG2E;
    var Er = Math.LOG10E;
    var Pr = Number.prototype.clz;
    delete Number.prototype.clz;
    var Cr = { acosh: function acosh(e) { var t = Number(e); if (X(t) || e < 1) {
            return NaN;
        } if (t === 1) {
            return 0;
        } if (t === Infinity) {
            return t;
        } var r = 1 / (t * t); if (t < 2) {
            return Y(t - 1 + D(1 - r) * t);
        } var n = t / 2; return Y(n + D(1 - r) * n - 1) + 1 / Ir; }, asinh: function asinh(e) { var t = Number(e); if (t === 0 || !T(t)) {
            return t;
        } var r = k(t); var n = r * r; var o = Z(t); if (r < 1) {
            return o * Y(r + n / (D(n + 1) + 1));
        } return o * (Y(r / 2 + D(1 + 1 / n) * r / 2 - 1) + 1 / Ir); }, atanh: function atanh(e) { var t = Number(e); if (t === 0) {
            return t;
        } if (t === -1) {
            return -Infinity;
        } if (t === 1) {
            return Infinity;
        } if (X(t) || t < -1 || t > 1) {
            return NaN;
        } var r = k(t); return Z(t) * Y(2 * r / (1 - r)) / 2; }, cbrt: function cbrt(e) { var t = Number(e); if (t === 0) {
            return t;
        } var r = t < 0; var n; if (r) {
            t = -t;
        } if (t === Infinity) {
            n = Infinity;
        }
        else {
            n = L(F(t) / 3);
            n = (t / (n * n) + 2 * n) / 3;
        } return r ? -n : n; }, clz32: function clz32(e) { var t = Number(e); var r = ce.ToUint32(t); if (r === 0) {
            return 32;
        } return Pr ? ce.Call(Pr, r) : 31 - _(F(r + .5) * Ir); }, cosh: function cosh(e) { var t = Number(e); if (t === 0) {
            return 1;
        } if (X(t)) {
            return NaN;
        } if (!T(t)) {
            return Infinity;
        } var r = L(k(t) - 1); return (r + 1 / (r * Tr * Tr)) * (Tr / 2); }, expm1: function expm1(e) { var t = Number(e); if (t === -Infinity) {
            return -1;
        } if (!T(t) || t === 0) {
            return t;
        } if (k(t) > .5) {
            return L(t) - 1;
        } var r = t; var n = 0; var o = 1; while (n + r !== n) {
            n += r;
            o += 1;
            r *= t / o;
        } return n; }, hypot: function hypot(e, t) { var r = 0; var n = 0; for (var o = 0; o < arguments.length; ++o) {
            var i = k(Number(arguments[o]));
            if (n < i) {
                r *= n / i * (n / i);
                r += 1;
                n = i;
            }
            else {
                r += i > 0 ? i / n * (i / n) : i;
            }
        } return n === Infinity ? Infinity : n * D(r); }, log2: function log2(e) { return F(e) * Ir; }, log10: function log10(e) { return F(e) * Er; }, log1p: Y, sign: Z, sinh: function sinh(e) { var t = Number(e); if (!T(t) || t === 0) {
            return t;
        } var r = k(t); if (r < 1) {
            var n = Math.expm1(r);
            return Z(t) * n * (1 + 1 / (n + 1)) / 2;
        } var o = L(r - 1); return Z(t) * (o - 1 / (o * Tr * Tr)) * (Tr / 2); }, tanh: function tanh(e) { var t = Number(e); if (X(t) || t === 0) {
            return t;
        } if (t >= 20) {
            return 1;
        } if (t <= -20) {
            return -1;
        } return (Math.expm1(t) - Math.expm1(-t)) / (L(t) + L(-t)); }, trunc: function trunc(e) { var t = Number(e); return t < 0 ? -_(-t) : _(t); }, imul: function imul(e, t) { var r = ce.ToUint32(e); var n = ce.ToUint32(t); var o = r >>> 16 & 65535; var i = r & 65535; var a = n >>> 16 & 65535; var u = n & 65535; return i * u + (o * u + i * a << 16 >>> 0) | 0; }, fround: function fround(e) { var t = Number(e); if (t === 0 || t === Infinity || t === -Infinity || X(t)) {
            return t;
        } var r = Z(t); var n = k(t); if (n < Sr) {
            return r * Or(n / Sr / wr) * Sr * wr;
        } var o = (1 + wr / Number.EPSILON) * n; var i = o - (o - n); if (i > jr || X(i)) {
            return r * Infinity;
        } return r * i; } };
    var Mr = function withinULPDistance(e, t, r) { return k(1 - e / t) / Number.EPSILON < (r || 8); };
    b(Math, Cr);
    h(Math, "sinh", Cr.sinh, Math.sinh(710) === Infinity);
    h(Math, "cosh", Cr.cosh, Math.cosh(710) === Infinity);
    h(Math, "log1p", Cr.log1p, Math.log1p(-1e-17) !== -1e-17);
    h(Math, "asinh", Cr.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
    h(Math, "asinh", Cr.asinh, Math.asinh(1e300) === Infinity);
    h(Math, "atanh", Cr.atanh, Math.atanh(1e-300) === 0);
    h(Math, "tanh", Cr.tanh, Math.tanh(-2e-17) !== -2e-17);
    h(Math, "acosh", Cr.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
    h(Math, "acosh", Cr.acosh, !Mr(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
    h(Math, "cbrt", Cr.cbrt, !Mr(Math.cbrt(1e-300), 1e-100));
    h(Math, "sinh", Cr.sinh, Math.sinh(-2e-17) !== -2e-17);
    var xr = Math.expm1(10);
    h(Math, "expm1", Cr.expm1, xr > 22025.465794806718 || xr < 22025.465794806718);
    var Nr = Math.round;
    var Ar = Math.round(.5 - Number.EPSILON / 4) === 0 && Math.round(-.5 + Number.EPSILON / 3.99) === 1;
    var Rr = mr + 1;
    var _r = 2 * mr - 1;
    var kr = [Rr, _r].every(function (e) { return Math.round(e) === e; });
    h(Math, "round", function round(e) { var t = _(e); var r = t === -1 ? -0 : t + 1; return e - t < .5 ? t : r; }, !Ar || !kr);
    m.preserveToString(Math.round, Nr);
    var Lr = Math.imul;
    if (Math.imul(4294967295, 5) !== -5) {
        Math.imul = Cr.imul;
        m.preserveToString(Math.imul, Lr);
    }
    if (Math.imul.length !== 2) {
        ne(Math, "imul", function imul(e, t) { return ce.Call(Lr, Math, arguments); });
    }
    var Fr = function () { var e = S.setTimeout; if (typeof e !== "function" && typeof e !== "object") {
        return;
    } ce.IsPromise = function (e) { if (!ce.TypeIsObject(e)) {
        return false;
    } if (typeof e._promise === "undefined") {
        return false;
    } return true; }; var r = function (e) { if (!ce.IsConstructor(e)) {
        throw new TypeError("Bad promise constructor");
    } var t = this; var r = function (e, r) { if (t.resolve !== void 0 || t.reject !== void 0) {
        throw new TypeError("Bad Promise implementation!");
    } t.resolve = e; t.reject = r; }; t.resolve = void 0; t.reject = void 0; t.promise = new e(r); if (!(ce.IsCallable(t.resolve) && ce.IsCallable(t.reject))) {
        throw new TypeError("Bad promise constructor");
    } }; var n; if (typeof window !== "undefined" && ce.IsCallable(window.postMessage)) {
        n = function () { var e = []; var t = "zero-timeout-message"; var r = function (r) { M(e, r); window.postMessage(t, "*"); }; var n = function (r) { if (r.source === window && r.data === t) {
            r.stopPropagation();
            if (e.length === 0) {
                return;
            }
            var n = N(e);
            n();
        } }; window.addEventListener("message", n, true); return r; };
    } var o = function () { var e = S.Promise; var t = e && e.resolve && e.resolve(); return t && function (e) { return t.then(e); }; }; var i = ce.IsCallable(S.setImmediate) ? S.setImmediate : typeof process === "object" && process.nextTick ? process.nextTick : o() || (ce.IsCallable(n) ? n() : function (t) { e(t, 0); }); var a = function (e) { return e; }; var u = function (e) { throw e; }; var f = 0; var s = 1; var c = 2; var l = 0; var p = 1; var v = 2; var y = {}; var h = function (e, t, r) { i(function () { g(e, t, r); }); }; var g = function (e, t, r) { var n, o; if (t === y) {
        return e(r);
    } try {
        n = e(r);
        o = t.resolve;
    }
    catch (i) {
        n = i;
        o = t.reject;
    } o(n); }; var d = function (e, t) { var r = e._promise; var n = r.reactionLength; if (n > 0) {
        h(r.fulfillReactionHandler0, r.reactionCapability0, t);
        r.fulfillReactionHandler0 = void 0;
        r.rejectReactions0 = void 0;
        r.reactionCapability0 = void 0;
        if (n > 1) {
            for (var o = 1, i = 0; o < n; o++, i += 3) {
                h(r[i + l], r[i + v], t);
                e[i + l] = void 0;
                e[i + p] = void 0;
                e[i + v] = void 0;
            }
        }
    } r.result = t; r.state = s; r.reactionLength = 0; }; var m = function (e, t) { var r = e._promise; var n = r.reactionLength; if (n > 0) {
        h(r.rejectReactionHandler0, r.reactionCapability0, t);
        r.fulfillReactionHandler0 = void 0;
        r.rejectReactions0 = void 0;
        r.reactionCapability0 = void 0;
        if (n > 1) {
            for (var o = 1, i = 0; o < n; o++, i += 3) {
                h(r[i + p], r[i + v], t);
                e[i + l] = void 0;
                e[i + p] = void 0;
                e[i + v] = void 0;
            }
        }
    } r.result = t; r.state = c; r.reactionLength = 0; }; var O = function (e) { var t = false; var r = function (r) { var n; if (t) {
        return;
    } t = true; if (r === e) {
        return m(e, new TypeError("Self resolution"));
    } if (!ce.TypeIsObject(r)) {
        return d(e, r);
    } try {
        n = r.then;
    }
    catch (o) {
        return m(e, o);
    } if (!ce.IsCallable(n)) {
        return d(e, r);
    } i(function () { j(e, r, n); }); }; var n = function (r) { if (t) {
        return;
    } t = true; return m(e, r); }; return { resolve: r, reject: n }; }; var w = function (e, r, n, o) { if (e === I) {
        t(e, r, n, o, y);
    }
    else {
        t(e, r, n, o);
    } }; var j = function (e, t, r) { var n = O(e); var o = n.resolve; var i = n.reject; try {
        w(r, t, o, i);
    }
    catch (a) {
        i(a);
    } }; var T, I; var E = function () { var e = function Promise(t) { if (!(this instanceof e)) {
        throw new TypeError('Constructor Promise requires "new"');
    } if (this && this._promise) {
        throw new TypeError("Bad construction");
    } if (!ce.IsCallable(t)) {
        throw new TypeError("not a valid resolver");
    } var r = Ae(this, e, T, { _promise: { result: void 0, state: f, reactionLength: 0, fulfillReactionHandler0: void 0, rejectReactionHandler0: void 0, reactionCapability0: void 0 } }); var n = O(r); var o = n.reject; try {
        t(n.resolve, o);
    }
    catch (i) {
        o(i);
    } return r; }; return e; }(); T = E.prototype; var P = function (e, t, r, n) { var o = false; return function (i) { if (o) {
        return;
    } o = true; t[e] = i; if (--n.count === 0) {
        var a = r.resolve;
        a(t);
    } }; }; var C = function (e, t, r) { var n = e.iterator; var o = []; var i = { count: 1 }; var a, u; var f = 0; while (true) {
        try {
            a = ce.IteratorStep(n);
            if (a === false) {
                e.done = true;
                break;
            }
            u = a.value;
        }
        catch (s) {
            e.done = true;
            throw s;
        }
        o[f] = void 0;
        var c = t.resolve(u);
        var l = P(f, o, r, i);
        i.count += 1;
        w(c.then, c, l, r.reject);
        f += 1;
    } if (--i.count === 0) {
        var p = r.resolve;
        p(o);
    } return r.promise; }; var x = function (e, t, r) { var n = e.iterator; var o, i, a; while (true) {
        try {
            o = ce.IteratorStep(n);
            if (o === false) {
                e.done = true;
                break;
            }
            i = o.value;
        }
        catch (u) {
            e.done = true;
            throw u;
        }
        a = t.resolve(i);
        w(a.then, a, r.resolve, r.reject);
    } return r.promise; }; b(E, { all: function all(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Promise is not object");
        } var n = new r(t); var o, i; try {
            o = ce.GetIterator(e);
            i = { iterator: o, done: false };
            return C(i, t, n);
        }
        catch (a) {
            var u = a;
            if (i && !i.done) {
                try {
                    ce.IteratorClose(o, true);
                }
                catch (f) {
                    u = f;
                }
            }
            var s = n.reject;
            s(u);
            return n.promise;
        } }, race: function race(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Promise is not object");
        } var n = new r(t); var o, i; try {
            o = ce.GetIterator(e);
            i = { iterator: o, done: false };
            return x(i, t, n);
        }
        catch (a) {
            var u = a;
            if (i && !i.done) {
                try {
                    ce.IteratorClose(o, true);
                }
                catch (f) {
                    u = f;
                }
            }
            var s = n.reject;
            s(u);
            return n.promise;
        } }, reject: function reject(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Bad promise constructor");
        } var n = new r(t); var o = n.reject; o(e); return n.promise; }, resolve: function resolve(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Bad promise constructor");
        } if (ce.IsPromise(e)) {
            var n = e.constructor;
            if (n === t) {
                return e;
            }
        } var o = new r(t); var i = o.resolve; i(e); return o.promise; } }); b(T, { "catch": function (e) { return this.then(null, e); }, then: function then(e, t) { var n = this; if (!ce.IsPromise(n)) {
            throw new TypeError("not a promise");
        } var o = ce.SpeciesConstructor(n, E); var i; var b = arguments.length > 2 && arguments[2] === y; if (b && o === E) {
            i = y;
        }
        else {
            i = new r(o);
        } var g = ce.IsCallable(e) ? e : a; var d = ce.IsCallable(t) ? t : u; var m = n._promise; var O; if (m.state === f) {
            if (m.reactionLength === 0) {
                m.fulfillReactionHandler0 = g;
                m.rejectReactionHandler0 = d;
                m.reactionCapability0 = i;
            }
            else {
                var w = 3 * (m.reactionLength - 1);
                m[w + l] = g;
                m[w + p] = d;
                m[w + v] = i;
            }
            m.reactionLength += 1;
        }
        else if (m.state === s) {
            O = m.result;
            h(g, i, O);
        }
        else if (m.state === c) {
            O = m.result;
            h(d, i, O);
        }
        else {
            throw new TypeError("unexpected Promise state");
        } return i.promise; } }); y = new r(E); I = T.then; return E; }();
    if (S.Promise) {
        delete S.Promise.accept;
        delete S.Promise.defer;
        delete S.Promise.prototype.chain;
    }
    if (typeof Fr === "function") {
        b(S, { Promise: Fr });
        var Dr = w(S.Promise, function (e) { return e.resolve(42).then(function () { }) instanceof e; });
        var zr = !i(function () { return S.Promise.reject(42).then(null, 5).then(null, W); });
        var qr = i(function () { return S.Promise.call(3, W); });
        var Wr = function (e) { var t = e.resolve(5); t.constructor = {}; var r = e.resolve(t); try {
            r.then(null, W).then(null, W);
        }
        catch (n) {
            return true;
        } return t === r; }(S.Promise);
        var Gr = s && function () { var e = 0; var t = Object.defineProperty({}, "then", { get: function () { e += 1; } }); Promise.resolve(t); return e === 1; }();
        var Hr = function BadResolverPromise(e) { var t = new Promise(e); e(3, function () { }); this.then = t.then; this.constructor = BadResolverPromise_2; };
        Hr.prototype = Promise.prototype;
        Hr.all = Promise.all;
        var Vr = a(function () { return !!Hr.all([1, 2]); });
        if (!Dr || !zr || !qr || Wr || !Gr || Vr) {
            Promise = Fr;
            ne(S, "Promise", Fr);
        }
        if (Promise.all.length !== 1) {
            var Br = Promise.all;
            ne(Promise, "all", function all(e) { return ce.Call(Br, this, arguments); });
        }
        if (Promise.race.length !== 1) {
            var Ur = Promise.race;
            ne(Promise, "race", function race(e) { return ce.Call(Ur, this, arguments); });
        }
        if (Promise.resolve.length !== 1) {
            var $r = Promise.resolve;
            ne(Promise, "resolve", function resolve(e) { return ce.Call($r, this, arguments); });
        }
        if (Promise.reject.length !== 1) {
            var Jr = Promise.reject;
            ne(Promise, "reject", function reject(e) { return ce.Call(Jr, this, arguments); });
        }
        Mt(Promise, "all");
        Mt(Promise, "race");
        Mt(Promise, "resolve");
        Mt(Promise, "reject");
        Ce(Promise);
    }
    var Xr = function (e) { var t = n(p(e, function (e, t) { e[t] = true; return e; }, {})); return e.join(":") === t.join(":"); };
    var Kr = Xr(["z", "a", "bb"]);
    var Zr = Xr(["z", 1, "a", "3", 2]);
    if (s) {
        var Yr = function fastkey(e, t) { if (!t && !Kr) {
            return null;
        } if (se(e)) {
            return "^" + ce.ToString(e);
        }
        else if (typeof e === "string") {
            return "$" + e;
        }
        else if (typeof e === "number") {
            if (!Zr) {
                return "n" + e;
            }
            return e;
        }
        else if (typeof e === "boolean") {
            return "b" + e;
        } return null; };
        var Qr = function emptyObject() { return Object.create ? Object.create(null) : {}; };
        var en = function addIterableToMap(e, n, o) { if (r(o) || re.string(o)) {
            l(o, function (e) { if (!ce.TypeIsObject(e)) {
                throw new TypeError("Iterator value " + e + " is not an entry object");
            } n.set(e[0], e[1]); });
        }
        else if (o instanceof e) {
            t(e.prototype.forEach, o, function (e, t) { n.set(t, e); });
        }
        else {
            var i, a;
            if (!se(o)) {
                a = n.set;
                if (!ce.IsCallable(a)) {
                    throw new TypeError("bad map");
                }
                i = ce.GetIterator(o);
            }
            if (typeof i !== "undefined") {
                while (true) {
                    var u = ce.IteratorStep(i);
                    if (u === false) {
                        break;
                    }
                    var f = u.value;
                    try {
                        if (!ce.TypeIsObject(f)) {
                            throw new TypeError("Iterator value " + f + " is not an entry object");
                        }
                        t(a, n, f[0], f[1]);
                    }
                    catch (s) {
                        ce.IteratorClose(i, true);
                        throw s;
                    }
                }
            }
        } };
        var tn = function addIterableToSet(e, n, o) { if (r(o) || re.string(o)) {
            l(o, function (e) { n.add(e); });
        }
        else if (o instanceof e) {
            t(e.prototype.forEach, o, function (e) { n.add(e); });
        }
        else {
            var i, a;
            if (!se(o)) {
                a = n.add;
                if (!ce.IsCallable(a)) {
                    throw new TypeError("bad set");
                }
                i = ce.GetIterator(o);
            }
            if (typeof i !== "undefined") {
                while (true) {
                    var u = ce.IteratorStep(i);
                    if (u === false) {
                        break;
                    }
                    var f = u.value;
                    try {
                        t(a, n, f);
                    }
                    catch (s) {
                        ce.IteratorClose(i, true);
                        throw s;
                    }
                }
            }
        } };
        var rn = { Map: function () { var e = {}; var r = function MapEntry(e, t) { this.key = e; this.value = t; this.next = null; this.prev = null; }; r.prototype.isRemoved = function isRemoved() { return this.key === e; }; var n = function isMap(e) { return !!e._es6map; }; var o = function requireMapSlot(e, t) { if (!ce.TypeIsObject(e) || !n(e)) {
                throw new TypeError("Method Map.prototype." + t + " called on incompatible receiver " + ce.ToString(e));
            } }; var i = function MapIterator(e, t) { o(e, "[[MapIterator]]"); this.head = e._head; this.i = this.head; this.kind = t; }; i.prototype = { isMapIterator: true, next: function next() { if (!this.isMapIterator) {
                    throw new TypeError("Not a MapIterator");
                } var e = this.i; var t = this.kind; var r = this.head; if (typeof this.i === "undefined") {
                    return Ke();
                } while (e.isRemoved() && e !== r) {
                    e = e.prev;
                } var n; while (e.next !== r) {
                    e = e.next;
                    if (!e.isRemoved()) {
                        if (t === "key") {
                            n = e.key;
                        }
                        else if (t === "value") {
                            n = e.value;
                        }
                        else {
                            n = [e.key, e.value];
                        }
                        this.i = e;
                        return Ke(n);
                    }
                } this.i = void 0; return Ke(); } }; Me(i.prototype); var a; var u = function Map() { if (!(this instanceof Map)) {
                throw new TypeError('Constructor Map requires "new"');
            } if (this && this._es6map) {
                throw new TypeError("Bad construction");
            } var e = Ae(this, Map, a, { _es6map: true, _head: null, _map: G ? new G : null, _size: 0, _storage: Qr() }); var t = new r(null, null); t.next = t.prev = t; e._head = t; if (arguments.length > 0) {
                en(Map, e, arguments[0]);
            } return e; }; a = u.prototype; m.getter(a, "size", function () { if (typeof this._size === "undefined") {
                throw new TypeError("size method called on incompatible Map");
            } return this._size; }); b(a, { get: function get(e) { o(this, "get"); var t; var r = Yr(e, true); if (r !== null) {
                    t = this._storage[r];
                    if (t) {
                        return t.value;
                    }
                    else {
                        return;
                    }
                } if (this._map) {
                    t = V.call(this._map, e);
                    if (t) {
                        return t.value;
                    }
                    else {
                        return;
                    }
                } var n = this._head; var i = n; while ((i = i.next) !== n) {
                    if (ce.SameValueZero(i.key, e)) {
                        return i.value;
                    }
                } }, has: function has(e) { o(this, "has"); var t = Yr(e, true); if (t !== null) {
                    return typeof this._storage[t] !== "undefined";
                } if (this._map) {
                    return B.call(this._map, e);
                } var r = this._head; var n = r; while ((n = n.next) !== r) {
                    if (ce.SameValueZero(n.key, e)) {
                        return true;
                    }
                } return false; }, set: function set(e, t) { o(this, "set"); var n = this._head; var i = n; var a; var u = Yr(e, true); if (u !== null) {
                    if (typeof this._storage[u] !== "undefined") {
                        this._storage[u].value = t;
                        return this;
                    }
                    else {
                        a = this._storage[u] = new r(e, t);
                        i = n.prev;
                    }
                }
                else if (this._map) {
                    if (B.call(this._map, e)) {
                        V.call(this._map, e).value = t;
                    }
                    else {
                        a = new r(e, t);
                        U.call(this._map, e, a);
                        i = n.prev;
                    }
                } while ((i = i.next) !== n) {
                    if (ce.SameValueZero(i.key, e)) {
                        i.value = t;
                        return this;
                    }
                } a = a || new r(e, t); if (ce.SameValue(-0, e)) {
                    a.key = +0;
                } a.next = this._head; a.prev = this._head.prev; a.prev.next = a; a.next.prev = a; this._size += 1; return this; }, "delete": function (t) { o(this, "delete"); var r = this._head; var n = r; var i = Yr(t, true); if (i !== null) {
                    if (typeof this._storage[i] === "undefined") {
                        return false;
                    }
                    n = this._storage[i].prev;
                    delete this._storage[i];
                }
                else if (this._map) {
                    if (!B.call(this._map, t)) {
                        return false;
                    }
                    n = V.call(this._map, t).prev;
                    H.call(this._map, t);
                } while ((n = n.next) !== r) {
                    if (ce.SameValueZero(n.key, t)) {
                        n.key = e;
                        n.value = e;
                        n.prev.next = n.next;
                        n.next.prev = n.prev;
                        this._size -= 1;
                        return true;
                    }
                } return false; }, clear: function clear() { o(this, "clear"); this._map = G ? new G : null; this._size = 0; this._storage = Qr(); var t = this._head; var r = t; var n = r.next; while ((r = n) !== t) {
                    r.key = e;
                    r.value = e;
                    n = r.next;
                    r.next = r.prev = t;
                } t.next = t.prev = t; }, keys: function keys() { o(this, "keys"); return new i(this, "key"); }, values: function values() { o(this, "values"); return new i(this, "value"); }, entries: function entries() { o(this, "entries"); return new i(this, "key+value"); }, forEach: function forEach(e) { o(this, "forEach"); var r = arguments.length > 1 ? arguments[1] : null; var n = this.entries(); for (var i = n.next(); !i.done; i = n.next()) {
                    if (r) {
                        t(e, r, i.value[1], i.value[0], this);
                    }
                    else {
                        e(i.value[1], i.value[0], this);
                    }
                } } }); Me(a, a.entries); return u; }(), Set: function () { var e = function isSet(e) { return e._es6set && typeof e._storage !== "undefined"; }; var r = function requireSetSlot(t, r) { if (!ce.TypeIsObject(t) || !e(t)) {
                throw new TypeError("Set.prototype." + r + " called on incompatible receiver " + ce.ToString(t));
            } }; var o; var i = function Set() { if (!(this instanceof Set)) {
                throw new TypeError('Constructor Set requires "new"');
            } if (this && this._es6set) {
                throw new TypeError("Bad construction");
            } var e = Ae(this, Set, o, { _es6set: true, "[[SetData]]": null, _storage: Qr() }); if (!e._es6set) {
                throw new TypeError("bad set");
            } if (arguments.length > 0) {
                tn(Set, e, arguments[0]);
            } return e; }; o = i.prototype; var a = function (e) { var t = e; if (t === "^null") {
                return null;
            }
            else if (t === "^undefined") {
                return void 0;
            }
            else {
                var r = t.charAt(0);
                if (r === "$") {
                    return C(t, 1);
                }
                else if (r === "n") {
                    return +C(t, 1);
                }
                else if (r === "b") {
                    return t === "btrue";
                }
            } return +t; }; var u = function ensureMap(e) { if (!e["[[SetData]]"]) {
                var t = new rn.Map;
                e["[[SetData]]"] = t;
                l(n(e._storage), function (e) { var r = a(e); t.set(r, r); });
                e["[[SetData]]"] = t;
            } e._storage = null; }; m.getter(i.prototype, "size", function () { r(this, "size"); if (this._storage) {
                return n(this._storage).length;
            } u(this); return this["[[SetData]]"].size; }); b(i.prototype, { has: function has(e) { r(this, "has"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    return !!this._storage[t];
                } u(this); return this["[[SetData]]"].has(e); }, add: function add(e) { r(this, "add"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    this._storage[t] = true;
                    return this;
                } u(this); this["[[SetData]]"].set(e, e); return this; }, "delete": function (e) { r(this, "delete"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    var n = z(this._storage, t);
                    return delete this._storage[t] && n;
                } u(this); return this["[[SetData]]"]["delete"](e); }, clear: function clear() { r(this, "clear"); if (this._storage) {
                    this._storage = Qr();
                } if (this["[[SetData]]"]) {
                    this["[[SetData]]"].clear();
                } }, values: function values() { r(this, "values"); u(this); return new f(this["[[SetData]]"].values()); }, entries: function entries() { r(this, "entries"); u(this); return new f(this["[[SetData]]"].entries()); }, forEach: function forEach(e) { r(this, "forEach"); var n = arguments.length > 1 ? arguments[1] : null; var o = this; u(o); this["[[SetData]]"].forEach(function (r, i) { if (n) {
                    t(e, n, i, i, o);
                }
                else {
                    e(i, i, o);
                } }); } }); h(i.prototype, "keys", i.prototype.values, true); Me(i.prototype, i.prototype.values); var f = function SetIterator(e) { this.it = e; }; f.prototype = { isSetIterator: true, next: function next() { if (!this.isSetIterator) {
                    throw new TypeError("Not a SetIterator");
                } return this.it.next(); } }; Me(f.prototype); return i; }() };
        var nn = S.Set && !Set.prototype["delete"] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray((new Set).keys);
        if (nn) {
            S.Set = rn.Set;
        }
        if (S.Map || S.Set) {
            var on = a(function () { return new Map([[1, 2]]).get(1) === 2; });
            if (!on) {
                S.Map = function Map() { if (!(this instanceof Map)) {
                    throw new TypeError('Constructor Map requires "new"');
                } var e = new G; if (arguments.length > 0) {
                    en(Map, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, S.Map.prototype); return e; };
                S.Map.prototype = O(G.prototype);
                h(S.Map.prototype, "constructor", S.Map, true);
                m.preserveToString(S.Map, G);
            }
            var an = new Map;
            var un = function () { var e = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]); e.set(-0, e); return e.get(0) === e && e.get(-0) === e && e.has(0) && e.has(-0); }();
            var fn = an.set(1, 2) === an;
            if (!un || !fn) {
                ne(Map.prototype, "set", function set(e, r) { t(U, this, e === 0 ? 0 : e, r); return this; });
            }
            if (!un) {
                b(Map.prototype, { get: function get(e) { return t(V, this, e === 0 ? 0 : e); }, has: function has(e) { return t(B, this, e === 0 ? 0 : e); } }, true);
                m.preserveToString(Map.prototype.get, V);
                m.preserveToString(Map.prototype.has, B);
            }
            var sn = new Set;
            var cn = Set.prototype["delete"] && Set.prototype.add && Set.prototype.has && function (e) { e["delete"](0); e.add(-0); return !e.has(0); }(sn);
            var ln = sn.add(1) === sn;
            if (!cn || !ln) {
                var pn = Set.prototype.add;
                Set.prototype.add = function add(e) { t(pn, this, e === 0 ? 0 : e); return this; };
                m.preserveToString(Set.prototype.add, pn);
            }
            if (!cn) {
                var vn = Set.prototype.has;
                Set.prototype.has = function has(e) { return t(vn, this, e === 0 ? 0 : e); };
                m.preserveToString(Set.prototype.has, vn);
                var yn = Set.prototype["delete"];
                Set.prototype["delete"] = function SetDelete(e) { return t(yn, this, e === 0 ? 0 : e); };
                m.preserveToString(Set.prototype["delete"], yn);
            }
            var hn = w(S.Map, function (e) { var t = new e([]); t.set(42, 42); return t instanceof e; });
            var bn = Object.setPrototypeOf && !hn;
            var gn = function () { try {
                return !(S.Map() instanceof S.Map);
            }
            catch (e) {
                return e instanceof TypeError;
            } }();
            if (S.Map.length !== 0 || bn || !gn) {
                S.Map = function Map() { if (!(this instanceof Map)) {
                    throw new TypeError('Constructor Map requires "new"');
                } var e = new G; if (arguments.length > 0) {
                    en(Map, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, Map.prototype); return e; };
                S.Map.prototype = G.prototype;
                h(S.Map.prototype, "constructor", S.Map, true);
                m.preserveToString(S.Map, G);
            }
            var dn = w(S.Set, function (e) { var t = new e([]); t.add(42, 42); return t instanceof e; });
            var mn = Object.setPrototypeOf && !dn;
            var On = function () { try {
                return !(S.Set() instanceof S.Set);
            }
            catch (e) {
                return e instanceof TypeError;
            } }();
            if (S.Set.length !== 0 || mn || !On) {
                var wn = S.Set;
                S.Set = function Set() { if (!(this instanceof Set)) {
                    throw new TypeError('Constructor Set requires "new"');
                } var e = new wn; if (arguments.length > 0) {
                    tn(Set, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, Set.prototype); return e; };
                S.Set.prototype = wn.prototype;
                h(S.Set.prototype, "constructor", S.Set, true);
                m.preserveToString(S.Set, wn);
            }
            var jn = new S.Map;
            var Sn = !a(function () { return jn.keys().next().done; });
            if (typeof S.Map.prototype.clear !== "function" || (new S.Set).size !== 0 || jn.size !== 0 || typeof S.Map.prototype.keys !== "function" || typeof S.Set.prototype.keys !== "function" || typeof S.Map.prototype.forEach !== "function" || typeof S.Set.prototype.forEach !== "function" || u(S.Map) || u(S.Set) || typeof jn.keys().next !== "function" || Sn || !hn) {
                b(S, { Map: rn.Map, Set: rn.Set }, true);
            }
            if (S.Set.prototype.keys !== S.Set.prototype.values) {
                h(S.Set.prototype, "keys", S.Set.prototype.values, true);
            }
            Me(Object.getPrototypeOf((new S.Map).keys()));
            Me(Object.getPrototypeOf((new S.Set).keys()));
            if (c && S.Set.prototype.has.name !== "has") {
                var Tn = S.Set.prototype.has;
                ne(S.Set.prototype, "has", function has(e) { return t(Tn, this, e); });
            }
        }
        b(S, rn);
        Ce(S.Map);
        Ce(S.Set);
    }
    var In = function throwUnlessTargetIsObject(e) { if (!ce.TypeIsObject(e)) {
        throw new TypeError("target must be an object");
    } };
    var En = { apply: function apply() { return ce.Call(ce.Call, null, arguments); }, construct: function construct(e, t) { if (!ce.IsConstructor(e)) {
            throw new TypeError("First argument must be a constructor.");
        } var r = arguments.length > 2 ? arguments[2] : e; if (!ce.IsConstructor(r)) {
            throw new TypeError("new.target must be a constructor.");
        } return ce.Construct(e, t, r, "internal"); }, deleteProperty: function deleteProperty(e, t) { In(e); if (s) {
            var r = Object.getOwnPropertyDescriptor(e, t);
            if (r && !r.configurable) {
                return false;
            }
        } return delete e[t]; }, has: function has(e, t) { In(e); return t in e; } };
    if (Object.getOwnPropertyNames) {
        Object.assign(En, { ownKeys: function ownKeys(e) { In(e); var t = Object.getOwnPropertyNames(e); if (ce.IsCallable(Object.getOwnPropertySymbols)) {
                x(t, Object.getOwnPropertySymbols(e));
            } return t; } });
    }
    var Pn = function ConvertExceptionToBoolean(e) { return !i(e); };
    if (Object.preventExtensions) {
        Object.assign(En, { isExtensible: function isExtensible(e) { In(e); return Object.isExtensible(e); }, preventExtensions: function preventExtensions(e) { In(e); return Pn(function () { return Object.preventExtensions(e); }); } });
    }
    if (s) {
        var Cn = function get(e, t, r) { var n = Object.getOwnPropertyDescriptor(e, t); if (!n) {
            var o = Object.getPrototypeOf(e);
            if (o === null) {
                return void 0;
            }
            return Cn(o, t, r);
        } if ("value" in n) {
            return n.value;
        } if (n.get) {
            return ce.Call(n.get, r);
        } return void 0; };
        var Mn = function set(e, r, n, o) { var i = Object.getOwnPropertyDescriptor(e, r); if (!i) {
            var a = Object.getPrototypeOf(e);
            if (a !== null) {
                return Mn(a, r, n, o);
            }
            i = { value: void 0, writable: true, enumerable: true, configurable: true };
        } if ("value" in i) {
            if (!i.writable) {
                return false;
            }
            if (!ce.TypeIsObject(o)) {
                return false;
            }
            var u = Object.getOwnPropertyDescriptor(o, r);
            if (u) {
                return ae.defineProperty(o, r, { value: n });
            }
            else {
                return ae.defineProperty(o, r, { value: n, writable: true, enumerable: true, configurable: true });
            }
        } if (i.set) {
            t(i.set, o, n);
            return true;
        } return false; };
        Object.assign(En, { defineProperty: function defineProperty(e, t, r) { In(e); return Pn(function () { return Object.defineProperty(e, t, r); }); }, getOwnPropertyDescriptor: function getOwnPropertyDescriptor(e, t) { In(e); return Object.getOwnPropertyDescriptor(e, t); }, get: function get(e, t) { In(e); var r = arguments.length > 2 ? arguments[2] : e; return Cn(e, t, r); }, set: function set(e, t, r) { In(e); var n = arguments.length > 3 ? arguments[3] : e; return Mn(e, t, r, n); } });
    }
    if (Object.getPrototypeOf) {
        var xn = Object.getPrototypeOf;
        En.getPrototypeOf = function getPrototypeOf(e) { In(e); return xn(e); };
    }
    if (Object.setPrototypeOf && En.getPrototypeOf) {
        var Nn = function (e, t) { var r = t; while (r) {
            if (e === r) {
                return true;
            }
            r = En.getPrototypeOf(r);
        } return false; };
        Object.assign(En, { setPrototypeOf: function setPrototypeOf(e, t) { In(e); if (t !== null && !ce.TypeIsObject(t)) {
                throw new TypeError("proto must be an object or null");
            } if (t === ae.getPrototypeOf(e)) {
                return true;
            } if (ae.isExtensible && !ae.isExtensible(e)) {
                return false;
            } if (Nn(e, t)) {
                return false;
            } Object.setPrototypeOf(e, t); return true; } });
    }
    var An = function (e, t) { if (!ce.IsCallable(S.Reflect[e])) {
        h(S.Reflect, e, t);
    }
    else {
        var r = a(function () { S.Reflect[e](1); S.Reflect[e](NaN); S.Reflect[e](true); return true; });
        if (r) {
            ne(S.Reflect, e, t);
        }
    } };
    Object.keys(En).forEach(function (e) { An(e, En[e]); });
    var Rn = S.Reflect.getPrototypeOf;
    if (c && Rn && Rn.name !== "getPrototypeOf") {
        ne(S.Reflect, "getPrototypeOf", function getPrototypeOf(e) { return t(Rn, S.Reflect, e); });
    }
    if (S.Reflect.setPrototypeOf) {
        if (a(function () { S.Reflect.setPrototypeOf(1, {}); return true; })) {
            ne(S.Reflect, "setPrototypeOf", En.setPrototypeOf);
        }
    }
    if (S.Reflect.defineProperty) {
        if (!a(function () { var e = !S.Reflect.defineProperty(1, "test", { value: 1 }); var t = typeof Object.preventExtensions !== "function" || !S.Reflect.defineProperty(Object.preventExtensions({}), "test", {}); return e && t; })) {
            ne(S.Reflect, "defineProperty", En.defineProperty);
        }
    }
    if (S.Reflect.construct) {
        if (!a(function () { var e = function F() { }; return S.Reflect.construct(function () { }, [], e) instanceof e; })) {
            ne(S.Reflect, "construct", En.construct);
        }
    }
    if (String(new Date(NaN)) !== "Invalid Date") {
        var _n = Date.prototype.toString;
        var kn = function toString() { var e = +this; if (e !== e) {
            return "Invalid Date";
        } return ce.Call(_n, this); };
        ne(Date.prototype, "toString", kn);
    }
    var Ln = { anchor: function anchor(e) { return ce.CreateHTML(this, "a", "name", e); }, big: function big() { return ce.CreateHTML(this, "big", "", ""); }, blink: function blink() { return ce.CreateHTML(this, "blink", "", ""); }, bold: function bold() { return ce.CreateHTML(this, "b", "", ""); }, fixed: function fixed() { return ce.CreateHTML(this, "tt", "", ""); }, fontcolor: function fontcolor(e) { return ce.CreateHTML(this, "font", "color", e); }, fontsize: function fontsize(e) { return ce.CreateHTML(this, "font", "size", e); }, italics: function italics() { return ce.CreateHTML(this, "i", "", ""); }, link: function link(e) { return ce.CreateHTML(this, "a", "href", e); }, small: function small() { return ce.CreateHTML(this, "small", "", ""); }, strike: function strike() { return ce.CreateHTML(this, "strike", "", ""); }, sub: function sub() { return ce.CreateHTML(this, "sub", "", ""); }, sup: function sub() { return ce.CreateHTML(this, "sup", "", ""); } };
    l(Object.keys(Ln), function (e) { var r = String.prototype[e]; var n = false; if (ce.IsCallable(r)) {
        var o = t(r, "", ' " ');
        var i = P([], o.match(/"/g)).length;
        n = o !== o.toLowerCase() || i > 2;
    }
    else {
        n = true;
    } if (n) {
        ne(String.prototype, e, Ln[e]);
    } });
    var Fn = function () { if (!oe) {
        return false;
    } var e = typeof JSON === "object" && typeof JSON.stringify === "function" ? JSON.stringify : null; if (!e) {
        return false;
    } if (typeof e($()) !== "undefined") {
        return true;
    } if (e([$()]) !== "[null]") {
        return true;
    } var t = { a: $() }; t[$()] = true; if (e(t) !== "{}") {
        return true;
    } return false; }();
    var Dn = a(function () { if (!oe) {
        return true;
    } return JSON.stringify(Object($())) === "{}" && JSON.stringify([Object($())]) === "[{}]"; });
    if (Fn || !Dn) {
        var zn = JSON.stringify;
        ne(JSON, "stringify", function stringify(e) { if (typeof e === "symbol") {
            return;
        } var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o = [e]; if (!r(n)) {
            var i = ce.IsCallable(n) ? n : null;
            var a = function (e, r) { var n = i ? t(i, this, e, r) : r; if (typeof n !== "symbol") {
                if (re.symbol(n)) {
                    return Nt({})(n);
                }
                else {
                    return n;
                }
            } };
            o.push(a);
        }
        else {
            o.push(n);
        } if (arguments.length > 2) {
            o.push(arguments[2]);
        } return zn.apply(this, o); });
    }
    return S;
});
//# sourceMappingURL=es6-shim.map
/// <reference path="node_modules/es6-shim/es6-shim.min.js" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                /**
                 * Associate tokens with promises.
                 *
                 * First, .make() a promise -- associate a token with resolve/reject callbacks.
                 *
                 * You can either .keep() a promise -- resolve() and forget it;
                 * Or you may also .break() a promise -- reject() and forget it.
                 *
                 * <T> is the type of resolved value (value yielded successfully by promise).
                 */
                var PromiseStore = /** @class */ (function () {
                    function PromiseStore() {
                        this._promises = new Map();
                    }
                    Object.defineProperty(PromiseStore.prototype, "length", {
                        /**
                         * How many promises are currently being tracked?
                         */
                        get: function () {
                            return this._promises.size;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Associate a token with its respective resolve and reject callbacks.
                     */
                    PromiseStore.prototype.make = function (token, resolve, reject) {
                        if (this._promises.has(token)) {
                            return reject("Existing request with token " + token);
                        }
                        this._promises.set(token, { reject: reject, resolve: resolve });
                    };
                    /**
                     * Resolve the promise associated with a token (with a value!).
                     * Once the promise is resolved, the token is removed..
                     */
                    PromiseStore.prototype.keep = function (token, value) {
                        var callbacks = this._promises.get(token);
                        if (!callbacks) {
                            throw new Error("No promise associated with token: " + token);
                        }
                        var accept = callbacks.resolve;
                        this._promises.delete(token);
                        return accept(value);
                    };
                    /**
                     * Instantly reject and forget a promise associated with the token.
                     */
                    PromiseStore.prototype.break = function (token, reason) {
                        var callbacks = this._promises.get(token);
                        if (!callbacks) {
                            throw new Error("No promise associated with token: " + token);
                        }
                        this._promises.delete(token);
                        callbacks.reject(reason);
                    };
                    return PromiseStore;
                }());
                prediction.PromiseStore = PromiseStore;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/*
 * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
 * Copyright (c) 2018 SIL International
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/// <reference path="node_modules/es6-shim/es6-shim.min.js" />
/// <reference path="promise-store.ts" />
/**
 * Top-level interface to the Language Modelling layer, or "LMLayer" for short.
 *
 * The Language Modelling layer provides a way for keyboards to offer prediction and
 * correction functionalities. The LMLayer proper runs within a Web Worker, however,
 * this class is intended to run in the main thread, and automatically spawn a Web
 * Worker, capable of offering predictions.
 *
 * Since the Worker runs in a different thread, the public methods of this class are
 * asynchronous. Methods of note include:
 *
 *  - #loadModel() -- loads a specified model file
 *  - #predict() -- ask the LMLayer to offer suggestions (predictions or corrections) for
 *                  the input event
 *  - #unloadModel() -- unloads the LMLayer's currently loaded model, preparing it to
 *                          receive (load) a new model
 *
 * The top-level LMLayer will automatically starts up its own Web Worker.
 */
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                var LMLayer = /** @class */ (function () {
                    /**
                     * Construct the top-level LMLayer interface. This also starts the underlying Worker.
                     *
                     * @param uri URI of the underlying LMLayer worker code. This will usually be a blob:
                     *            or file: URI. If uri is not provided, this will start the default Worker.
                     */
                    function LMLayer(capabilities, worker) {
                        // Either use the given worker, or instantiate the default worker.
                        this._worker = worker || new Worker(LMLayer.asBlobURI(LMLayerWorkerCode));
                        this._worker.onmessage = this.onMessage.bind(this);
                        this._declareLMLayerReady = null;
                        this._predictPromises = new prediction.PromiseStore;
                        this._wordbreakPromises = new prediction.PromiseStore();
                        this._nextToken = Number.MIN_SAFE_INTEGER;
                        this.sendConfig(capabilities);
                    }
                    /**
                     * Initializes the LMLayer worker with the host platform's capability set.
                     *
                     * @param capabilities The host platform's capability spec - a model cannot assume access to more context
                     *                     than specified by this parameter.
                     */
                    LMLayer.prototype.sendConfig = function (capabilities) {
                        this._worker.postMessage({
                            message: 'config',
                            capabilities: capabilities
                        });
                    };
                    /**
                     * Initializes the LMLayer worker with a path to the desired model file.
                     */
                    LMLayer.prototype.loadModel = function (modelFilePath) {
                        var _this = this;
                        return new Promise(function (resolve, _reject) {
                            // Sets up so the promise is resolved in the onMessage() callback, when it receives
                            // the 'ready' message.
                            _this._declareLMLayerReady = resolve;
                            _this._worker.postMessage({
                                message: 'load',
                                model: modelFilePath
                            });
                        });
                    };
                    /**
                     * Unloads the previously-active model from memory, resetting the LMLayer to prep
                     * for transition to use of a new model.
                     */
                    LMLayer.prototype.unloadModel = function () {
                        this._worker.postMessage({
                            message: 'unload'
                        });
                    };
                    LMLayer.prototype.predict = function (transform, context) {
                        var _this = this;
                        var token = this._nextToken++;
                        return new Promise(function (resolve, reject) {
                            _this._predictPromises.make(token, resolve, reject);
                            _this._worker.postMessage({
                                message: 'predict',
                                token: token,
                                transform: transform,
                                context: context,
                            });
                        });
                    };
                    LMLayer.prototype.wordbreak = function (context) {
                        var _this = this;
                        var token = this._nextToken++;
                        return new Promise(function (resolve, reject) {
                            _this._wordbreakPromises.make(token, resolve, reject);
                            _this._worker.postMessage({
                                message: 'wordbreak',
                                token: token,
                                context: context
                            });
                        });
                    };
                    // TODO: asynchronous close() method.
                    //       Worker code must recognize message and call self.close().
                    LMLayer.prototype.onMessage = function (event) {
                        var payload = event.data;
                        if (payload.message === 'error') {
                            console.error(payload.log);
                            if (payload.error) {
                                console.error(payload.error);
                            }
                        }
                        else if (payload.message === 'ready') {
                            this._declareLMLayerReady(event.data.configuration);
                        }
                        else if (payload.message === 'suggestions') {
                            this._predictPromises.keep(payload.token, payload.suggestions);
                        }
                        else if (payload.message === 'currentword') {
                            this._wordbreakPromises.keep(payload.token, payload.word);
                        }
                        else {
                            // This branch should never execute, but just in case...
                            //@ts-ignore
                            throw new Error("Message not implemented: " + payload.message);
                        }
                    };
                    /**
                     * Clears out any computational resources in use by the LMLayer, including shutting
                     * down any internal WebWorkers.
                     */
                    LMLayer.prototype.shutdown = function () {
                        this._worker.terminate();
                    };
                    /**
                     * Given a function, this utility returns the source code within it, as a string.
                     * This is intended to unwrap the "wrapped" source code created in the LMLayerWorker
                     * build process.
                     *
                     * @param fn The function whose body will be returned.
                     */
                    LMLayer.unwrap = function (fn) {
                        var wrapper = fn.toString();
                        var match = wrapper.match(/function[^{]+{((?:.|\r|\n)+)}[^}]*$/);
                        return match[1];
                    };
                    /**
                     * Converts the INSIDE of a function into a blob URI that can
                     * be passed as a valid URI for a Worker.
                     * @param fn Function whose body will be referenced by a URI.
                     *
                     * This function makes the following possible:
                     *
                     *    let worker = new Worker(LMLayer.asBlobURI(function myWorkerCode () {
                     *      postMessage('inside Web Worker')
                     *      function onmessage(event) {
                     *        // handle message inside Web Worker.
                     *      }
                     *    }));
                     */
                    LMLayer.asBlobURI = function (fn) {
                        var code = LMLayer.unwrap(fn);
                        var blob = new Blob([code], { type: 'text/javascript' });
                        return URL.createObjectURL(blob);
                    };
                    return LMLayer;
                }());
                prediction.LMLayer = LMLayer;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
(function () {
    var ns = com.keyman.text.prediction;
    // Let LMLayer be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = ns.LMLayer;
        //@ts-ignore
        ns.LMLayer.PromiseStore = ns.PromiseStore;
    }
    else {
        //@ts-ignore
        window.LMLayer = ns.LMLayer;
    }
}());
/**
 * Defines the reference-path tags necessary to link properly with common/predictive-text.
 */
// Defines the main interface of the Language Modeling Layer (LMLayer) and its original typing information.
///<reference path="../../../common/predictive-text/embedded_worker.d.ts" />
///<reference path="../../../common/predictive-text/index.ts" />
// We DO need the embedded_worker.d.ts file - since we're directly linking into the LMLayer's code,
// we need the typedef for the embedded worker to be linked.
// Defines the text processing KMW core.
///<reference path="../processor.ts" />
// Defines the LMLayer's outer shell
///<reference path="../../includes/lmlayer.ts" />
// Defines the ModelManager and its related types.
///<reference path="../../kmwkeyboards.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_16) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction_1) {
                var TranscriptionContext = /** @class */ (function () {
                    function TranscriptionContext(mock, config) {
                        this.left = mock.getTextBeforeCaret();
                        this.startOfBuffer = this.left._kmwLength() > config.leftContextCodePoints;
                        if (!this.startOfBuffer) {
                            // Our custom substring version will return the last n characters if param #1 is given -n.
                            this.left = this.left._kmwSubstr(-config.leftContextCodePoints);
                        }
                        this.right = mock.getTextAfterCaret();
                        this.endOfBuffer = this.right._kmwLength() > config.leftContextCodePoints;
                        if (!this.endOfBuffer) {
                            this.right = this.right._kmwSubstr(0, config.leftContextCodePoints);
                        }
                    }
                    return TranscriptionContext;
                }());
                var ReadySuggestions = /** @class */ (function () {
                    function ReadySuggestions(suggestions, id) {
                        this.suggestions = suggestions;
                        this.transcriptionID = id;
                    }
                    return ReadySuggestions;
                }());
                prediction_1.ReadySuggestions = ReadySuggestions;
                var ModelManager = /** @class */ (function () {
                    function ModelManager() {
                        this.recentTranscriptions = [];
                        this._mayPredict = true;
                        this._mayCorrect = true;
                        // Tracks registered models by ID.
                        this.registeredModels = {};
                        // Allows for easy model lookup by language code; useful when switching keyboards.
                        this.languageModelMap = {};
                    }
                    ModelManager.prototype.init = function () {
                        var keyman = com.keyman.singleton;
                        // Establishes KMW's platform 'capabilities', which limit the range of context a LMLayer
                        // model may expect.
                        var capabilities = {
                            maxLeftContextCodePoints: 64,
                            // Since the apps don't yet support right-deletions.
                            maxRightContextCodePoints: keyman.isEmbedded ? 0 : 64
                        };
                        if (!this.canEnable()) {
                            return;
                        }
                        this.lmEngine = new prediction_1.LMLayer(capabilities);
                        // Registers this module for keyboard (language) and model change events.
                        keyman['addEventListener']('keyboardchange', this.onKeyboardChange.bind(this));
                    };
                    Object.defineProperty(ModelManager.prototype, "activeModel", {
                        get: function () {
                            return this.currentModel;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ModelManager.prototype.unloadModel = function () {
                        this.lmEngine.unloadModel();
                        delete this.currentModel;
                        delete this.configuration;
                    };
                    ModelManager.prototype.loadModel = function (model) {
                        if (!model) {
                            throw new Error("Null reference not allowed.");
                        }
                        var file = model.path;
                        var mm = this;
                        // We should wait until the model is successfully loaded before setting our state values.
                        return this.lmEngine.loadModel(file).then(function (config) {
                            mm.currentModel = model;
                            mm.configuration = config;
                        });
                    };
                    ModelManager.prototype.onKeyboardChange = function (kbdInfo) {
                        var _a;
                        var keyman = com.keyman.singleton;
                        var mm = this;
                        if (!this.mayPredict) {
                            return Promise.resolve();
                        }
                        if (typeof kbdInfo == 'string') { // This case refers to the active language code.
                            kbdInfo = (_a = {},
                                _a['internalName'] = keyman.keyboardManager.getActiveKeyboardName(),
                                _a['languageCode'] = kbdInfo,
                                _a['indirect'] = true,
                                _a);
                        }
                        var lgCode = kbdInfo['languageCode'];
                        var model = this.languageModelMap[lgCode];
                        var loadPromise;
                        if (this.currentModel !== model) {
                            if (this.currentModel) {
                                this.unloadModel();
                                keyman.util.callEvent(ModelManager.EVENT_PREFIX + 'modelchange', 'unloaded');
                            }
                            if (model) {
                                loadPromise = this.loadModel(model);
                            }
                            // If we're loading a model, we need to defer until its completion before we report a change of state.
                            if (loadPromise) {
                                var mm_1 = this;
                                loadPromise.then(function () {
                                    // Because this is executed from a Promise, it's possible to have a race condition
                                    // where the 'loaded' event triggers after an 'unloaded' event meant to disable the model.
                                    // (Especially in the embedded apps.)  This will catch these cases.
                                    if (mm_1.mayPredict) {
                                        keyman.util.callEvent(ModelManager.EVENT_PREFIX + 'modelchange', 'loaded');
                                    }
                                    else {
                                        mm_1.unloadModel();
                                    }
                                }).catch(function (failReason) {
                                    // Does this provide enough logging information?
                                    console.error("Could not load model '" + model.id + "': " + failReason);
                                });
                            }
                        }
                    };
                    // Accessible publicly as keyman.modelManager.register(model: ModelSpec)
                    ModelManager.prototype.register = function (model) {
                        var keyman = com.keyman.singleton;
                        var activeLanguage = keyman.keyboardManager.getActiveLanguage();
                        this.registeredModels[model.id] = model;
                        // Register the model for each targeted language code variant.
                        var mm = this;
                        model.languages.forEach(function (code) {
                            mm.languageModelMap[code] = model;
                            // The model's for our active language!  Activate it!
                            if (code == activeLanguage) {
                                // Manually trigger our model-update event function.
                                mm.onKeyboardChange(code);
                            }
                        });
                    };
                    ModelManager.prototype.deregister = function (modelId) {
                        var keyman = com.keyman.singleton;
                        var model;
                        // Remove the model from the id-lookup associative array.
                        if (this.registeredModels[modelId]) {
                            model = this.registeredModels[modelId];
                            delete this.registeredModels[modelId];
                        }
                        else {
                            return;
                        }
                        // Is it the active model?
                        if (this.currentModel && this.currentModel.id == modelId) {
                            this.unloadModel();
                            keyman.util.callEvent(ModelManager.EVENT_PREFIX + 'modelchange', 'unloaded');
                        }
                        // Ensure the model is deregistered for each targeted language code variant.
                        var mm = this;
                        model.languages.forEach(function (code) {
                            if (mm.languageModelMap[code].id == modelId) {
                                delete mm.languageModelMap[code];
                            }
                        });
                    };
                    ModelManager.prototype.isRegistered = function (model) {
                        return !!this.registeredModels[model.id];
                    };
                    /**
                     * Function     addEventListener
                     * Scope        Public
                     * @param       {string}            event     event to handle
                     * @param       {function(Event)}   func      event handler function
                     * @return      {boolean}                     value returned by util.addEventListener
                     * Description  Wrapper function to add and identify handlers for ModelManager events
                     */
                    ModelManager.prototype['addEventListener'] = function (event, func) {
                        var keyman = com.keyman.singleton;
                        return keyman.util.addEventListener(ModelManager.EVENT_PREFIX + event, func);
                    };
                    /**
                     * Function     removeEventListener
                     * Scope        Public
                     * @param       {string}            event     event to handle
                     * @param       {function(Event)}   func      event handler function
                     * @return      {boolean}                     value returned by util.addEventListener
                     * Description  Wrapper function to remove previously-added handlers for ModelManager events
                     */
                    ModelManager.prototype['removeEventListener'] = function (event, func) {
                        var keyman = com.keyman.singleton;
                        return keyman.util.removeEventListener(ModelManager.EVENT_PREFIX + event, func);
                    };
                    ModelManager.prototype.invalidateContext = function () {
                        var keyman = com.keyman.singleton;
                        // Signal to any predictive text UI that the context has changed, invalidating recent predictions.
                        keyman.util.callEvent(ModelManager.EVENT_PREFIX + "invalidatesuggestions", 'context');
                        // If there's no active model, there can be no predictions.
                        // We'll also be missing important data needed to even properly REQUEST the predictions.
                        if (!this.currentModel || !this.configuration) {
                            return;
                        }
                        this.predict_internal();
                    };
                    ModelManager.prototype.wordbreak = function (target) {
                        var keyman = com.keyman.singleton;
                        var context = new TranscriptionContext(text.Mock.from(target), this.configuration);
                        return this.lmEngine.wordbreak(context);
                    };
                    ModelManager.prototype.predict = function (transcription) {
                        var keyman = com.keyman.singleton;
                        // If there's no active model, there can be no predictions.
                        // We'll also be missing important data needed to even properly REQUEST the predictions.
                        if (!this.currentModel || !this.configuration) {
                            return;
                        }
                        // We've already invalidated any suggestions resulting from any previously-existing Promise -
                        // may as well officially invalidate them via event.
                        keyman.util.callEvent(ModelManager.EVENT_PREFIX + "invalidatesuggestions", 'new');
                        this.predict_internal(transcription);
                    };
                    /**
                     * Called internally to do actual predictions after any relevant "invalidatesuggestions" events
                     * have been raised.
                     * @param transcription The triggering transcription (if it exists)
                     */
                    ModelManager.prototype.predict_internal = function (transcription) {
                        var keyman = com.keyman.singleton;
                        if (!transcription) {
                            var t = text.Processor.getOutputTarget();
                            if (t) {
                                transcription = t.buildTranscriptionFrom(t, null);
                            }
                            else {
                                return;
                            }
                        }
                        var context = new TranscriptionContext(transcription.preInput, this.configuration);
                        this.recordTranscription(transcription);
                        var transform = transcription.transform;
                        var promise = this.currentPromise = this.lmEngine.predict(transcription.alternates || transcription.transform, context);
                        var mm = this;
                        promise.then(function (suggestions) {
                            if (promise == mm.currentPromise) {
                                var result = new ReadySuggestions(suggestions, transform.id);
                                keyman.util.callEvent(ModelManager.EVENT_PREFIX + "suggestionsready", result);
                                mm.currentPromise = null;
                            }
                        });
                    };
                    ModelManager.prototype.recordTranscription = function (transcription) {
                        this.recentTranscriptions.push(transcription);
                        if (this.recentTranscriptions.length > ModelManager.TRANSCRIPTION_BUFFER) {
                            this.recentTranscriptions.splice(0, 1);
                        }
                    };
                    /**
                     * Retrieves the context and output state of KMW immediately before the prediction with
                     * token `id` was generated.  Must correspond to a 'recent' one, as only so many are stored
                     * in `ModelManager`'s history buffer.
                     * @param id A unique identifier corresponding to a recent `Transcription`.
                     * @returns The matching `Transcription`, or `null` none is found.
                     */
                    ModelManager.prototype.getPredictionState = function (id) {
                        var match = this.recentTranscriptions.filter(function (t) {
                            return t.token == id;
                        });
                        return match.length == 0 ? null : match[0];
                    };
                    ModelManager.prototype.shutdown = function () {
                        this.lmEngine.shutdown();
                    };
                    Object.defineProperty(ModelManager.prototype, "enabled", {
                        get: function () {
                            return this.activeModel && this._mayPredict;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ModelManager.prototype.canEnable = function () {
                        var keyman = com.keyman.singleton;
                        if (keyman.util.getIEVersion() == 10) {
                            console.warn("KeymanWeb cannot properly initialize its WebWorker in this version of IE.");
                            return false;
                        }
                        else if (keyman.util.getIEVersion() < 10) {
                            console.warn("WebWorkers are not supported in this version of IE.");
                            return false;
                        }
                        return true;
                    };
                    ModelManager.prototype.doEnable = function (flag) {
                        var keyman = com.keyman.singleton;
                        if (flag) {
                            var lgCode = keyman.keyboardManager.getActiveLanguage();
                            if (this.languageModelMap[lgCode]) {
                                // Just reuse the existing model-change trigger code.
                                this.onKeyboardChange(lgCode);
                            }
                        }
                        else {
                            if (this.activeModel) { // We only need to unload a model when one is actually loaded.
                                this.unloadModel();
                            }
                            // Ensure that the banner is unloaded.
                            keyman.util.callEvent(ModelManager.EVENT_PREFIX + 'modelchange', 'unloaded');
                        }
                    };
                    Object.defineProperty(ModelManager.prototype, "mayPredict", {
                        get: function () {
                            return this._mayPredict;
                        },
                        set: function (flag) {
                            var enabled = this.enabled;
                            if (!this.canEnable()) {
                                return;
                            }
                            this._mayPredict = flag;
                            if (enabled != this.enabled || flag) {
                                this.doEnable(flag);
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(ModelManager.prototype, "mayCorrect", {
                        get: function () {
                            return this._mayCorrect;
                        },
                        set: function (flag) {
                            this._mayCorrect = flag;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ModelManager.prototype.tryAcceptSuggestion = function (source) {
                        var keyman = com.keyman.singleton;
                        // Handlers of this event should return 'false' when the 'try' is successful.
                        return !keyman.util.callEvent(ModelManager.EVENT_PREFIX + 'tryaccept', source);
                    };
                    ModelManager.prototype.tryRevertSuggestion = function () {
                        var keyman = com.keyman.singleton;
                        // Handlers of this event should return 'false' when the 'try' is successful.
                        return !keyman.util.callEvent(ModelManager.EVENT_PREFIX + 'tryrevert', null);
                    };
                    ModelManager.EVENT_PREFIX = "kmw.mm.";
                    ModelManager.TRANSCRIPTION_BUFFER = 10;
                    return ModelManager;
                }());
                prediction_1.ModelManager = ModelManager;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman_16.text || (keyman_16.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Includes KMW-added property declaration extensions for HTML elements.
/// <reference path="kmwexthtml.ts" />
// Includes a promise polyfill (needed for IE)
/// <reference path="../node_modules/es6-shim/es6-shim.min.js" />
// Defines build-environment includes, since `tsc` doesn't provide a compile-time define.
/// <reference path="environment.inc.ts" />
// Defines the web-page interface object.
/// <reference path="singleton.ts" />
// Defines the core text processor.
/// <reference path="text/processor.ts" />
// Defines the web-page interface object.
/// <reference path="kmwdom.ts" />
// Includes KMW-added property declaration extensions for HTML elements.
/// <reference path="kmwutils.ts" />
// Defines the keyboard callback object.
/// <reference path="text/kbdInterface.ts" />
// Defines keyboard data & management classes.
/// <reference path="kmwkeyboards.ts" />
// Defines built-in keymapping.
/// <reference path="kmwkeymaps.ts" />
// Defines KMW's hotkey management object.
/// <reference path="kmwhotkeys.ts" />
// Defines the ui management code that tracks UI activation and such.
/// <reference path="kmwuimanager.ts" />
// Defines OSK management code.
/// <reference path="osk/oskManager.ts" />
// Defines the language modeling layer (for use in autocorrect and text prediction)
/// <reference path="includes/lmlayer.ts" />
// Defines the model manager.
/// <reference path="text/prediction/modelManager.ts" />
/***
   KeymanWeb 11.0
   Copyright 2017-2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var KeymanBase = /** @class */ (function () {
            // -------------
            function KeymanBase() {
                this._TitleElement = null; // I1972 - KeymanWeb Titlebar should not be a link
                this._IE = 0; // browser version identification
                this._MasterDocument = null; // Document with controller (to allow iframes to distinguish local/master control)
                this._HotKeys = []; // Array of document-level hotkey objects
                this.warned = false; // Warning flag (to prevent multiple warnings)
                this.baseFont = 'sans-serif'; // Default font for mapped input elements
                this.appliedFont = ''; // Chain of fonts to be applied to mapped input elements
                this.fontCheckTimer = null; // Timer for testing loading of embedded fonts
                this.srcPath = ''; // Path to folder containing executing keymanweb script
                this.rootPath = ''; // Path to server root
                this.protocol = ''; // Protocol used for the KMW script.
                this.mustReloadKeyboard = false; // Force keyboard refreshing even if already loaded
                this.globalKeyboard = null; // Indicates the currently-active keyboard for controls without independent keyboard settings.
                this.globalLanguageCode = null; // Indicates the language code corresponding to `globalKeyboard`.
                this.isEmbedded = false; // Indicates if the KeymanWeb instance is embedded within a mobile app.
                // Blocks full page initialization when set to `true`.
                this.refocusTimer = 0; // Tracks a timeout event that aids of OSK modifier/state key tracking when the document loses focus.
                this.isHeadless = false; // Indicates that KMW lacks any access to the DOM.  Nothing yet implemented for '= true'.
                this['build'] = 300; // TS needs this to be defined within the class.
                // Defines option-tracking object as a string map.
                this.options = {
                    'root': '',
                    'resources': '',
                    'keyboards': '',
                    'fonts': '',
                    'attachType': '',
                    'ui': null
                };
                this.refreshElementContent = null;
                // Allow internal minification of the public modules.
                this.util = this['util'] = new keyman.Util(this);
                window['KeymanWeb'] = this.interface = this['interface'] = new keyman.text.KeyboardInterface();
                this.ui = this['ui'] = {};
                this.keyboardManager = new keyman.KeyboardManager(this);
                this.domManager = new keyman.DOMManager(this);
                this.hotkeyManager = new keyman.HotkeyManager(this);
                this.uiManager = new keyman.UIManager(this);
                this.keyMapManager = new keyman.KeyMapManager();
                this.textProcessor = new keyman.text.Processor();
                this.modelManager = new keyman.text.prediction.ModelManager();
                this.osk = this['osk'] = new com.keyman.osk.OSKManager();
                // Load properties from their static variants.
                this['build'] = KeymanBase.__BUILD__;
                this.srcPath = KeymanBase._srcPath;
                this.rootPath = KeymanBase._rootPath;
                this.protocol = KeymanBase._protocol;
                this['version'] = com.keyman.environment.VERSION;
                this['helpURL'] = 'http://help.keyman.com/go';
                this.setInitialized(0);
                // Signals that a KMW load has occurred in order to prevent double-loading.
                this['loaded'] = true;
            }
            // Stub functions (defined later in code only if required)
            KeymanBase.prototype.setDefaultDeviceOptions = function (opt) { };
            KeymanBase.prototype.getStyleSheetPath = function (s) { return s; };
            KeymanBase.prototype.getKeyboardPath = function (f, p) { return f; };
            KeymanBase.prototype.KC_ = function (n, ln, Pelem) { return ''; };
            KeymanBase.prototype.handleRotationEvents = function () { };
            // Will serve as an API function for a workaround, in case of future touch-alignment issues.
            KeymanBase.prototype['alignInputs'] = function (eleList) { };
            KeymanBase.prototype.hideInputs = function () { };
            ;
            KeymanBase.prototype.namespaceID = function (Pstub) { };
            ;
            KeymanBase.prototype.preserveID = function (Pk) { };
            ;
            KeymanBase.prototype.setInitialized = function (val) {
                this.initialized = this['initialized'] = val;
            };
            KeymanBase.prototype.delayedInit = function () {
                // Track the selected Event-handling object.
                this.touchAliasing = this.util.device.touchable ? this.domManager.touchHandlers : this.domManager.nonTouchHandlers;
            };
            /**
             * Triggers a KeymanWeb engine shutdown to facilitate a full system reset.
             * This function is designed for use with KMW unit-testing, which reloads KMW
             * multiple times to test the different initialization paths.
             */
            KeymanBase.prototype['shutdown'] = function () {
                // Disable page focus/blur events, which can sometimes trigger and cause parallel KMW instances in testing.
                this.util.detachDOMEvent(window, 'focus', this['pageFocusHandler'], false);
                this.util.detachDOMEvent(window, 'blur', this['pageFocusHandler'], false);
                this.domManager.shutdown();
                this.osk.shutdown();
                this.util.shutdown();
                this.keyboardManager.shutdown();
                this.modelManager.shutdown();
                if (this.ui && this.ui.shutdown) {
                    this.ui.shutdown();
                }
                keyman.DOMEventHandlers.states = new keyman.CommonDOMStates();
            };
            /**
             * Expose font testing to allow checking that SpecialOSK or custom font has
             * been correctly loaded by browser
             *
             *  @param  {string}  fName   font-family name
             *  @return {boolean}         true if available
             **/
            KeymanBase.prototype['isFontAvailable'] = function (fName) {
                return this.util.checkFont({ 'family': fName });
            };
            /**
             * Function     addEventListener
             * Scope        Public
             * @param       {string}            event     event to handle
             * @param       {function(Event)}   func      event handler function
             * @return      {boolean}                     value returned by util.addEventListener
             * Description  Wrapper function to add and identify KeymanWeb-specific event handlers
             */
            KeymanBase.prototype['addEventListener'] = function (event, func) {
                return this.util.addEventListener('kmw.' + event, func);
            };
            /**
           * Function     _GetEventObject
           * Scope        Private
           * @param       {Event=}     e     Event object if passed by browser
           * @return      {Event|null}       Event object
           * Description Gets the event object from the window when using Internet Explorer
           *             and handles getting the event correctly in frames
           */
            KeymanBase.prototype._GetEventObject = function (e) {
                if (!e) {
                    e = window.event;
                    if (!e) {
                        var elem = this.domManager.getLastActiveElement();
                        if (elem) {
                            elem = elem.ownerDocument;
                            var win;
                            if (elem) {
                                win = elem.defaultView;
                            }
                            if (!win) {
                                return null;
                            }
                            e = win.event;
                        }
                    }
                }
                return e;
            };
            /**
             * Function     _push
             * Scope        Private
             * @param       {Array}     Parray    Array
             * @param       {*}         Pval      Value to be pushed or appended to array
             * @return      {Array}               Returns extended array
             * Description  Push (if possible) or append a value to an array
             */
            KeymanBase.prototype._push = function (Parray, Pval) {
                if (Parray.push) {
                    Parray.push(Pval);
                }
                else {
                    Parray = Parray.concat(Pval);
                }
                return Parray;
            };
            // Base object API definitions
            /**
             * Function     attachToControl
             * Scope        Public
             * @param       {Element}    Pelem       Element to which KMW will be attached
             * Description  Attaches KMW to control (or IFrame)
             */
            KeymanBase.prototype['attachToControl'] = function (Pelem) {
                this.domManager.attachToControl(Pelem);
            };
            /**
             * Function     detachFromControl
             * Scope        Public
             * @param       {Element}    Pelem       Element from which KMW will detach
             * Description  Detaches KMW from a control (or IFrame)
             */
            KeymanBase.prototype['detachFromControl'] = function (Pelem) {
                this.domManager.detachFromControl(Pelem);
            };
            /**
             * Exposed function to load keyboards by name. One or more arguments may be used
             *
             * @param {string|Object} x keyboard name string or keyboard metadata JSON object
             *
             */
            KeymanBase.prototype['addKeyboards'] = function (x) {
                if (arguments.length == 0) {
                    this.keyboardManager.keymanCloudRequest('', false);
                }
                else {
                    this.keyboardManager.addKeyboardArray(arguments);
                }
            };
            /**
             *  Add default or all keyboards for a given language
             *
             *  @param  {string}   arg    Language name (multiple arguments allowed)
             **/
            KeymanBase.prototype['addKeyboardsForLanguage'] = function (arg) {
                this.keyboardManager.addLanguageKeyboards(arguments);
            };
            /**
             * Call back from cloud for adding keyboard metadata
             *
             * @param {Object}    x   metadata object
             **/
            KeymanBase.prototype['register'] = function (x) {
                this.keyboardManager.register(x);
            };
            /**
             * Build 362: removeKeyboards() remove keyboard from list of available keyboards
             *
             * @param {string} x keyboard name string
             *
             */
            KeymanBase.prototype['removeKeyboards'] = function (x) {
                return this.keyboardManager.removeKeyboards(x);
            };
            /**
             * Allow to change active keyboard by (internal) keyboard name
             *
             * @param       {string}    PInternalName   Internal name
             * @param       {string}    PLgCode         Language code
             */
            KeymanBase.prototype['setActiveKeyboard'] = function (PInternalName, PLgCode) {
                return this.keyboardManager.setActiveKeyboard(PInternalName, PLgCode);
            };
            /**
             * Function     getActiveKeyboard
             * Scope        Public
             * @return      {string}      Name of active keyboard
             * Description  Return internal name of currently active keyboard
             */
            KeymanBase.prototype['getActiveKeyboard'] = function () {
                return this.keyboardManager.getActiveKeyboardName();
            };
            /**
             * Function    getActiveLanguage
             * Scope       Public
             * @param      {boolean=}        true to retrieve full language name, false/undefined to retrieve code.
             * @return     {string}         language code
             * Description Return language code for currently selected language
             */
            KeymanBase.prototype['getActiveLanguage'] = function (fullName) {
                return this.keyboardManager.getActiveLanguage(fullName);
            };
            KeymanBase.prototype['isAttached'] = function (x) {
                return this.domManager.isAttached(x);
            };
            /**
             * Function    isCJK
             * Scope       Public
             * @param      {Object=}  k0
             * @return     {boolean}
             * Description Tests if active keyboard (or optional argument) uses a pick list (Chinese, Japanese, Korean, etc.)
             *             (This function accepts either keyboard structure.)
             */
            KeymanBase.prototype['isCJK'] = function (k0) {
                return this.keyboardManager.isCJK(k0);
            };
            /**
             * Function     isChiral
             * Scope        Public
             * @param       {string|Object=}   k0
             * @return      {boolean}
             * Description  Tests if the active keyboard (or optional argument) uses chiral modifiers.
             */
            KeymanBase.prototype['isChiral'] = function (k0) {
                return this.keyboardManager.isChiral(k0);
            };
            /**
             * Get keyboard meta data for the selected keyboard and language
             *
             * @param       {string}    PInternalName     Internal name of keyboard
             * @param       {string=}   PlgCode           language code
             * @return      {Object}                      Details of named keyboard
             *
             **/
            KeymanBase.prototype['getKeyboard'] = function (PInternalName, PlgCode) {
                var Ln, Lrn;
                var kbdList = this.keyboardManager.getDetailedKeyboards();
                for (Ln = 0; Ln < kbdList.length; Ln++) {
                    Lrn = kbdList[Ln];
                    if (Lrn['InternalName'] == PInternalName || Lrn['InternalName'] == "Keyboard_" + PInternalName) {
                        if (arguments.length < 2) {
                            return Lrn;
                        }
                        if (Lrn['LanguageCode'] == PlgCode) {
                            return Lrn;
                        }
                    }
                }
                return null;
            };
            /**
             * Get array of available keyboard stubs
             *
             * @return   {Array}     Array of available keyboards
             *
             */
            KeymanBase.prototype['getKeyboards'] = function () {
                return this.keyboardManager.getDetailedKeyboards();
            };
            /**
             * Gets the cookie for the name and language code of the most recently active keyboard
             *
             *  Defaults to US English, but this needs to be user-set in later revision (TODO)
             *
             * @return      {string}          InternalName:LanguageCode
             */
            KeymanBase.prototype['getSavedKeyboard'] = function () {
                return this.keyboardManager.getSavedKeyboard();
            };
            /**
             * Function     Initialization
             * Scope        Public
             * @param       {Object}  arg     object array of user-defined properties
             * Description  KMW window initialization
             */
            KeymanBase.prototype['init'] = function (arg) {
                return this.domManager.init(arg);
            };
            /**
             * Function     resetContext
             * Scope        Public
             * Description  Revert OSK to default layer and clear any deadkeys and modifiers
             */
            KeymanBase.prototype['resetContext'] = function () {
                this.interface.resetContext();
            };
            ;
            /**
             * Function     setNumericLayer
             * Scope        Public
             * Description  Set OSK to numeric layer if it exists
             */
            KeymanBase.prototype['setNumericLayer'] = function () {
                this.interface.setNumericLayer();
            };
            ;
            /**
             * Function     disableControl
             * Scope        Public
             * @param       {Element}      Pelem       Element to be disabled
             * Description  Disables a KMW control element
             */
            KeymanBase.prototype['disableControl'] = function (Pelem) {
                this.domManager.disableControl(Pelem);
            };
            /**
             * Function     enableControl
             * Scope        Public
             * @param       {Element}      Pelem       Element to be disabled
             * Description  Disables a KMW control element
             */
            KeymanBase.prototype['enableControl'] = function (Pelem) {
                this.domManager.enableControl(Pelem);
            };
            /**
             * Function     setKeyboardForControl
             * Scope        Public
             * @param       {Element}    Pelem    Control element
             * @param       {string|null=}    Pkbd     Keyboard (Clears the set keyboard if set to null.)
             * @param       {string|null=}     Plc      Language Code
             * Description  Set default keyboard for the control
             */
            KeymanBase.prototype['setKeyboardForControl'] = function (Pelem, Pkbd, Plc) {
                this.domManager.setKeyboardForControl(Pelem, Pkbd, Plc);
            };
            /**
             * Function     getKeyboardForControl
             * Scope        Public
             * @param       {Element}    Pelem    Control element
             * @return      {string|null}         The independently-managed keyboard for the control.
             * Description  Returns the keyboard ID of the current independently-managed keyboard for this control.
             *              If it is currently following the global keyboard setting, returns null instead.
             */
            KeymanBase.prototype['getKeyboardForControl'] = function (Pelem) {
                this.domManager.getKeyboardForControl(Pelem);
            };
            /**
             * Function     getLanguageForControl
             * Scope        Public
             * @param       {Element}    Pelem    Control element
             * @return      {string|null}         The independently-managed keyboard for the control.
             * Description  Returns the language code used with the current independently-managed keyboard for this control.
             *              If it is currently following the global keyboard setting, returns null instead.
             */
            KeymanBase.prototype['getLanguageForControl'] = function (Pelem) {
                this.domManager.getLanguageForControl(Pelem);
            };
            /**
             * Set focus to last active target element (browser-dependent)
             */
            KeymanBase.prototype['focusLastActiveElement'] = function () {
                this.domManager.focusLastActiveElement();
            };
            /**
             * Get the last active target element *before* KMW activated (I1297)
             *
             * @return      {Object}
             */
            KeymanBase.prototype['getLastActiveElement'] = function () {
                return this.domManager.getLastActiveElement();
            };
            /**
             *  Set the active input element directly optionally setting focus
             *
             *  @param  {Object|string} e         element id or element
             *  @param  {boolean=}      setFocus  optionally set focus  (KMEW-123)
             **/
            KeymanBase.prototype['setActiveElement'] = function (e, setFocus) {
                return this.domManager.setActiveElement(e, setFocus);
            };
            /**
             * Move focus to user-specified element
             *
             *  @param  {string|Object}   e   element or element id
             *
             **/
            KeymanBase.prototype['moveToElement'] = function (e) {
                this.domManager.moveToElement(e);
            };
            /**
             * Function     addHotkey
             * Scope        Public
             * @param       {number}            keyCode
             * @param       {number}            shiftState
             * @param       {function(Object)}  handler
             * Description  Add hot key handler to array of document-level hotkeys triggered by key up event
             */
            KeymanBase.prototype['addHotKey'] = function (keyCode, shiftState, handler) {
                this.hotkeyManager.addHotKey(keyCode, shiftState, handler);
            };
            /**
             * Function     removeHotkey
             * Scope        Public
             * @param       {number}        keyCode
             * @param       {number}        shiftState
             * Description  Remove a hot key handler from array of document-level hotkeys triggered by key up event
             */
            KeymanBase.prototype['removeHotKey'] = function (keyCode, shiftState) {
                this.hotkeyManager.removeHotkey(keyCode, shiftState);
            };
            /**
             * Function     getUIState
             * Scope        Public
             * @return      {Object.<string,(boolean|number)>}
             * Description  Return object with activation state of UI:
             *                activationPending (bool):   KMW being activated
             *                activated         (bool):   KMW active
             */
            KeymanBase.prototype['getUIState'] = function () {
                return this.uiManager.getUIState();
            };
            /**
             * Set or clear the IsActivatingKeymanWebUI flag (exposed function)
             *
             * @param       {(boolean|number)}  state  Activate (true,false)
             */
            KeymanBase.prototype['activatingUI'] = function (state) {
                this.uiManager.setActivatingUI(state);
            };
            /**
             * Create copy of the OSK that can be used for embedding in documentation or help
             * The currently active keyboard will be returned if PInternalName is null
             *
             *  @param  {string}          PInternalName   internal name of keyboard, with or without Keyboard_ prefix
             *  @param  {number}          Pstatic         static keyboard flag  (unselectable elements)
             *  @param  {string=}         argFormFactor   layout form factor, defaulting to 'desktop'
             *  @param  {(string|number)=}  argLayerId    name or index of layer to show, defaulting to 'default'
             *  @return {Object}                          DIV object with filled keyboard layer content
             */
            KeymanBase.prototype['BuildVisualKeyboard'] = function (PInternalName, Pstatic, argFormFactor, argLayerId) {
                return com.keyman.osk.VisualKeyboard.buildDocumentationKeyboard(PInternalName, Pstatic, argFormFactor, argLayerId);
            };
            return KeymanBase;
        }());
        keyman.KeymanBase = KeymanBase;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/**
 * Determine path and protocol of executing script, setting them as
 * construction defaults.
 *
 * This can only be done during load when the active script will be the
 * last script loaded.  Otherwise the script must be identified by name.
*/
var scripts = document.getElementsByTagName('script');
var ss = scripts[scripts.length - 1].src;
var sPath = ss.substr(0, ss.lastIndexOf('/') + 1);
var KeymanBase = com.keyman.KeymanBase;
KeymanBase._srcPath = sPath;
KeymanBase._rootPath = sPath.replace(/(https?:\/\/)([^\/]*)(.*)/, '$1$2/');
KeymanBase._protocol = sPath.replace(/(.{3,5}:)(.*)/, '$1');
/** @define {number} build counter that gets set by the build environment */
KeymanBase.__BUILD__ = 299;
/**
 * Base code: Declare major component namespaces, instances, and utility functions
 */
// If a copy of the script is already loaded, detect this and prevent re-initialization / data reset.
if (!window['keyman'] || !window['keyman']['loaded']) {
    (function () {
        /* The base object call may need to be moved into a separate, later file eventually.
         * It will be necessary to override methods with kmwnative.ts and kmwembedded.ts before the
         * affected objects are initialized.
         *
         * We only recreate the 'keyman' object if it's not been loaded.
         * As this is the base object, not creating it prevents a KMW system reset.
         */
        window['keyman'] = com.keyman.singleton = new KeymanBase();
    })();
}
// Includes KMW-added property declaration extensions for HTML elements.
/// <reference path="kmwexthtml.ts" />
// Includes KMW string extension declarations.
/// <reference path="text/kmwstring.ts" />
// Includes type definitions for basic KMW types.
/// <reference path="kmwtypedefs.ts" />
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
// If KMW is already initialized, the KMW script has been loaded more than once. We wish to prevent resetting the 
// KMW system, so we use the fact that 'initialized' is only 1 / true after all scripts are loaded for the initial
// load of KMW.
if (!window['keyman']['initialized']) {
    // Continued KeymanWeb initialization.
    (function () {
        // Declare KeymanWeb, OnScreen Keyboard and Util object variables
        var keymanweb = window['keyman'], osk = keymanweb['osk'], util = keymanweb['util'], device = util.device;
        var kbdInterface = keymanweb['interface'];
        /**
         * Function     debug
         * Scope        Private
         * @param       {(string|Object)}     s   string (or object) to print
         * Description  Simple debug display (upper right of screen)
         *              Extended to support multiple arguments May 2015
         */
        keymanweb['debug'] = keymanweb.debug = function (s) {
            var p;
            if (keymanweb.debugElement == null) {
                var d = document.createElement('DIV'), ds = d.style;
                ds.position = 'absolute';
                ds.width = '30%';
                ds.maxHeight = '50%';
                ds.top = '0';
                ds.right = '0';
                ds.minHeight = '50px';
                ds.border = '1px solid blue';
                ds.whiteSpace = 'pre-line';
                ds.overflowY = 'scroll';
                p = document.createElement('P');
                p.id = 'debug_output';
                p.style.margin = '2px';
                d.appendChild(p);
                document.body.appendChild(d);
                keymanweb.debugElement = p;
            }
            if ((p = document.getElementById('debug_output')) == null)
                return;
            if (arguments.length == 0)
                if (typeof p.textContent != 'undefined')
                    p.textContent = '';
                else
                    p.innerHTML = '';
            else {
                var ts = new Date().toTimeString().substr(3, 5), t = ts + ' ', t1, k, m, sx;
                for (k = 0; k < arguments.length; k++) {
                    if (k > 0)
                        t = t + '; ';
                    sx = arguments[k];
                    if (typeof sx == 'object') {
                        if (sx == null) {
                            t = t + 'null';
                        }
                        else {
                            t1 = '';
                            for (m in sx) {
                                if (t1.length > 0)
                                    t1 = t1 + ', ';
                                t1 = t1 + m + ':';
                                switch (typeof sx[m]) {
                                    case 'string':
                                    case 'number':
                                    case 'boolean':
                                        t1 = t1 + sx[m];
                                        break;
                                    default:
                                        t1 = t1 + typeof sx[m];
                                        break;
                                }
                                if (t1.length > 1024) {
                                    t1 = t1.substr(0, 1000) + '...';
                                    break;
                                }
                            }
                            if (t1.length > 0)
                                t = t + '{' + t1 + '}';
                        }
                    }
                    else {
                        t = t + sx;
                    }
                }
                // Truncate if necessary to avoid memory problems
                if (t.length > 1500)
                    t = t.substr(0, 1500) + ' (more)';
                if (typeof p.textContent != 'undefined')
                    p.textContent = t + '\n' + p.textContent;
                else
                    p.innerHTML = t + '<br />' + p.innerHTML;
            }
        };
        /*
         * The following code existed here as part of the original pre-conversion JavaScript source, performing some inline initialization.
         * Ideally, this will be refactored once proper object-orientation of the codebase within TypeScript is complete.
         */
        keymanweb.debugElement = null;
        var dbg = keymanweb.debug;
        keymanweb.delayedInit();
        // I732 START - Support for European underlying keyboards #1
        if (typeof (window['KeymanWeb_BaseLayout']) !== 'undefined')
            com.keyman.osk.Layouts._BaseLayout = window['KeymanWeb_BaseLayout'];
        else
            com.keyman.osk.Layouts._BaseLayout = 'us';
        keymanweb._BrowserIsSafari = (navigator.userAgent.indexOf('AppleWebKit') >= 0); // I732 END - Support for European underlying keyboards #1      
        //TODO: find all references to next three routines and disambiguate!!
        // Complete page initialization only after the page is fully loaded, including any embedded fonts
        // This avoids the need to use a timer to test for the fonts
        util.attachDOMEvent(window, 'load', keymanweb.domManager._WindowLoad, false);
        util.attachDOMEvent(window, 'unload', keymanweb.domManager._WindowUnload, false); // added fourth argument (default value)       
        // *** I3319 Supplementary Plane modifications - end new code
        util.attachDOMEvent(document, 'keyup', keymanweb.hotkeyManager._Process, false);
        // We need to track this handler, as it causes... interesting... interactions during testing in certain browsers.
        keymanweb['pageFocusHandler'] = keymanweb.interface.resetVKShift.bind(keymanweb.interface);
        util.attachDOMEvent(window, 'focus', keymanweb['pageFocusHandler'], false); // I775
        util.attachDOMEvent(window, 'blur', keymanweb['pageFocusHandler'], false); // I775
        // Initialize supplementary plane string extensions
        String.kmwEnableSupplementaryPlane(false);
    })();
}
// References the base KMW object.
/// <reference path="kmwbase.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman_17) {
        var RotationState = /** @class */ (function () {
            function RotationState() {
                this.innerWidth = window.innerWidth;
                this.innerHeight = window.innerHeight;
            }
            RotationState.prototype.equals = function (other) {
                return this.innerWidth == other.innerWidth && this.innerHeight == other.innerHeight;
            };
            return RotationState;
        }());
        // Please reference /testing/rotation-events/index.html and update it as necessary when maintaining this class.
        var RotationManager = /** @class */ (function () {
            // --------------------
            function RotationManager(keyman) {
                // Tracks the number of idle 'update' iterations since the last permutation.
                this.idlePermutationCounter = RotationManager.IDLE_PERMUTATION_CAP;
                this.keyman = keyman;
            }
            RotationManager.prototype.resolve = function () {
                this.keyman.alignInputs();
                var osk = this.keyman.osk;
                // TODO:  Reattach later in the refactoring process!
                //osk.hideLanguageList();
                osk._Load();
                if (this.oskVisible) {
                    osk._Show();
                }
                this.isActive = false;
                // If we've been using an update interval loop, we should clear the state information.
                if (this.updateTimer) {
                    window.clearInterval(this.updateTimer);
                    this.rotState = null;
                }
            };
            // Used by both Android and iOS.
            RotationManager.prototype.initNewRotation = function () {
                this.oskVisible = this.keyman.osk.isVisible();
                this.keyman.osk.hideNow();
                this.isActive = true;
            };
            /**
             * Establishes rotation-oriented event handling for native-mode KeymanWeb.  At this time, tablet PCs are not directly supported.
             */
            RotationManager.prototype.init = function () {
                // If we're in embedded mode, we really should NOT run this method.
                if (this.keyman.isEmbedded) {
                    return;
                }
                // Note:  we use wrapper functions instead of `.bind(this)` in this method to facilitate stubbing for our rotation test page.
                var os = this.keyman.util.device.OS;
                var util = this.keyman.util;
                var rotationManager = this;
                if (os == 'iOS') {
                    /* iOS is rather inconsistent about these events, with changes to important window state information -
                     * especially to `window.innerWidth` - possible after the events trigger!  They don't always trigger
                     * the same amount or in a consistently predictable manner.
                     *
                     * The overall idea is to wait out all those changes so that we don't produce a bad keyboard layout.
                     */
                    util.attachDOMEvent(window, 'orientationchange', function () {
                        rotationManager.iOSEventHandler();
                        return false;
                    });
                    util.attachDOMEvent(window, 'resize', function () {
                        rotationManager.iOSEventHandler();
                        return false;
                    });
                }
                else if (os == 'Android') {
                    // Android's far more consistent with its event generation than iOS.
                    if ('onmozorientationchange' in screen) {
                        util.attachDOMEvent(screen, 'mozorientationchange', function () {
                            rotationManager.initNewRotation();
                            return false;
                        });
                    }
                    else {
                        util.attachDOMEvent(window, 'orientationchange', function () {
                            rotationManager.initNewRotation();
                            return false;
                        });
                    }
                    util.attachDOMEvent(window, 'resize', function () {
                        rotationManager.resolve();
                        return false;
                    });
                }
            };
            RotationManager.prototype.iOSEventHandler = function () {
                if (!this.isActive) {
                    this.initNewRotation();
                    this.rotState = new RotationState();
                    this.updateTimer = window.setInterval(this.iOSEventUpdate.bind(this), RotationManager.UPDATE_INTERVAL);
                }
                // If one of the rotation-oriented events just triggered, we should ALWAYS reset the counter.
                this.idlePermutationCounter = 0;
            };
            RotationManager.prototype.iOSEventUpdate = function () {
                var newState = new RotationState();
                if (this.rotState.equals(newState)) {
                    if (++this.idlePermutationCounter == RotationManager.IDLE_PERMUTATION_CAP) {
                        this.resolve();
                    }
                }
                else {
                    this.rotState = newState;
                    this.idlePermutationCounter = 0;
                }
            };
            // iOS-oriented members 
            // --------------------
            // We'll assume permutations are complete after this many 'update' iterations.
            RotationManager.IDLE_PERMUTATION_CAP = 15;
            RotationManager.UPDATE_INTERVAL = 20; // 20 ms, that is.
            return RotationManager;
        }());
        keyman_17.RotationManager = RotationManager;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Includes KMW string extension declarations.
/// <reference path="text/kmwstring.ts" />
// Contains event management for mobile device rotation events.
/// <reference path="kmwrotation.ts" />
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
// If KMW is already initialized, the KMW script has been loaded more than once. We wish to prevent resetting the 
// KMW system, so we use the fact that 'initialized' is only 1 / true after all scripts are loaded for the initial
// load of KMW.
if (!window['keyman']['initialized']) {
    /*****************************************/
    /*                                       */
    /*   On-Screen (Visual) Keyboard Code    */
    /*                                       */
    /*****************************************/
    (function () {
        // Declare KeymanWeb object
        var keymanweb = window['keyman'], osk = keymanweb['osk'], util = keymanweb['util'], device = util.device;
        var dbg = keymanweb.debug;
        var dom = com.keyman.dom;
        // Force full initialization
        keymanweb.isEmbedded = false;
        /**
         * Set default device options
         * @param {Object}  opt device options object
         */
        keymanweb.setDefaultDeviceOptions = function (opt) {
            // Element attachment type
            if (opt['attachType'] == '')
                opt['attachType'] = (device.touchable ? 'manual' : 'auto');
        };
        /**
           * Customized wait display
           *
           * @param   {string|boolean}   s       displayed text (or false)
           */
        util.wait = function (s) {
            // Keyboards loaded with page are initialized before the page is ready,
            // so cannot use the wait indicater (and don't need it, anyway)
            // Do not display if a blocking cloud server error has occurred (to prevent multiple errors)
            var bg = this.waiting;
            if (typeof (bg) == 'undefined' || bg == null || keymanweb.warned) {
                return;
            }
            var nn = bg.firstChild.childNodes;
            if (s) {
                bg.pending = true;
                window.setTimeout(function () {
                    if (bg.pending) {
                        window.scrollTo(0, 0);
                        nn[0].style.display = 'none';
                        nn[1].className = 'kmw-wait-text';
                        nn[1].innerHTML = s;
                        nn[2].style.display = 'block';
                        bg.style.display = 'block';
                    }
                }, 1000);
            }
            else {
                if (bg.pending) {
                    nn[1].innerHTML = '';
                    bg.pending = false;
                    bg.style.display = 'none';
                }
            }
        };
        // Get default style sheet path
        keymanweb.getStyleSheetPath = function (ssName) {
            var ssPath = util['getOption']('resources') + 'osk/' + ssName;
            return ssPath;
        };
        /**
         * Get keyboard path (relative or absolute)
         * KeymanWeb 2 revised keyboard location specification:
         *  (a) absolute URL (includes ':') - load from specified URL
         *  (b) relative URL (starts with /, ./, ../) - load with respect to current page
         *  (c) filename only (anything else) - prepend keyboards option to URL
         *      (e.g. default keyboards option will be set by Cloud)
         *
         * @param {string}  Lfilename  keyboard file name with optional prefix
         */
        keymanweb.getKeyboardPath = function (Lfilename) {
            var rx = RegExp('^(([\\.]/)|([\\.][\\.]/)|(/))|(:)');
            return (rx.test(Lfilename) ? '' : keymanweb.options['keyboards']) + Lfilename;
        };
        /**
         * Align input fields (should not be needed with KMEI, KMEA), making them visible if previously hidden.
         *
         *  @param  {object}   eleList    A list of specific elements to align.  If nil, selects all elements.
         *
         **/
        keymanweb.alignInputs = function (eleList) {
            if (device.touchable) {
                var domManager = keymanweb.domManager;
                var processList = [];
                if (eleList) {
                    // Did the user specify the actual element or the touch-alias?
                    eleList.forEach(function (element) {
                        if (element.base) {
                            // It's a touch-alias element, which is what we wish to perform alignment on.
                            processList.push(element);
                        }
                        else {
                            // This retrieves an element's touch-alias, should it exist.
                            var touchAlias = element['kmw_ip'];
                            if (touchAlias) {
                                processList.push(element['kmw_ip']);
                            }
                        }
                    });
                }
                else {
                    processList = domManager.inputList;
                }
                // Supported by IE 9 and all modern browsers.
                processList.forEach(function (element) {
                    if (dom.Utils.instanceof(element, "TouchAliasElement")) {
                        element.updateInput();
                    }
                    element.style.visibility = 'visible';
                    if (element.base.textContent.length > 0) {
                        element.base.style.visibility = 'hidden';
                    }
                });
            }
        };
        /**
         * Programatically hides all input fields with underlying elements.  Restore with .alignInputs.
         *
         *  @param  {boolean}   align    align and make visible, else hide
         *
         **/
        keymanweb.hideInputs = function () {
            var domManager = keymanweb.domManager;
            if (device.touchable) {
                for (var i = 0; i < domManager.inputList.length; i++) {
                    domManager.inputList[i].style.visibility = 'hidden';
                    domManager.inputList[i].base.style.visibility = 'visible';
                }
            }
        };
        /**
         * Test if caret position is determined from the active element, or
         * from the synthesized overlay element (touch devices)
         *
         * @return  {boolean}
         **/
        keymanweb.isPositionSynthesized = function () {
            return device.touchable;
        };
        /**
         * Use rotation events to adjust OSK and input element positions and scaling as necessary
         */
        keymanweb.handleRotationEvents = function () {
            var rotationManager = new com.keyman.RotationManager(keymanweb);
            rotationManager.init();
        };
        /**
         * Possible way to detect the start of a rotation and hide the OSK before it is adjusted in size
         *
         *  @param  {Object}    e   accelerometer rotation event
         *
        keymanweb.testRotation = function(e)
        {
          var r=e.rotationRate;
          if(typeof(r) != 'undefined')
          {
            dbg(r.alpha+' '+r.beta+' '+r.gamma);
          }
        }
        */
    })();
}
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
/********************************************************/
/*                                                      */
/* Automatically initialize keymanweb with defaults     */
/* after the page is fully loaded                       */
/*                                                      */
/********************************************************/
(function () {
    // Declare KeymanWeb object
    var keymanweb = window['keyman'];
    // We don't want to instantly init() in case this code is used via bookmarklet.
    var readyStateCheckInterval = window.setInterval(function () {
        if (document.readyState === "complete") {
            window.clearInterval(readyStateCheckInterval);
            keymanweb.init(null);
        }
    }, 10);
})();
/// <reference path="kmwbase.ts" />
/// <reference path="kmwutils.ts" />
/// <reference path="text/kbdInterface.ts" />
/**
 * This file generates aliases linking renamed functions to some of our published developer API for KMW.
 * This won't enable Closure to do "advanced minification", but it's useful for ensuring we don't break
 * things people depended on in legacy versions.
 */
// Util.ts
(function () {
    var prototype = com.keyman.Util.prototype;
    var publishAPI = function (legacyName, name) {
        prototype[legacyName] = prototype[name];
    };
    // These four were renamed, but we need to maintain their legacy names.
    publishAPI("_GetAbsoluteX", 'getAbsoluteX');
    publishAPI("_GetAbsoluteY", "getAbsoluteY");
    publishAPI("_GetAbsolute", "getAbsolute");
    publishAPI("toNzString", "nzString");
}());
// Keyboard callbacks
(function () {
    var prototype = com.keyman.text.KeyboardInterface.prototype;
    var exportKBCallback = function (miniName, longName) {
        prototype[miniName] = prototype[longName];
    };
    exportKBCallback('KSF', 'saveFocus');
    exportKBCallback('KBR', 'beepReset');
    exportKBCallback('KT', 'insertText');
    exportKBCallback('KR', 'registerKeyboard');
    exportKBCallback('KRS', 'registerStub');
    exportKBCallback('KC', 'context');
    exportKBCallback('KN', 'nul');
    exportKBCallback('KCM', 'contextMatch');
    exportKBCallback('KFCM', 'fullContextMatch');
    exportKBCallback('KIK', 'isKeypress');
    exportKBCallback('KKM', 'keyMatch');
    exportKBCallback('KSM', 'stateMatch');
    exportKBCallback('KKI', 'keyInformation');
    exportKBCallback('KDM', 'deadkeyMatch');
    exportKBCallback('KB', 'beep');
    exportKBCallback('KA', 'any');
    exportKBCallback('KDC', 'deleteContext');
    exportKBCallback('KO', 'output');
    exportKBCallback('KDO', 'deadkeyOutput');
    exportKBCallback('KIO', 'indexOutput');
    exportKBCallback('KIFS', 'ifStore');
    exportKBCallback('KSETS', 'setStore');
    exportKBCallback('KLOAD', 'loadStore');
    exportKBCallback('KSAVE', 'saveStore');
}());
//# sourceMappingURL=keymanweb.js.map